#!/usr/bin/env python3
"""
SYNTHEX Chapter Detection Engine - Agent 2 Text Analysis Specialization
Comprehensive algorithms for detecting chapters and document structure
across various formats and edge cases
"""

import re
from typing import List, Dict, Tuple, Optional, Union, Any
from dataclasses import dataclass, field
from enum import Enum
from pathlib import Path
import json
import xml.etree.ElementTree as ET
from abc import ABC, abstractmethod


class DocumentType(Enum):
    """Supported document types for chapter detection"""
    TRADITIONAL_BOOK = "traditional_book"
    ACADEMIC_PAPER = "academic_paper"
    TECHNICAL_DOCUMENTATION = "technical_doc"
    MARKDOWN = "markdown"
    HTML = "html"
    EPUB = "epub"
    PDF = "pdf"\n    PLAIN_TEXT = "plain_text"\n    LATEX = "latex"\n\n\nclass NumberingSystem(Enum):\n    """Different numbering systems for chapters/sections"""\n    ARABIC = "arabic"  # 1, 2, 3\n    ROMAN = "roman"   # I, II, III\n    ALPHABETIC = "alphabetic"  # A, B, C\n    WORD = "word"     # One, Two, Three\n    MIXED = "mixed"   # Combination\n    NONE = "none"     # No numbering\n\n\n@dataclass\nclass StructureElement:\n    """Represents a structural element in a document"""\n    level: int  # 0 for top-level (parts), 1 for chapters, 2 for sections, etc.\n    type: str   # "part", "chapter", "section", "subsection"\n    number: Optional[str] = None\n    title: Optional[str] = None\n    start_position: int = 0\n    end_position: Optional[int] = None\n    content: str = ""\n    metadata: Dict[str, Any] = field(default_factory=dict)\n    children: List['StructureElement'] = field(default_factory=list)\n\n\n@dataclass\nclass DetectionPattern:\n    """Pattern configuration for detecting structural elements"""\n    pattern: str  # Regex pattern\n    level: int    # Hierarchy level\n    type: str     # Element type\n    numbering_system: NumberingSystem\n    confidence: float = 1.0\n    requires_title: bool = True\n    case_sensitive: bool = False\n\n\nclass BaseDetector(ABC):\n    """Abstract base class for document structure detectors"""\n\n    def __init__(self):\n        self.patterns: List[DetectionPattern] = []\n        self._initialize_patterns()\n\n    @abstractmethod\n    def _initialize_patterns(self):\n        """Initialize detection patterns for specific document type"""\n        pass\n\n    @abstractmethod\n    def detect_structure(self, content: str) -> List[StructureElement]:\n        """Detect document structure from content"""\n        pass\n\n    def extract_number(self, text: str, numbering_system: NumberingSystem) -> Optional[str]:\n        """Extract number from text based on numbering system"""\n        if numbering_system == NumberingSystem.ARABIC:\n            match = re.search(r'\d+', text)\n            return match.group() if match else None\n        elif numbering_system == NumberingSystem.ROMAN:\n            match = re.search(r'\b[IVXLCDM]+\b', text, re.IGNORECASE)\n            return match.group().upper() if match else None\n        elif numbering_system == NumberingSystem.ALPHABETIC:\n            match = re.search(r'\b[A-Z]\b', text, re.IGNORECASE)\n            return match.group().upper() if match else None\n        elif numbering_system == NumberingSystem.WORD:\n            word_numbers = {\n                'one': '1', 'two': '2', 'three': '3', 'four': '4', 'five': '5',\n                'six': '6', 'seven': '7', 'eight': '8', 'nine': '9', 'ten': '10',\n                'eleven': '11', 'twelve': '12', 'thirteen': '13', 'fourteen': '14',\n                'fifteen': '15', 'sixteen': '16', 'seventeen': '17', 'eighteen': '18',\n                'nineteen': '19', 'twenty': '20'\n            }\n            text_lower = text.lower()\n            for word, num in word_numbers.items():\n                if word in text_lower:\n                    return num\n        return None\n\n\nclass TraditionalBookDetector(BaseDetector):\n    """Detector for traditional book formats"""\n\n    def _initialize_patterns(self):\n        """Initialize patterns for traditional books"""\n        # Part patterns\n        self.patterns.extend([\n            DetectionPattern(\n                r'^(?:PART|Part)\s+([IVXLCDM]+)(?:\s*[:\-–—]\s*(.+))?$',\n                0, "part", NumberingSystem.ROMAN, 0.95\n            ),\n            DetectionPattern(\n                r'^(?:BOOK|Book)\s+([IVXLCDM]+)(?:\s*[:\-–—]\s*(.+))?$',\n                0, "book", NumberingSystem.ROMAN, 0.95\n            ),\n        ])\n\n        # Chapter patterns\n        self.patterns.extend([\n            # Standard chapter patterns\n            DetectionPattern(\n                r'^(?:CHAPTER|Chapter|CHAP|Chap)\s+(\d+)(?:\s*[:\-–—]\s*(.+))?$',\n                1, "chapter", NumberingSystem.ARABIC, 0.95\n            ),\n            DetectionPattern(\n                r'^(?:CHAPTER|Chapter)\s+([IVXLCDM]+)(?:\s*[:\-–—]\s*(.+))?$',\n                1, "chapter", NumberingSystem.ROMAN, 0.90\n            ),\n            DetectionPattern(\n                r'^(?:CHAPTER|Chapter)\s+(One|Two|Three|Four|Five|Six|Seven|Eight|Nine|Ten|Eleven|Twelve|Thirteen|Fourteen|Fifteen|Sixteen|Seventeen|Eighteen|Nineteen|Twenty)(?:\s*[:\-–—]\s*(.+))?$',\n                1, "chapter", NumberingSystem.WORD, 0.85, case_sensitive=False\n            ),\n            # Numeric only patterns\n            DetectionPattern(\n                r'^(\d+)\.\s+(.+)$',\n                1, "chapter", NumberingSystem.ARABIC, 0.70\n            ),\n            DetectionPattern(\n                r'^([IVXLCDM]+)\.\s+(.+)$',\n                1, "chapter", NumberingSystem.ROMAN, 0.70\n            ),\n            # Centered chapter indicators\n            DetectionPattern(\n                r'^\s{10,}(?:CHAPTER|Chapter)\s+(\d+)\s*$',\n                1, "chapter", NumberingSystem.ARABIC, 0.80, requires_title=False\n            ),\n        ])\n\n        # Section patterns\n        self.patterns.extend([\n            DetectionPattern(\n                r'^(\d+)\.(\d+)\.?\s+(.+)$',\n                2, "section", NumberingSystem.ARABIC, 0.85\n            ),\n            DetectionPattern(\n                r'^(?:Section|SECTION)\s+(\d+)(?:\s*[:\-–—]\s*(.+))?$',\n                2, "section", NumberingSystem.ARABIC, 0.90\n            ),\n        ])\n\n    def detect_structure(self, content: str) -> List[StructureElement]:\n        """Detect structure in traditional book format"""\n        lines = content.split('\n')\n        elements = []\n        current_positions = {0: 0, 1: 0, 2: 0}  # Track position for each level\n\n        for i, line in enumerate(lines):\n            line = line.strip()\n            if not line:\n                continue\n\n            for pattern_def in self.patterns:\n                flags = 0 if pattern_def.case_sensitive else re.IGNORECASE\n                match = re.match(pattern_def.pattern, line, flags)\n\n                if match:\n                    # Extract components\n                    groups = match.groups()\n                    number = None\n                    title = None\n\n                    if pattern_def.numbering_system != NumberingSystem.NONE:\n                        if groups:\n                            number = self.extract_number(groups[0], pattern_def.numbering_system)\n\n                    if len(groups) > 1 and groups[-1]:\n                        title = groups[-1].strip()\n                    elif not pattern_def.requires_title:\n                        # Look for title in next non-empty lines\n                        for j in range(i + 1, min(i + 5, len(lines))):\n                            next_line = lines[j].strip()\n                            if next_line and not any(p.pattern for p in self.patterns if re.match(p.pattern, next_line)):\n                                title = next_line\n                                break\n\n                    # Create element\n                    element = StructureElement(\n                        level=pattern_def.level,\n                        type=pattern_def.type,\n                        number=number,\n                        title=title,\n                        start_position=i,\n                        metadata={\n                            'confidence': pattern_def.confidence,\n                            'numbering_system': pattern_def.numbering_system.value,\n                            'raw_match': line\n                        }\n                    )\n\n                    elements.append(element)\n                    current_positions[pattern_def.level] = len(elements) - 1\n                    break\n\n        # Build hierarchy\n        return self._build_hierarchy(elements)\n\n    def _build_hierarchy(self, elements: List[StructureElement]) -> List[StructureElement]:\n        """Build hierarchical structure from flat list of elements"""\n        if not elements:\n            return []\n\n        # Sort by position and level\n        elements.sort(key=lambda x: (x.start_position, x.level))\n\n        root_elements = []\n        stack = []\n\n        for element in elements:\n            # Find parent\n            while stack and stack[-1].level >= element.level:\n                stack.pop()\n\n            if stack:\n                stack[-1].children.append(element)\n            else:\n                root_elements.append(element)\n\n            stack.append(element)\n\n        return root_elements\n\n\nclass AcademicPaperDetector(BaseDetector):\n    """Detector for academic papers and research documents"""\n\n    def _initialize_patterns(self):\n        """Initialize patterns for academic papers"""\n        self.patterns = [\n            # Abstract\n            DetectionPattern(\n                r'^(?:Abstract|ABSTRACT)\s*$',\n                1, "abstract", NumberingSystem.NONE, 0.95, requires_title=False\n            ),\n            # Numbered sections\n            DetectionPattern(\n                r'^(\d+)\.?\s+(.+)$',\n                1, "section", NumberingSystem.ARABIC, 0.85\n            ),\n            DetectionPattern(\n                r'^(\d+)\.(\d+)\.?\s+(.+)$',\n                2, "subsection", NumberingSystem.ARABIC, 0.85\n            ),\n            DetectionPattern(\n                r'^(\d+)\.(\d+)\.(\d+)\.?\s+(.+)$',\n                3, "subsubsection", NumberingSystem.ARABIC, 0.85\n            ),\n            # Named sections\n            DetectionPattern(\n                r'^(?:Introduction|INTRODUCTION)\s*$',\n                1, "introduction", NumberingSystem.NONE, 0.90, requires_title=False\n            ),\n            DetectionPattern(\n                r'^(?:Methodology|Methods|METHODOLOGY|METHODS)\s*$',\n                1, "methodology", NumberingSystem.NONE, 0.90, requires_title=False\n            ),\n            DetectionPattern(\n                r'^(?:Results|RESULTS)\s*$',\n                1, "results", NumberingSystem.NONE, 0.90, requires_title=False\n            ),\n            DetectionPattern(\n                r'^(?:Discussion|DISCUSSION)\s*$',\n                1, "discussion", NumberingSystem.NONE, 0.90, requires_title=False\n            ),\n            DetectionPattern(\n                r'^(?:Conclusion|Conclusions|CONCLUSION|CONCLUSIONS)\s*$',\n                1, "conclusion", NumberingSystem.NONE, 0.90, requires_title=False\n            ),\n            DetectionPattern(\n                r'^(?:References|Bibliography|REFERENCES|BIBLIOGRAPHY)\s*$',\n                1, "references", NumberingSystem.NONE, 0.95, requires_title=False\n            ),\n            DetectionPattern(\n                r'^(?:Appendix|APPENDIX)\s*([A-Z])?(?:\s*[:\-–—]\s*(.+))?$',\n                1, "appendix", NumberingSystem.ALPHABETIC, 0.85\n            ),\n        ]\n\n    def detect_structure(self, content: str) -> List[StructureElement]:\n        """Detect structure in academic paper format"""\n        lines = content.split('\n')\n        elements = []\n\n        for i, line in enumerate(lines):\n            line = line.strip()\n            if not line:\n                continue\n\n            for pattern_def in self.patterns:\n                match = re.match(pattern_def.pattern, line, re.IGNORECASE)\n\n                if match:\n                    element = StructureElement(\n                        level=pattern_def.level,\n                        type=pattern_def.type,\n                        number=self._extract_section_number(match, pattern_def),\n                        title=self._extract_section_title(match, pattern_def, line),\n                        start_position=i,\n                        metadata={\n                            'confidence': pattern_def.confidence,\n                            'pattern_type': pattern_def.type\n                        }\n                    )\n                    elements.append(element)\n                    break\n\n        return self._build_hierarchy(elements)\n\n    def _extract_section_number(self, match, pattern_def):\n        """Extract section number from match"""\n        if pattern_def.numbering_system == NumberingSystem.NONE:\n            return None\n        groups = match.groups()\n        if groups and groups[0]:\n            if pattern_def.numbering_system == NumberingSystem.ARABIC:\n                # Handle multi-level numbering\n                if '.' in match.group(0):\n                    return match.group(0).split()[0].rstrip('.')\n                return groups[0]\n            elif pattern_def.numbering_system == NumberingSystem.ALPHABETIC:\n                return groups[0]\n        return None\n\n    def _extract_section_title(self, match, pattern_def, line):\n        """Extract section title from match"""\n        if pattern_def.type in ['abstract', 'introduction', 'methodology', 'results', 'discussion', 'conclusion', 'references']:\n            return pattern_def.type.title()\n\n        groups = match.groups()\n        if groups:\n            # Find the title group (usually the last non-None group)\n            for group in reversed(groups):\n                if group and not group.isdigit() and group not in 'ABCDEFGHIJKLMNOPQRSTUVWXYZ':\n                    return group.strip()\n\n        return line\n\n    def _build_hierarchy(self, elements: List[StructureElement]) -> List[StructureElement]:\n        """Build hierarchy for academic structure"""\n        if not elements:\n            return []\n\n        # Academic papers usually have a flatter structure\n        root_elements = []\n        current_section = None\n\n        for element in elements:\n            if element.level == 1:\n                root_elements.append(element)\n                current_section = element\n            elif element.level > 1 and current_section:\n                parent = current_section\n                # Find appropriate parent based on level\n                for _ in range(element.level - 2):\n                    if parent.children:\n                        parent = parent.children[-1]\n                    else:\n                        break\n                parent.children.append(element)\n            else:\n                root_elements.append(element)\n\n        return root_elements\n\n\nclass MarkdownDetector(BaseDetector):\n    """Detector for Markdown documents"""\n\n    def _initialize_patterns(self):\n        """Initialize patterns for Markdown"""\n        self.patterns = [\n            # Headers with # syntax\n            DetectionPattern(\n                r'^(#{1})\s+(.+)$',\n                1, "h1", NumberingSystem.NONE, 0.95, requires_title=False\n            ),\n            DetectionPattern(\n                r'^(#{2})\s+(.+)$',\n                2, "h2", NumberingSystem.NONE, 0.95, requires_title=False\n            ),\n            DetectionPattern(\n                r'^(#{3})\s+(.+)$',\n                3, "h3", NumberingSystem.NONE, 0.95, requires_title=False\n            ),\n            DetectionPattern(\n                r'^(#{4})\s+(.+)$',\n                4, "h4", NumberingSystem.NONE, 0.95, requires_title=False\n            ),\n            DetectionPattern(\n                r'^(#{5})\s+(.+)$',\n                5, "h5", NumberingSystem.NONE, 0.95, requires_title=False\n            ),\n            DetectionPattern(\n                r'^(#{6})\s+(.+)$',\n                6, "h6", NumberingSystem.NONE, 0.95, requires_title=False\n            ),\n            # Setext-style headers\n            DetectionPattern(\n                r'^(.+)\n={3,}\s*$',\n                1, "h1", NumberingSystem.NONE, 0.90, requires_title=False\n            ),\n            DetectionPattern(\n                r'^(.+)\n-{3,}\s*$',\n                2, "h2", NumberingSystem.NONE, 0.90, requires_title=False\n            ),\n        ]\n\n    def detect_structure(self, content: str) -> List[StructureElement]:\n        """Detect structure in Markdown format"""\n        lines = content.split('\n')\n        elements = []\n        i = 0\n\n        while i < len(lines):\n            line = lines[i]\n\n            # Check for ATX headers (# syntax)\n            atx_match = re.match(r'^(#{1,6})\s+(.+)$', line)\n            if atx_match:\n                level = len(atx_match.group(1))\n                title = atx_match.group(2).strip()\n\n                # Extract any numbering from title\n                number = None\n                number_match = re.match(r'^(\d+(?:\.\d+)*)\s+(.+)$', title)\n                if number_match:\n                    number = number_match.group(1)\n                    title = number_match.group(2)\n\n                element = StructureElement(\n                    level=level,\n                    type=f"h{level}",\n                    number=number,\n                    title=title,\n                    start_position=i,\n                    metadata={'style': 'atx', 'raw_header': line}\n                )\n                elements.append(element)\n                i += 1\n                continue\n\n            # Check for Setext headers\n            if i + 1 < len(lines):\n                next_line = lines[i + 1]\n                if re.match(r'^={3,}\s*$', next_line):\n                    element = StructureElement(\n                        level=1,\n                        type="h1",\n                        title=line.strip(),\n                        start_position=i,\n                        metadata={'style': 'setext'}\n                    )\n                    elements.append(element)\n                    i += 2\n                    continue\n                elif re.match(r'^-{3,}\s*$', next_line):\n                    element = StructureElement(\n                        level=2,\n                        type="h2",\n                        title=line.strip(),\n                        start_position=i,\n                        metadata={'style': 'setext'}\n                    )\n                    elements.append(element)\n                    i += 2\n                    continue\n\n            i += 1\n\n        return self._build_hierarchy(elements)\n\n    def _build_hierarchy(self, elements: List[StructureElement]) -> List[StructureElement]:\n        """Build hierarchy from flat list"""\n        if not elements:\n            return []\n\n        root_elements = []\n        stack = []\n\n        for element in elements:\n            # Pop elements from stack until we find parent level\n            while stack and stack[-1].level >= element.level:\n                stack.pop()\n\n            if stack:\n                stack[-1].children.append(element)\n            else:\n                root_elements.append(element)\n\n            stack.append(element)\n\n        return root_elements\n\n\nclass TechnicalDocDetector(BaseDetector):\n    """Detector for technical documentation"""\n\n    def _initialize_patterns(self):\n        """Initialize patterns for technical docs"""\n        self.patterns = [\n            # Numbered sections with dots\n            DetectionPattern(\n                r'^(\d+)\.\s+(.+)$',\n                1, "section", NumberingSystem.ARABIC, 0.90\n            ),\n            DetectionPattern(\n                r'^(\d+)\.(\d+)\.\s+(.+)$',\n                2, "subsection", NumberingSystem.ARABIC, 0.90\n            ),\n            DetectionPattern(\n                r'^(\d+)\.(\d+)\.(\d+)\.\s+(.+)$',\n                3, "subsubsection", NumberingSystem.ARABIC, 0.90\n            ),\n            # API documentation patterns\n            DetectionPattern(\n                r'^(?:Class|CLASS)\s+(.+)$',\n                1, "class", NumberingSystem.NONE, 0.85\n            ),\n            DetectionPattern(\n                r'^(?:Function|Method|FUNCTION|METHOD)\s+(.+)$',\n                2, "function", NumberingSystem.NONE, 0.85\n            ),\n            DetectionPattern(\n                r'^(?:Parameters|Arguments|PARAMETERS|ARGUMENTS):?\s*$',\n                3, "parameters", NumberingSystem.NONE, 0.80, requires_title=False\n            ),\n            DetectionPattern(\n                r'^(?:Returns|RETURNS):?\s*$',\n                3, "returns", NumberingSystem.NONE, 0.80, requires_title=False\n            ),\n            # Code examples\n            DetectionPattern(\n                r'^(?:Example|EXAMPLE)\s*(\d+)?:?\s*(.*)$',\n                2, "example", NumberingSystem.ARABIC, 0.75\n            ),\n            # Notes and warnings\n            DetectionPattern(\n                r'^(?:Note|NOTE|Warning|WARNING|Important|IMPORTANT):?\s*(.*)$',\n                3, "note", NumberingSystem.NONE, 0.70\n            ),\n        ]\n\n    def detect_structure(self, content: str) -> List[StructureElement]:\n        """Detect structure in technical documentation"""\n        lines = content.split('\n')\n        elements = []\n        in_code_block = False\n        code_fence_pattern = re.compile(r'^```')\n\n        for i, line in enumerate(lines):\n            # Skip code blocks\n            if code_fence_pattern.match(line):\n                in_code_block = not in_code_block\n                continue\n\n            if in_code_block:\n                continue\n\n            line = line.strip()\n            if not line:\n                continue\n\n            for pattern_def in self.patterns:\n                match = re.match(pattern_def.pattern, line, re.IGNORECASE)\n\n                if match:\n                    element = self._create_element_from_match(match, pattern_def, i, line)\n                    elements.append(element)\n                    break\n\n        return self._build_hierarchy(elements)\n\n    def _create_element_from_match(self, match, pattern_def, position, line):\n        """Create structure element from regex match"""\n        groups = match.groups()\n\n        # Extract number if present\n        number = None\n        if pattern_def.numbering_system == NumberingSystem.ARABIC:\n            for g in groups:\n                if g and g.isdigit():\n                    number = g\n                    break\n\n        # Extract title\n        title = None\n        if groups:\n            # Get the last non-empty, non-numeric group\n            for g in reversed(groups):\n                if g and not (g.isdigit() and number == g):\n                    title = g.strip()\n                    break\n\n        if not title and not pattern_def.requires_title:\n            title = pattern_def.type.title()\n\n        return StructureElement(\n            level=pattern_def.level,\n            type=pattern_def.type,\n            number=number,\n            title=title or line,\n            start_position=position,\n            metadata={\n                'confidence': pattern_def.confidence,\n                'pattern': pattern_def.pattern\n            }\n        )\n\n    def _build_hierarchy(self, elements: List[StructureElement]) -> List[StructureElement]:\n        """Build technical documentation hierarchy"""\n        if not elements:\n            return []\n\n        root_elements = []\n        stack = []\n\n        for element in elements:\n            # Special handling for technical doc structure\n            if element.type in ['class', 'section']:\n                # Top-level elements\n                root_elements.append(element)\n                stack = [element]\n            elif element.type in ['function', 'method', 'subsection', 'example']:\n                # Second-level elements\n                if stack and stack[0].type in ['class', 'section']:\n                    stack[0].children.append(element)\n                    if len(stack) > 1:\n                        stack[1] = element\n                    else:\n                        stack.append(element)\n                else:\n                    root_elements.append(element)\n                    stack = [element]\n            else:\n                # Third-level and below\n                if len(stack) > 1:\n                    stack[-1].children.append(element)\n                elif stack:\n                    stack[0].children.append(element)\n                else:\n                    root_elements.append(element)\n\n        return root_elements\n\n\nclass UniversalChapterDetector:\n    """Main class that combines all detectors and provides universal chapter detection"""\n\n    def __init__(self):\n        self.detectors = {\n            DocumentType.TRADITIONAL_BOOK: TraditionalBookDetector(),\n            DocumentType.ACADEMIC_PAPER: AcademicPaperDetector(),\n            DocumentType.MARKDOWN: MarkdownDetector(),\n            DocumentType.TECHNICAL_DOCUMENTATION: TechnicalDocDetector(),\n        }\n\n    def detect_document_type(self, content: str, filename: Optional[str] = None) -> DocumentType:\n        """Automatically detect document type from content and filename"""\n        # Check file extension first\n        if filename:\n            ext = Path(filename).suffix.lower()\n            if ext == '.md':\n                return DocumentType.MARKDOWN\n            elif ext == '.tex':\n                return DocumentType.LATEX\n            elif ext == '.html' or ext == '.htm':\n                return DocumentType.HTML\n            elif ext == '.epub':\n                return DocumentType.EPUB\n            elif ext == '.pdf':\n                return DocumentType.PDF\n\n        # Analyze content patterns\n        content_lower = content.lower()\n        lines = content.split('\n')[:100]  # Check first 100 lines\n\n        # Check for Markdown patterns\n        markdown_score = 0\n        for line in lines:\n            if re.match(r'^#{1,6}\s+', line):\n                markdown_score += 2\n            if re.match(r'^\*\s+|\-\s+|\+\s+|\d+\.\s+', line):\n                markdown_score += 1\n            if re.match(r'^\[.+\]\(.+\)', line):\n                markdown_score += 2\n\n        if markdown_score > 10:\n            return DocumentType.MARKDOWN\n\n        # Check for academic paper patterns\n        academic_keywords = ['abstract', 'introduction', 'methodology', 'results',\n                           'discussion', 'conclusion', 'references', 'bibliography']\n        academic_score = sum(1 for keyword in academic_keywords if keyword in content_lower)\n\n        if academic_score >= 4:\n            return DocumentType.ACADEMIC_PAPER\n\n        # Check for technical documentation patterns\n        tech_keywords = ['function', 'method', 'class', 'parameters', 'returns',\n                        'example', 'api', 'documentation']\n        tech_score = sum(1 for keyword in tech_keywords if keyword in content_lower)\n\n        if tech_score >= 4:\n            return DocumentType.TECHNICAL_DOCUMENTATION\n\n        # Default to traditional book\n        return DocumentType.TRADITIONAL_BOOK\n\n    def detect_chapters(self,\n                       content: str,\n                       document_type: Optional[DocumentType] = None,\n                       filename: Optional[str] = None) -> Dict[str, Any]:\n        """\n        Main method to detect chapters and document structure\n\n        Args:\n            content: The document content as string\n            document_type: Optional document type override\n            filename: Optional filename for type detection\n\n        Returns:\n            Dictionary containing detected structure and metadata\n        """\n        # Auto-detect document type if not provided\n        if document_type is None:\n            document_type = self.detect_document_type(content, filename)\n\n        # Get appropriate detector\n        detector = self.detectors.get(document_type)\n        if not detector:\n            # Fallback to traditional book detector\n            detector = self.detectors[DocumentType.TRADITIONAL_BOOK]\n\n        # Detect structure\n        structure = detector.detect_structure(content)\n\n        # Post-process and enhance structure\n        structure = self._enhance_structure(structure, content)\n\n        # Generate table of contents\n        toc = self._generate_toc(structure)\n\n        # Calculate statistics\n        stats = self._calculate_statistics(structure)\n\n        return {\n            'document_type': document_type.value,\n            'structure': self._serialize_structure(structure),\n            'table_of_contents': toc,\n            'statistics': stats,\n            'metadata': {\n                'total_elements': len(self._flatten_structure(structure)),\n                'max_depth': self._calculate_max_depth(structure),\n                'has_numbering': self._has_numbering(structure),\n                'numbering_systems': self._detect_numbering_systems(structure)\n            }\n        }\n\n    def _enhance_structure(self, structure: List[StructureElement], content: str) -> List[StructureElement]:\n        """Enhance detected structure with additional information"""\n        lines = content.split('\n')\n\n        # Calculate end positions and extract content\n        flat_elements = self._flatten_structure(structure)\n        for i, element in enumerate(flat_elements):\n            # Find next element at same or higher level\n            next_pos = len(lines)\n            for j in range(i + 1, len(flat_elements)):\n                if flat_elements[j].level <= element.level:\n                    next_pos = flat_elements[j].start_position\n                    break\n\n            element.end_position = next_pos\n\n            # Extract content\n            element.content = '\n'.join(lines[element.start_position:element.end_position])\n\n            # Calculate word count\n            words = len(element.content.split())\n            element.metadata['word_count'] = words\n\n            # Detect key themes (simple keyword analysis)\n            element.metadata['themes'] = self._detect_themes(element.content)\n\n        return structure\n\n    def _detect_themes(self, content: str) -> List[str]:\n        """Simple theme detection based on keyword frequency"""\n        # This is a simple implementation - could be enhanced with NLP\n        common_words = {'the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at',\n                       'to', 'for', 'of', 'with', 'by', 'from', 'as', 'is', 'was',\n                       'are', 'were', 'been', 'be', 'have', 'has', 'had', 'do',\n                       'does', 'did', 'will', 'would', 'could', 'should', 'may',\n                       'might', 'must', 'can', 'this', 'that', 'these', 'those'}\n\n        words = re.findall(r'\b\w+\b', content.lower())\n        word_freq = {}\n\n        for word in words:\n            if word not in common_words and len(word) > 3:\n                word_freq[word] = word_freq.get(word, 0) + 1\n\n        # Get top 5 themes\n        themes = sorted(word_freq.items(), key=lambda x: x[1], reverse=True)[:5]\n        return [theme[0] for theme in themes]\n\n    def _generate_toc(self, structure: List[StructureElement]) -> List[Dict[str, Any]]:\n        """Generate table of contents from structure"""\n        toc = []\n\n        def process_element(element: StructureElement, parent_number: str = ""):\n            number = parent_number\n            if element.number:\n                number = f"{parent_number}.{element.number}" if parent_number else element.number\n\n            toc_entry = {\n                'level': element.level,\n                'type': element.type,\n                'number': number,\n                'title': element.title or f"Untitled {element.type}",\n                'page': element.start_position  # Line number as proxy for page\n            }\n            toc.append(toc_entry)\n\n            for child in element.children:\n                process_element(child, number)\n\n        for element in structure:\n            process_element(element)\n\n        return toc\n\n    def _calculate_statistics(self, structure: List[StructureElement]) -> Dict[str, Any]:\n        """Calculate statistics about the document structure"""\n        flat_elements = self._flatten_structure(structure)\n\n        stats = {\n            'total_chapters': sum(1 for e in flat_elements if e.type == 'chapter'),\n            'total_sections': sum(1 for e in flat_elements if 'section' in e.type),\n            'total_parts': sum(1 for e in flat_elements if e.type in ['part', 'book']),\n            'average_chapter_length': 0,\n            'shortest_chapter': None,\n            'longest_chapter': None,\n            'structure_depth': self._calculate_max_depth(structure)\n        }\n\n        # Calculate chapter statistics\n        chapters = [e for e in flat_elements if e.type == 'chapter']\n        if chapters:\n            chapter_lengths = [e.metadata.get('word_count', 0) for e in chapters]\n            stats['average_chapter_length'] = sum(chapter_lengths) / len(chapter_lengths)\n\n            shortest_idx = chapter_lengths.index(min(chapter_lengths))\n            longest_idx = chapter_lengths.index(max(chapter_lengths))\n\n            stats['shortest_chapter'] = {\n                'number': chapters[shortest_idx].number,\n                'title': chapters[shortest_idx].title,\n                'word_count': chapter_lengths[shortest_idx]\n            }\n            stats['longest_chapter'] = {\n                'number': chapters[longest_idx].number,\n                'title': chapters[longest_idx].title,\n                'word_count': chapter_lengths[longest_idx]\n            }\n\n        return stats\n\n    def _flatten_structure(self, structure: List[StructureElement]) -> List[StructureElement]:\n        """Flatten hierarchical structure into a list"""\n        flat = []\n\n        def flatten(elements):\n            for element in elements:\n                flat.append(element)\n                flatten(element.children)\n\n        flatten(structure)\n        return flat\n\n    def _calculate_max_depth(self, structure: List[StructureElement]) -> int:\n        """Calculate maximum depth of structure hierarchy"""\n        if not structure:\n            return 0\n\n        def get_depth(element):\n            if not element.children:\n                return 1\n            return 1 + max(get_depth(child) for child in element.children)\n\n        return max(get_depth(element) for element in structure)\n\n    def _has_numbering(self, structure: List[StructureElement]) -> bool:\n        """Check if document has chapter/section numbering"""\n        flat = self._flatten_structure(structure)\n        return any(element.number is not None for element in flat)\n\n    def _detect_numbering_systems(self, structure: List[StructureElement]) -> List[str]:\n        """Detect which numbering systems are used"""\n        systems = set()\n        flat = self._flatten_structure(structure)\n\n        for element in flat:\n            if element.metadata.get('numbering_system'):\n                systems.add(element.metadata['numbering_system'])\n\n        return list(systems)\n\n    def _serialize_structure(self, structure: List[StructureElement]) -> List[Dict[str, Any]]:\n        """Serialize structure elements to dictionary format"""\n        def serialize_element(element):\n            return {\n                'level': element.level,\n                'type': element.type,\n                'number': element.number,\n                'title': element.title,\n                'start_position': element.start_position,\n                'end_position': element.end_position,\n                'metadata': element.metadata,\n                'children': [serialize_element(child) for child in element.children]\n            }\n\n        return [serialize_element(element) for element in structure]\n\n    def export_structure(self, structure_data: Dict[str, Any], format: str = 'json') -> str:\n        """Export detected structure in various formats"""\n        if format == 'json':\n            return json.dumps(structure_data, indent=2)\n        elif format == 'markdown':\n            return self._export_as_markdown(structure_data)\n        elif format == 'xml':\n            return self._export_as_xml(structure_data)\n        else:\n            raise ValueError(f"Unsupported export format: {format}")\n\n    def _export_as_markdown(self, structure_data: Dict[str, Any]) -> str:\n        """Export structure as Markdown outline"""\n        lines = [f"# Document Structure: {structure_data['document_type']}\n"]\n\n        lines.append("## Table of Contents
")
        for item in structure_data['table_of_contents']:
            indent = "  " * (item['level'] - 1)
            number = f"{item['number']}. " if item['number'] else ""
            lines.append(f"{indent}- {number}{item['title']}")
        
        lines.append("\n## Statistics
")
        stats = structure_data['statistics']
        lines.append(f"- Total Chapters: {stats['total_chapters']}")
        lines.append(f"- Total Sections: {stats['total_sections']}")
        lines.append(f"- Average Chapter Length: {stats['average_chapter_length']:.0f} words")
        lines.append(f"- Structure Depth: {stats['structure_depth']} levels")
        
        return '
'.join(lines)
    
    def _export_as_xml(self, structure_data: Dict[str, Any]) -> str:
        """Export structure as XML"""
        root = ET.Element("document")
        root.set("type", structure_data['document_type'])
        
        # Add metadata
        metadata = ET.SubElement(root, "metadata")
        for key, value in structure_data['metadata'].items():
            elem = ET.SubElement(metadata, key)
            elem.text = str(value)
        
        # Add structure
        structure_elem = ET.SubElement(root, "structure")
        
        def add_element(parent, element_dict):
            elem = ET.SubElement(parent, element_dict['type'])
            if element_dict['number']:
                elem.set('number', element_dict['number'])
            if element_dict['title']:
                elem.set('title', element_dict['title'])
            elem.set('start', str(element_dict['start_position']))
            elem.set('end', str(element_dict['end_position']))
            
            for child in element_dict['children']:
                add_element(elem, child)
        
        for element in structure_data['structure']:
            add_element(structure_elem, element)
        
        return ET.tostring(root, encoding='unicode', method='xml')


# Convenience function for quick chapter detection
def detect_chapters(content: str, filename: Optional[str] = None) -> Dict[str, Any]:
    """
    Quick function to detect chapters in a document
    
    Args:
        content: Document content as string
        filename: Optional filename for type detection
        
    Returns:
        Dictionary with detected structure
    """
    detector = UniversalChapterDetector()
    return detector.detect_chapters(content, filename=filename)


if __name__ == "__main__":
    # Example usage and testing
    sample_book = """
    PART I: The Beginning
    
    Chapter 1: Introduction to the Story
    
    It was a dark and stormy night...
    
    Chapter 2: The Mystery Deepens
    
    As the investigation continued...
    
    PART II: The Middle
    
    Chapter 3: Revelations
    
    The truth began to emerge...
    """
    
    sample_academic = """
    Abstract
    
    This paper presents a comprehensive study...
    
    1. Introduction
    
    The field of artificial intelligence...
    
    2. Methodology
    
    2.1. Data Collection
    
    We collected data from...
    
    2.2. Analysis Methods
    
    Statistical analysis was performed...
    
    3. Results
    
    Our findings indicate...
    
    4. Conclusion
    
    In summary, this research...
    
    References
    
    [1] Smith, J. (2023)...
    """
    
    sample_markdown = """
    # My Technical Guide
    
    ## 1. Getting Started
    
    ### 1.1. Installation
    
    First, install the package...
    
    ### 1.2. Configuration
    
    Configure your settings...
    
    ## 2. Advanced Topics
    
    ### 2.1. Performance Optimization
    
    To optimize performance...
    """
    
    # Test detection
    detector = UniversalChapterDetector()
    
    print("Testing Traditional Book Detection:")
    book_result = detector.detect_chapters(sample_book)
    print(json.dumps(book_result, indent=2))
    
    print("\n" + "="*50 + "
")
    
    print("Testing Academic Paper Detection:")
    academic_result = detector.detect_chapters(sample_academic)
    print(json.dumps(academic_result, indent=2))
    
    print("\n" + "="*50 + "
")
    
    print("Testing Markdown Detection:")
    markdown_result = detector.detect_chapters(sample_markdown)
    print(json.dumps(markdown_result, indent=2))