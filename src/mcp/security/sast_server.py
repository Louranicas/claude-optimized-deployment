
from __future__ import annotations

"""SAST (Static Application Security Testing) MCP Server."""

__all__ = [
    "SASTMCPServer"
]
import os
import re
import asyncio
import json
import subprocess
from typing import Dict, Any, List, Optional, Tuple
from pathlib import Path
from datetime import datetime
import logging
from asyncio import Semaphore
import tempfile
import ast

from src.mcp.protocols import MCPTool, MCPToolParameter, MCPServerInfo, MCPCapabilities, MCPError
from src.mcp.servers import MCPServer

from src.core.error_handler import (
    handle_errors,
    async_handle_errors,
    log_error,
    ServiceUnavailableError,
    ExternalServiceError,
    ValidationError,
    ConfigurationError
)

logger = logging.getLogger(__name__)

# Security patterns for various languages
INJECTION_PATTERNS = {
    "sql_injection": {
        "python": [
            r"\.execute\s*\(\s*[\"'].*%[s|d].*[\"']\s*%",
            r"\.execute\s*\(\s*f[\"'].*{.*}.*[\"']",
            r"\.execute\s*\(\s*[\"'].*\+.*[\"']"
        ],
        "javascript": [
            r"\.query\s*\(\s*[`\"'].*\$\{.*\}.*[`\"']",
            r"\.query\s*\(\s*[\"'].*\+.*[\"']"
        ],
        "java": [
            r"createQuery\s*\(\s*[\"'].*\+.*[\"']",
            r"prepareStatement\s*\(\s*[\"'].*\+.*[\"']"
        ]
    },
    "command_injection": {
        "python": [
            r"os\.system\s*\(",
            r"subprocess\.call\s*\(\s*[^[]",
            r"eval\s*\(",
            r"exec\s*\("\n        ],\n        "javascript": [\n            r"eval\s*\(",\n            r"child_process\.exec\s*\(",\n            r"\.execSync\s*\("\n        ]\n    },\n    "path_traversal": {\n        "all": [\n            r"\.\.\/",\n            r"\.\.\\\\",\n            r"%2e%2e%2f",\n            r"%252e%252e%252f"\n        ]\n    }\n}\n\n# CWE mappings\nCWE_MAPPINGS = {\n    "sql_injection": "CWE-89",\n    "command_injection": "CWE-78",\n    "path_traversal": "CWE-22",\n    "xss": "CWE-79",\n    "xxe": "CWE-611",\n    "insecure_deserialization": "CWE-502",\n    "weak_crypto": "CWE-327",\n    "hardcoded_secrets": "CWE-798"\n}\n\n\nclass SASTMCPServer(MCPServer):\n    """Static Application Security Testing MCP Server."""\n\n    def __init__(self, permission_checker: Optional[Any] = None):\n        """Initialize SAST server."""\n        super().__init__(name="sast-scanner", version="1.0.0", permission_checker=permission_checker)\n        self.scan_history: List[Dict[str, Any]] = []\n        self.scan_semaphore = Semaphore(3)\n        self._scan_cache: Dict[str, Tuple[datetime, Any]] = {}\n        self._cache_ttl = 600  # 10 minutes\n\n    def get_server_info(self) -> MCPServerInfo:\n        """Get SAST server information."""\n        return MCPServerInfo(\n            name="sast-scanner",\n            version="1.0.0",\n            description="Static Application Security Testing with multiple scanners",\n            capabilities=MCPCapabilities(\n                tools=True,\n                resources=False,\n                prompts=False,\n                experimental={\n                    "multi_language_support": True,\n                    "cwe_mapping": True,\n                    "semgrep_integration": True,\n                    "codeql_support": True,\n                    "sonarqube_integration": True,\n                    "custom_rules": True,\n                    "incremental_scanning": True\n                }\n            )\n        )\n\n    def get_tools(self) -> List[MCPTool]:\n        """Get available SAST tools."""\n        return [\n            MCPTool(\n                name="run_semgrep_scan",\n                description="Run Semgrep static analysis for security vulnerabilities",\n                parameters=[\n                    MCPToolParameter(name="target_path", type="string",\n                                   description="Path to scan", required=True),\n                    MCPToolParameter(name="config", type="string",\n                                   description="Semgrep config to use", required=False,\n                                   enum=["auto", "security", "owasp", "cwe-top25"], default="auto"),\n                    MCPToolParameter(name="severity_filter", type="string",\n                                   description="Minimum severity level", required=False,\n                                   enum=["INFO", "WARNING", "ERROR"], default="WARNING")\n                ]\n            ),\n            MCPTool(\n                name="analyze_code_patterns",\n                description="Analyze code for dangerous patterns and anti-patterns",\n                parameters=[\n                    MCPToolParameter(name="target_path", type="string",\n                                   description="Path to analyze", required=True),\n                    MCPToolParameter(name="language", type="string",\n                                   description="Programming language", required=False,\n                                   enum=["python", "javascript", "java", "go", "auto"], default="auto"),\n                    MCPToolParameter(name="pattern_types", type="string",\n                                   description="Pattern types to check (comma-separated)", required=False,\n                                   default="injection,crypto,auth,data_validation")\n                ]\n            ),\n            MCPTool(\n                name="run_bandit_scan",\n                description="Python-specific security analysis with Bandit",\n                parameters=[\n                    MCPToolParameter(name="target_path", type="string",\n                                   description="Python code path to scan", required=True),\n                    MCPToolParameter(name="severity_level", type="string",\n                                   description="Minimum severity level", required=False,\n                                   enum=["LOW", "MEDIUM", "HIGH"], default="LOW"),\n                    MCPToolParameter(name="confidence_level", type="string",\n                                   description="Minimum confidence level", required=False,\n                                   enum=["LOW", "MEDIUM", "HIGH"], default="LOW")\n                ]\n            ),\n            MCPTool(\n                name="detect_hardcoded_secrets",\n                description="Advanced detection of hardcoded secrets and credentials",\n                parameters=[\n                    MCPToolParameter(name="target_path", type="string",\n                                   description="Path to scan for secrets", required=True),\n                    MCPToolParameter(name="custom_patterns", type="string",\n                                   description="Additional regex patterns (JSON array)", required=False, default="[]"),\n                    MCPToolParameter(name="exclude_patterns", type="string",\n                                   description="Paths to exclude (comma-separated)", required=False, default="")\n                ]\n            ),\n            MCPTool(\n                name="analyze_dependencies",\n                description="Analyze code dependencies for security issues",\n                parameters=[\n                    MCPToolParameter(name="project_path", type="string",\n                                   description="Project root path", required=True),\n                    MCPToolParameter(name="check_licenses", type="boolean",\n                                   description="Check for license issues", required=False, default=True),\n                    MCPToolParameter(name="check_outdated", type="boolean",\n                                   description="Check for outdated packages", required=False, default=True)\n                ]\n            )\n        ]\n\n    async def call_tool(self, tool_name: str, arguments: Dict[str, Any]) -> Any:\n        """Execute SAST tool."""\n        async with self.scan_semaphore:\n            tool_map = {\n                "run_semgrep_scan": self._run_semgrep_scan,\n                "analyze_code_patterns": self._analyze_code_patterns,\n                "run_bandit_scan": self._run_bandit_scan,\n                "detect_hardcoded_secrets": self._detect_hardcoded_secrets,\n                "analyze_dependencies": self._analyze_dependencies\n            }\n\n            if tool_name not in tool_map:\n                raise MCPError(-32601, f"Unknown tool: {tool_name}")\n\n            return await tool_map[tool_name](**arguments)\n\n    async def _run_semgrep_scan(self, target_path: str, config: str = "auto",\n                                severity_filter: str = "WARNING") -> Dict[str, Any]:\n        """Run Semgrep security scan."""\n        path = Path(target_path)\n        if not path.exists():\n            raise MCPError(-32000, f"Target path not found: {target_path}")\n\n        result = {\n            "scan_type": "semgrep",\n            "timestamp": datetime.now().isoformat(),\n            "target_path": target_path,\n            "config": config,\n            "findings": [],\n            "stats": {"total": 0, "by_severity": {}, "by_rule": {}}\n        }\n\n        # Build Semgrep command\n        cmd = ["semgrep", "--json"]\n\n        if config == "auto":\n            cmd.extend(["--config=auto"])\n        elif config == "security":\n            cmd.extend(["--config=p/security-audit"])\n        elif config == "owasp":\n            cmd.extend(["--config=p/owasp-top-ten"])\n        elif config == "cwe-top25":\n            cmd.extend(["--config=p/cwe-top-25"])\n\n        cmd.append(str(path))\n\n        try:\n            process = await asyncio.create_subprocess_exec(\n                *cmd,\n                stdout=asyncio.subprocess.PIPE,\n                stderr=asyncio.subprocess.PIPE\n            )\n\n            stdout, stderr = await process.communicate()\n\n            if stdout:\n                semgrep_results = json.loads(stdout.decode())\n\n                for finding in semgrep_results.get("results", []):\n                    severity = finding.get("extra", {}).get("severity", "INFO")\n\n                    # Apply severity filter\n                    severity_levels = {"INFO": 0, "WARNING": 1, "ERROR": 2}\n                    if severity_levels.get(severity, 0) >= severity_levels.get(severity_filter, 0):\n                        result["findings"].append({\n                            "rule_id": finding.get("check_id"),\n                            "message": finding.get("extra", {}).get("message"),\n                            "severity": severity,\n                            "file": finding.get("path"),\n                            "line": finding.get("start", {}).get("line"),\n                            "code": finding.get("extra", {}).get("lines"),\n                            "cwe": self._extract_cwe(finding.get("check_id", "")),\n                            "owasp": finding.get("extra", {}).get("metadata", {}).get("owasp")\n                        })\n\n                        # Update stats\n                        result["stats"]["total"] += 1\n                        result["stats"]["by_severity"][severity] = result["stats"]["by_severity"].get(severity, 0) + 1\n                        result["stats"]["by_rule"][finding.get("check_id")] = result["stats"]["by_rule"].get(finding.get("check_id"), 0) + 1\n\n        except Exception as e:\n            result["error"] = str(e)\n\n        self.scan_history.append(result)\n        return result\n\n    async def _analyze_code_patterns(self, target_path: str, language: str = "auto",\n                                   pattern_types: str = "injection,crypto,auth,data_validation") -> Dict[str, Any]:\n        """Analyze code for security patterns."""\n        path = Path(target_path)\n        if not path.exists():\n            raise MCPError(-32000, f"Target path not found: {target_path}")\n\n        result = {\n            "scan_type": "pattern_analysis",\n            "timestamp": datetime.now().isoformat(),\n            "target_path": target_path,\n            "language": language,\n            "findings": []\n        }\n\n        pattern_list = pattern_types.split(",")\n        files_to_scan = [path] if path.is_file() else list(path.rglob("*"))\n\n        for file_path in files_to_scan:\n            if file_path.is_file() and file_path.suffix in ['.py', '.js', '.java', '.go', '.php', '.rb']:\n                try:\n                    content = file_path.read_text(encoding='utf-8', errors='ignore')\n                    file_language = self._detect_language(file_path) if language == "auto" else language\n\n                    # Check injection patterns\n                    if "injection" in pattern_list:\n                        for injection_type, patterns in INJECTION_PATTERNS.items():\n                            lang_patterns = patterns.get(file_language, patterns.get("all", []))\n                            for pattern in lang_patterns:\n                                matches = re.finditer(pattern, content, re.MULTILINE)\n                                for match in matches:\n                                    line_num = content[:match.start()].count('\n') + 1\n                                    result["findings"].append({\n                                        "type": injection_type,\n                                        "file": str(file_path),\n                                        "line": line_num,\n                                        "severity": "HIGH",\n                                        "cwe": CWE_MAPPINGS.get(injection_type),\n                                        "code_snippet": match.group(0),\n                                        "recommendation": f"Review and fix potential {injection_type.replace('_', ' ')}"\n                                    })\n\n                    # Check crypto patterns\n                    if "crypto" in pattern_list:\n                        weak_crypto_patterns = [\n                            (r"MD5|md5", "Weak hash algorithm MD5", "CWE-327"),\n                            (r"SHA1|sha1", "Weak hash algorithm SHA1", "CWE-327"),\n                            (r"DES|des", "Weak encryption algorithm DES", "CWE-327"),\n                            (r"Random\(\)|Math\.random", "Insecure random number generator", "CWE-330")\n                        ]\n\n                        for pattern, message, cwe in weak_crypto_patterns:\n                            if re.search(pattern, content):\n                                result["findings"].append({\n                                    "type": "weak_crypto",\n                                    "file": str(file_path),\n                                    "severity": "MEDIUM",\n                                    "cwe": cwe,\n                                    "message": message,\n                                    "recommendation": "Use stronger cryptographic algorithms"\n                                })\n\n                except Exception as e:\n                    logger.warning(f"Error analyzing {file_path}: {e}")\n\n        result["stats"] = {\n            "total_findings": len(result["findings"]),\n            "by_type": {}\n        }\n\n        for finding in result["findings"]:\n            finding_type = finding.get("type")\n            result["stats"]["by_type"][finding_type] = result["stats"]["by_type"].get(finding_type, 0) + 1\n\n        self.scan_history.append(result)\n        return result\n\n    async def _run_bandit_scan(self, target_path: str, severity_level: str = "LOW",\n                              confidence_level: str = "LOW") -> Dict[str, Any]:\n        """Run Bandit Python security scanner."""\n        path = Path(target_path)\n        if not path.exists():\n            raise MCPError(-32000, f"Target path not found: {target_path}")\n\n        result = {\n            "scan_type": "bandit",\n            "timestamp": datetime.now().isoformat(),\n            "target_path": target_path,\n            "findings": [],\n            "metrics": {}\n        }\n\n        # Build Bandit command\n        cmd = [\n            "bandit", "-r", str(path), "-f", "json",\n            "-l", "-i",  # Show low severity and confidence by default\n            "--severity-level", severity_level.lower(),\n            "--confidence-level", confidence_level.lower()\n        ]\n\n        try:\n            process = await asyncio.create_subprocess_exec(\n                *cmd,\n                stdout=asyncio.subprocess.PIPE,\n                stderr=asyncio.subprocess.PIPE\n            )\n\n            stdout, stderr = await process.communicate()\n\n            if stdout:\n                bandit_results = json.loads(stdout.decode())\n\n                result["metrics"] = bandit_results.get("metrics", {})\n\n                for issue in bandit_results.get("results", []):\n                    result["findings"].append({\n                        "test_id": issue.get("test_id"),\n                        "test_name": issue.get("test_name"),\n                        "severity": issue.get("issue_severity"),\n                        "confidence": issue.get("issue_confidence"),\n                        "file": issue.get("filename"),\n                        "line": issue.get("line_number"),\n                        "code": issue.get("code"),\n                        "message": issue.get("issue_text"),\n                        "cwe": issue.get("issue_cwe", {}).get("id")\n                    })\n\n        except Exception as e:\n            result["error"] = str(e)\n\n        result["stats"] = {\n            "total_findings": len(result["findings"]),\n            "by_severity": {},\n            "by_confidence": {}\n        }\n\n        for finding in result["findings"]:\n            severity = finding.get("severity")\n            confidence = finding.get("confidence")\n            result["stats"]["by_severity"][severity] = result["stats"]["by_severity"].get(severity, 0) + 1\n            result["stats"]["by_confidence"][confidence] = result["stats"]["by_confidence"].get(confidence, 0) + 1\n\n        self.scan_history.append(result)\n        return result\n\n    async def _detect_hardcoded_secrets(self, target_path: str, custom_patterns: str = "[]",\n                                      exclude_patterns: str = "") -> Dict[str, Any]:\n        """Detect hardcoded secrets in code."""\n        path = Path(target_path)\n        if not path.exists():\n            raise MCPError(-32000, f"Target path not found: {target_path}")\n\n        result = {\n            "scan_type": "secret_detection",\n            "timestamp": datetime.now().isoformat(),\n            "target_path": target_path,\n            "findings": []\n        }\n\n        # Use multiple secret detection tools\n        tools_results = []\n\n        # 1. Trufflehog\n        try:\n            cmd = ["trufflehog", "filesystem", str(path), "--json"]\n            process = await asyncio.create_subprocess_exec(\n                *cmd,\n                stdout=asyncio.subprocess.PIPE,\n                stderr=asyncio.subprocess.PIPE\n            )\n            stdout, _ = await process.communicate()\n\n            if stdout:\n                for line in stdout.decode().strip().split('\n'):\n                    if line:\n                        finding = json.loads(line)\n                        tools_results.append({\n                            "tool": "trufflehog",\n                            "type": finding.get("detectorName"),\n                            "file": finding.get("sourceMetadata", {}).get("Data", {}).get("Filesystem", {}).get("file"),\n                            "verified": finding.get("verified", False),\n                            "raw": finding.get("raw")\n                        })\n        except Exception as e:\n            logger.warning(f"Trufflehog scan failed: {e}")\n\n        # 2. Gitleaks\n        try:\n            with tempfile.NamedTemporaryFile(mode='w', suffix='.json', delete=False) as report_file:\n                cmd = ["gitleaks", "detect", "--source", str(path), "--report-format", "json", "--report-path", report_file.name]\n                process = await asyncio.create_subprocess_exec(\n                    *cmd,\n                    stdout=asyncio.subprocess.PIPE,\n                    stderr=asyncio.subprocess.PIPE\n                )\n                await process.communicate()\n\n                if os.path.exists(report_file.name):\n                    with open(report_file.name, 'r') as f:\n                        gitleaks_results = json.load(f)\n                        for finding in gitleaks_results:\n                            tools_results.append({\n                                "tool": "gitleaks",\n                                "type": finding.get("rule"),\n                                "file": finding.get("file"),\n                                "line": finding.get("startLine"),\n                                "commit": finding.get("commit"),\n                                "secret": finding.get("secret")[:20] + "***" if finding.get("secret") else None\n                            })\n                    os.unlink(report_file.name)\n        except Exception as e:\n            logger.warning(f"Gitleaks scan failed: {e}")\n\n        # Aggregate and deduplicate findings\n        seen = set()\n        for finding in tools_results:\n            key = (finding.get("file"), finding.get("type"))\n            if key not in seen:\n                seen.add(key)\n                result["findings"].append({\n                    "type": finding.get("type"),\n                    "file": finding.get("file"),\n                    "line": finding.get("line"),\n                    "tool": finding.get("tool"),\n                    "severity": "CRITICAL",\n                    "cwe": "CWE-798",\n                    "recommendation": "Remove hardcoded secret and use secure secret management"\n                })\n\n        result["stats"] = {\n            "total_findings": len(result["findings"]),\n            "by_tool": {},\n            "by_type": {}\n        }\n\n        for finding in result["findings"]:\n            tool = finding.get("tool")\n            secret_type = finding.get("type")\n            result["stats"]["by_tool"][tool] = result["stats"]["by_tool"].get(tool, 0) + 1\n            result["stats"]["by_type"][secret_type] = result["stats"]["by_type"].get(secret_type, 0) + 1\n\n        self.scan_history.append(result)\n        return result\n\n    async def _analyze_dependencies(self, project_path: str, check_licenses: bool = True,\n                                  check_outdated: bool = True) -> Dict[str, Any]:\n        """Analyze project dependencies for security issues."""\n        path = Path(project_path)\n        if not path.exists():\n            raise MCPError(-32000, f"Project path not found: {project_path}")\n\n        result = {\n            "scan_type": "dependency_analysis",\n            "timestamp": datetime.now().isoformat(),\n            "project_path": project_path,\n            "findings": {\n                "vulnerabilities": [],\n                "license_issues": [],\n                "outdated_packages": []\n            }\n        }\n\n        # Detect project type and analyze accordingly\n        if (path / "package.json").exists():\n            # Node.js project\n            await self._analyze_npm_dependencies(path, result, check_licenses, check_outdated)\n\n        if (path / "requirements.txt").exists() or (path / "setup.py").exists() or (path / "pyproject.toml").exists():\n            # Python project\n            await self._analyze_python_dependencies(path, result, check_licenses, check_outdated)\n\n        if (path / "pom.xml").exists():\n            # Java Maven project\n            await self._analyze_maven_dependencies(path, result, check_licenses, check_outdated)\n\n        if (path / "go.mod").exists():\n            # Go project\n            await self._analyze_go_dependencies(path, result, check_licenses, check_outdated)\n\n        # Calculate risk score\n        total_issues = (len(result["findings"]["vulnerabilities"]) +\n                       len(result["findings"]["license_issues"]) +\n                       len(result["findings"]["outdated_packages"]))\n\n        result["risk_assessment"] = {\n            "total_issues": total_issues,\n            "risk_level": "CRITICAL" if total_issues > 20 else "HIGH" if total_issues > 10 else "MEDIUM" if total_issues > 5 else "LOW",\n            "recommendations": self._generate_dependency_recommendations(result["findings"])\n        }\n\n        self.scan_history.append(result)\n        return result\n\n    def _detect_language(self, file_path: Path) -> str:\n        """Detect programming language from file extension."""\n        ext_to_lang = {\n            '.py': 'python',\n            '.js': 'javascript',\n            '.ts': 'javascript',\n            '.java': 'java',\n            '.go': 'go',\n            '.rb': 'ruby',\n            '.php': 'php',\n            '.cs': 'csharp',\n            '.cpp': 'cpp',\n            '.c': 'c'\n        }\n        return ext_to_lang.get(file_path.suffix, 'unknown')\n\n    def _extract_cwe(self, rule_id: str) -> Optional[str]:\n        """Extract CWE ID from rule ID if present."""\n        cwe_match = re.search(r'CWE-(\d+)', rule_id, re.IGNORECASE)\n        return f"CWE-{cwe_match.group(1)}" if cwe_match else None\n\n    async def _analyze_npm_dependencies(self, path: Path, result: Dict, check_licenses: bool, check_outdated: bool):\n        """Analyze npm dependencies."""\n        # Run npm audit\n        try:\n            cmd = ["npm", "audit", "--json"]\n            process = await asyncio.create_subprocess_exec(\n                *cmd,\n                cwd=str(path),\n                stdout=asyncio.subprocess.PIPE,\n                stderr=asyncio.subprocess.PIPE\n            )\n            stdout, _ = await process.communicate()\n\n            if stdout:\n                audit_data = json.loads(stdout.decode())\n                for advisory_id, advisory in audit_data.get("advisories", {}).items():\n                    result["findings"]["vulnerabilities"].append({\n                        "type": "npm",\n                        "package": advisory.get("module_name"),\n                        "severity": advisory.get("severity"),\n                        "title": advisory.get("title"),\n                        "cve": advisory.get("cves", []),\n                        "recommendation": advisory.get("recommendation")\n                    })\n        except Exception as e:\n            logger.warning(f"npm audit failed: {e}")\n\n        # Check licenses\n        if check_licenses:\n            try:\n                cmd = ["license-checker", "--json", "--production"]\n                process = await asyncio.create_subprocess_exec(\n                    *cmd,\n                    cwd=str(path),\n                    stdout=asyncio.subprocess.PIPE,\n                    stderr=asyncio.subprocess.PIPE\n                )\n                stdout, _ = await process.communicate()\n\n                if stdout:\n                    licenses = json.loads(stdout.decode())\n                    problematic = ["GPL", "AGPL", "LGPL", "SSPL"]\n                    for pkg, info in licenses.items():\n                        license_type = info.get("licenses", "")\n                        if any(prob in license_type for prob in problematic):\n                            result["findings"]["license_issues"].append({\n                                "package": pkg,\n                                "license": license_type,\n                                "issue": "Potentially restrictive license"\n                            })\n            except Exception as e:\n                logger.warning(f"License check failed: {e}")\n\n    async def _analyze_python_dependencies(self, path: Path, result: Dict, check_licenses: bool, check_outdated: bool):\n        """Analyze Python dependencies."""\n        # Run safety check\n        try:\n            cmd = ["safety", "check", "--json"]\n            process = await asyncio.create_subprocess_exec(\n                *cmd,\n                cwd=str(path),\n                stdout=asyncio.subprocess.PIPE,\n                stderr=asyncio.subprocess.PIPE\n            )\n            stdout, _ = await process.communicate()\n\n            if stdout:\n                vulnerabilities = json.loads(stdout.decode())\n                for vuln in vulnerabilities:\n                    result["findings"]["vulnerabilities"].append({\n                        "type": "python",\n                        "package": vuln.get("package"),\n                        "installed_version": vuln.get("installed_version"),\n                        "vulnerability": vuln.get("vulnerability"),\n                        "description": vuln.get("description"),\n                        "cve": vuln.get("cve")\n                    })\n        except Exception as e:\n            logger.warning(f"Safety check failed: {e}")\n\n        # Check with pip-audit\n        try:\n            cmd = ["pip-audit", "--format", "json"]\n            process = await asyncio.create_subprocess_exec(\n                *cmd,\n                cwd=str(path),\n                stdout=asyncio.subprocess.PIPE,\n                stderr=asyncio.subprocess.PIPE\n            )\n            stdout, _ = await process.communicate()\n\n            if stdout:\n                audit_results = json.loads(stdout.decode())\n                for vuln in audit_results:\n                    result["findings"]["vulnerabilities"].append({\n                        "type": "python",\n                        "package": vuln.get("name"),\n                        "version": vuln.get("version"),\n                        "vulnerability": vuln.get("vulns", [])\n                    })\n        except Exception as e:\n            logger.warning(f"pip-audit failed: {e}")\n\n    def _generate_dependency_recommendations(self, findings: Dict) -> List[str]:\n        """Generate recommendations based on dependency findings."""\n        recommendations = []\n\n        if findings["vulnerabilities"]:\n            recommendations.append("Update vulnerable dependencies to patched versions")\n            critical_vulns = [v for v in findings["vulnerabilities"] if v.get("severity") in ["CRITICAL", "HIGH"]]\n            if critical_vulns:\n                recommendations.append(f"Address {len(critical_vulns)} critical/high severity vulnerabilities immediately")\n\n        if findings["license_issues"]:\n            recommendations.append("Review license compliance for restrictive licenses")\n\n        if findings["outdated_packages"]:\n            recommendations.append("Update outdated packages to maintain security patches")\n\n        return recommendations