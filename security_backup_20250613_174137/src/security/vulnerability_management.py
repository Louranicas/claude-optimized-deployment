"""
Vulnerability Management System for MCP Servers
Comprehensive vulnerability scanning, assessment, and patch management.

This module provides:
1. Dependency scanning and vulnerability detection
2. SAST (Static Application Security Testing) implementation
3. Dynamic security testing
4. Automated patch management
5. Security testing framework
6. Compliance scanning
"""

import asyncio
import json
import subprocess
import tempfile
import logging
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Set, Tuple
from dataclasses import dataclass, field
from enum import Enum
from pathlib import Path
import hashlib
import requests
import re

logger = logging.getLogger(__name__)


class VulnerabilitySeverity(Enum):
    """Vulnerability severity levels."""
    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"
    INFO = "info"


class ScanType(Enum):
    """Types of security scans."""
    DEPENDENCY = "dependency"
    STATIC_CODE = "static_code"
    DYNAMIC = "dynamic"
    CONTAINER = "container"
    INFRASTRUCTURE = "infrastructure"
    COMPLIANCE = "compliance"


@dataclass
class Vulnerability:
    """Vulnerability information."""
    id: str
    title: str
    description: str
    severity: VulnerabilitySeverity
    score: Optional[float]  # CVSS score
    cve_id: Optional[str] = None
    cwe_id: Optional[str] = None
    affected_component: Optional[str] = None
    affected_version: Optional[str] = None
    fixed_version: Optional[str] = None
    references: List[str] = field(default_factory=list)
    discovered_at: datetime = field(default_factory=datetime.utcnow)
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary."""
        return {
            "id": self.id,
            "title": self.title,
            "description": self.description,
            "severity": self.severity.value,
            "score": self.score,
            "cve_id": self.cve_id,
            "cwe_id": self.cwe_id,
            "affected_component": self.affected_component,
            "affected_version": self.affected_version,
            "fixed_version": self.fixed_version,
            "references": self.references,
            "discovered_at": self.discovered_at.isoformat()
        }


@dataclass
class ScanResult:
    """Security scan result."""
    scan_id: str
    scan_type: ScanType
    target: str
    started_at: datetime
    completed_at: Optional[datetime] = None
    vulnerabilities: List[Vulnerability] = field(default_factory=list)
    summary: Dict[str, Any] = field(default_factory=dict)
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    def get_severity_counts(self) -> Dict[str, int]:
        """Get count of vulnerabilities by severity."""
        counts = {severity.value: 0 for severity in VulnerabilitySeverity}
        for vuln in self.vulnerabilities:
            counts[vuln.severity.value] += 1
        return counts
    
    def get_risk_score(self) -> float:
        """Calculate overall risk score."""
        if not self.vulnerabilities:
            return 0.0
        
        severity_weights = {
            VulnerabilitySeverity.CRITICAL: 10.0,
            VulnerabilitySeverity.HIGH: 7.5,
            VulnerabilitySeverity.MEDIUM: 5.0,
            VulnerabilitySeverity.LOW: 2.5,
            VulnerabilitySeverity.INFO: 1.0
        }
        
        total_score = sum(
            severity_weights[vuln.severity] for vuln in self.vulnerabilities
        )
        
        # Normalize to 0-100 scale
        max_possible = len(self.vulnerabilities) * 10.0
        return min(100.0, (total_score / max_possible) * 100.0)


class DependencyScanner:
    """Scans dependencies for known vulnerabilities."""
    
    def __init__(self):
        self.vulnerability_db: Dict[str, List[Dict[str, Any]]] = {}
        self.last_db_update: Optional[datetime] = None
    
    async def scan_python_dependencies(self, requirements_file: str) -> ScanResult:
        """Scan Python dependencies using safety and pip-audit."""
        scan_id = f"python_deps_{datetime.utcnow().strftime('%Y%m%d_%H%M%S')}"
        result = ScanResult(
            scan_id=scan_id,
            scan_type=ScanType.DEPENDENCY,
            target=requirements_file,
            started_at=datetime.utcnow()
        )
        
        try:
            vulnerabilities = []
            
            # Use pip-audit if available
            try:
                pip_audit_result = await self._run_pip_audit(requirements_file)
                vulnerabilities.extend(pip_audit_result)
            except Exception as e:
                logger.warning(f"pip-audit failed: {e}")
            
            # Use safety as fallback
            try:
                safety_result = await self._run_safety_check(requirements_file)
                vulnerabilities.extend(safety_result)
            except Exception as e:
                logger.warning(f"safety check failed: {e}")
            
            result.vulnerabilities = vulnerabilities
            result.completed_at = datetime.utcnow()
            result.summary = {
                "total_vulnerabilities": len(vulnerabilities),
                "severity_counts": result.get_severity_counts(),
                "risk_score": result.get_risk_score()
            }
            
        except Exception as e:
            logger.error(f"Python dependency scan failed: {e}")
            result.metadata["error"] = str(e)
        
        return result
    
    async def _run_pip_audit(self, requirements_file: str) -> List[Vulnerability]:
        """Run pip-audit scanner."""
        vulnerabilities = []
        
        try:
            cmd = ["pip-audit", "--format", "json", "--requirement", requirements_file]
            process = await asyncio.create_subprocess_exec(
                *cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            
            stdout, stderr = await process.communicate()
            
            if process.returncode == 0:
                data = json.loads(stdout.decode())
                
                for vuln_data in data.get("vulnerabilities", []):
                    vuln = Vulnerability(
                        id=f"pip_audit_{vuln_data.get('id', 'unknown')}",
                        title=vuln_data.get("description", "Unknown vulnerability"),
                        description=vuln_data.get("description", ""),
                        severity=self._parse_severity(vuln_data.get("fix_versions")),
                        cve_id=vuln_data.get("aliases", [None])[0],
                        affected_component=vuln_data.get("package", ""),
                        affected_version=vuln_data.get("installed_version", ""),
                        fixed_version=vuln_data.get("fix_versions", [None])[0]
                    )
                    vulnerabilities.append(vuln)
            
        except FileNotFoundError:
            logger.warning("pip-audit not found, install with: pip install pip-audit")
        except Exception as e:
            logger.error(f"pip-audit execution failed: {e}")
        
        return vulnerabilities
    
    async def _run_safety_check(self, requirements_file: str) -> List[Vulnerability]:
        """Run safety check scanner."""
        vulnerabilities = []
        
        try:
            cmd = ["safety", "check", "--json", "--file", requirements_file]
            process = await asyncio.create_subprocess_exec(
                *cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            
            stdout, stderr = await process.communicate()
            
            if stdout:
                data = json.loads(stdout.decode())
                
                for vuln_data in data:
                    vuln = Vulnerability(
                        id=f"safety_{vuln_data.get('id', 'unknown')}",
                        title=vuln_data.get("vulnerability", "Unknown vulnerability"),
                        description=vuln_data.get("vulnerability", ""),
                        severity=self._parse_severity(vuln_data.get("vulnerability", "")),
                        affected_component=vuln_data.get("package", ""),
                        affected_version=vuln_data.get("installed_version", ""),
                        fixed_version=vuln_data.get("spec", "")
                    )
                    vulnerabilities.append(vuln)
            
        except FileNotFoundError:
            logger.warning("safety not found, install with: pip install safety")
        except Exception as e:
            logger.error(f"safety execution failed: {e}")
        
        return vulnerabilities
    
    async def scan_npm_dependencies(self, package_json_path: str) -> ScanResult:
        """Scan Node.js dependencies using npm audit."""
        scan_id = f"npm_deps_{datetime.utcnow().strftime('%Y%m%d_%H%M%S')}"
        result = ScanResult(
            scan_id=scan_id,
            scan_type=ScanType.DEPENDENCY,
            target=package_json_path,
            started_at=datetime.utcnow()
        )
        
        try:
            vulnerabilities = []
            
            # Run npm audit
            package_dir = Path(package_json_path).parent
            cmd = ["npm", "audit", "--json"]
            
            process = await asyncio.create_subprocess_exec(
                *cmd,
                cwd=str(package_dir),
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            
            stdout, stderr = await process.communicate()
            
            if stdout:
                data = json.loads(stdout.decode())
                
                for vuln_id, vuln_data in data.get("vulnerabilities", {}).items():
                    vuln = Vulnerability(
                        id=f"npm_{vuln_id}",
                        title=vuln_data.get("title", "Unknown vulnerability"),
                        description=vuln_data.get("description", ""),
                        severity=VulnerabilitySeverity(vuln_data.get("severity", "low")),
                        cve_id=vuln_data.get("cves", [None])[0],
                        affected_component=vuln_data.get("name", ""),
                        references=vuln_data.get("references", [])
                    )
                    vulnerabilities.append(vuln)
            
            result.vulnerabilities = vulnerabilities
            result.completed_at = datetime.utcnow()
            result.summary = {
                "total_vulnerabilities": len(vulnerabilities),
                "severity_counts": result.get_severity_counts(),
                "risk_score": result.get_risk_score()
            }
            
        except Exception as e:
            logger.error(f"NPM dependency scan failed: {e}")
            result.metadata["error"] = str(e)
        
        return result
    
    def _parse_severity(self, text: str) -> VulnerabilitySeverity:
        """Parse severity from text."""
        text = text.lower()
        if "critical" in text:
            return VulnerabilitySeverity.CRITICAL
        elif "high" in text:
            return VulnerabilitySeverity.HIGH
        elif "medium" in text or "moderate" in text:
            return VulnerabilitySeverity.MEDIUM
        elif "low" in text:
            return VulnerabilitySeverity.LOW
        else:
            return VulnerabilitySeverity.INFO


class StaticCodeScanner:
    """Static Application Security Testing (SAST) scanner."""
    
    def __init__(self):
        self.rules: Dict[str, List[Dict[str, Any]]] = {}
        self._load_security_rules()
    
    def _load_security_rules(self):
        """Load security scanning rules."""
        # Python security rules
        self.rules["python"] = [
            {
                "id": "hardcoded_password",
                "pattern": r"(password|passwd|pwd)\s*=\s*['\"][^'\"]+['\"]",
                "severity": VulnerabilitySeverity.HIGH,
                "title": "Hardcoded Password",
                "description": "Password is hardcoded in source code"
            },
            {
                "id": "sql_injection",
                "pattern": r"execute\(['\"].*%s.*['\"]",
                "severity": VulnerabilitySeverity.HIGH,
                "title": "SQL Injection Risk",
                "description": "Potential SQL injection vulnerability"
            },
            {
                "id": "command_injection",
                "pattern": r"os\.system\(.*\+.*\)|subprocess\.call\(.*\+.*\)",
                "severity": VulnerabilitySeverity.HIGH,
                "title": "Command Injection Risk",
                "description": "Potential command injection vulnerability"
            },
            {
                "id": "weak_crypto",
                "pattern": r"hashlib\.(md5|sha1)\(",
                "severity": VulnerabilitySeverity.MEDIUM,
                "title": "Weak Cryptographic Hash",
                "description": "Use of weak cryptographic hash function"
            },
            {
                "id": "insecure_random",
                "pattern": r"random\.random\(\)|random\.choice\(",
                "severity": VulnerabilitySeverity.MEDIUM,
                "title": "Insecure Random Number Generation",
                "description": "Use of insecure random number generator for security purposes"
            }
        ]
        
        # JavaScript security rules
        self.rules["javascript"] = [
            {
                "id": "eval_usage",
                "pattern": r"\beval\s*\(",
                "severity": VulnerabilitySeverity.HIGH,
                "title": "Use of eval()",
                "description": "Use of eval() function can lead to code injection"
            },
            {
                "id": "hardcoded_secret",
                "pattern": r"(api_key|secret|token)\s*[:=]\s*['\"][a-zA-Z0-9]{20,}['\"]",
                "severity": VulnerabilitySeverity.HIGH,
                "title": "Hardcoded Secret",
                "description": "API key or secret is hardcoded in source code"
            },
            {
                "id": "unsafe_innerHTML",
                "pattern": r"\.innerHTML\s*=\s*.*\+",
                "severity": VulnerabilitySeverity.MEDIUM,
                "title": "Unsafe innerHTML Usage",
                "description": "Dynamic innerHTML assignment can lead to XSS"
            }
        ]
    
    async def scan_directory(self, directory: str, file_patterns: List[str] = None) -> ScanResult:
        """Scan directory for security issues."""
        scan_id = f"sast_{datetime.utcnow().strftime('%Y%m%d_%H%M%S')}"
        result = ScanResult(
            scan_id=scan_id,
            scan_type=ScanType.STATIC_CODE,
            target=directory,
            started_at=datetime.utcnow()
        )
        
        if file_patterns is None:
            file_patterns = ["*.py", "*.js", "*.ts", "*.jsx", "*.tsx"]
        
        try:
            vulnerabilities = []
            files_scanned = 0
            
            directory_path = Path(directory)
            
            for pattern in file_patterns:
                for file_path in directory_path.rglob(pattern):
                    if file_path.is_file():
                        file_vulns = await self._scan_file(file_path)
                        vulnerabilities.extend(file_vulns)
                        files_scanned += 1
            
            result.vulnerabilities = vulnerabilities
            result.completed_at = datetime.utcnow()
            result.summary = {
                "files_scanned": files_scanned,
                "total_vulnerabilities": len(vulnerabilities),
                "severity_counts": result.get_severity_counts(),
                "risk_score": result.get_risk_score()
            }
            
        except Exception as e:
            logger.error(f"Static code scan failed: {e}")
            result.metadata["error"] = str(e)
        
        return result
    
    async def _scan_file(self, file_path: Path) -> List[Vulnerability]:
        """Scan individual file for security issues."""
        vulnerabilities = []
        
        try:
            content = file_path.read_text(encoding='utf-8', errors='ignore')
            
            # Determine file type
            file_type = self._get_file_type(file_path)
            rules = self.rules.get(file_type, [])
            
            for line_num, line in enumerate(content.splitlines(), 1):
                for rule in rules:
                    if re.search(rule["pattern"], line, re.IGNORECASE):
                        vuln = Vulnerability(
                            id=f"{rule['id']}_{file_path.name}_{line_num}",
                            title=rule["title"],
                            description=f"{rule['description']} in {file_path.name}:{line_num}",
                            severity=rule["severity"],
                            affected_component=str(file_path)
                        )
                        vulnerabilities.append(vuln)
        
        except Exception as e:
            logger.error(f"Failed to scan file {file_path}: {e}")
        
        return vulnerabilities
    
    def _get_file_type(self, file_path: Path) -> str:
        """Determine file type for rule selection."""
        suffix = file_path.suffix.lower()
        
        if suffix == ".py":
            return "python"
        elif suffix in [".js", ".jsx", ".ts", ".tsx"]:
            return "javascript"
        else:
            return "unknown"


class ContainerScanner:
    """Container security scanner."""
    
    async def scan_dockerfile(self, dockerfile_path: str) -> ScanResult:
        """Scan Dockerfile for security issues."""
        scan_id = f"dockerfile_{datetime.utcnow().strftime('%Y%m%d_%H%M%S')}"
        result = ScanResult(
            scan_id=scan_id,
            scan_type=ScanType.CONTAINER,
            target=dockerfile_path,
            started_at=datetime.utcnow()
        )
        
        try:
            vulnerabilities = []
            dockerfile_path_obj = Path(dockerfile_path)
            
            if not dockerfile_path_obj.exists():
                raise FileNotFoundError(f"Dockerfile not found: {dockerfile_path}")
            
            content = dockerfile_path_obj.read_text()
            lines = content.splitlines()
            
            # Check for security issues
            for line_num, line in enumerate(lines, 1):
                line = line.strip()
                
                # Check for running as root
                if line.upper().startswith("USER") and "root" in line.lower():
                    vuln = Vulnerability(
                        id=f"dockerfile_root_user_{line_num}",
                        title="Running as Root User",
                        description="Container runs as root user, which is a security risk",
                        severity=VulnerabilitySeverity.HIGH,
                        affected_component=dockerfile_path
                    )
                    vulnerabilities.append(vuln)
                
                # Check for missing USER instruction
                if line.upper().startswith("FROM") and line_num > 1:
                    # Check if USER instruction exists after FROM
                    user_found = any(l.strip().upper().startswith("USER") for l in lines[line_num:])
                    if not user_found:
                        vuln = Vulnerability(
                            id=f"dockerfile_no_user_{line_num}",
                            title="No USER Instruction",
                            description="Dockerfile lacks USER instruction, will run as root",
                            severity=VulnerabilitySeverity.MEDIUM,
                            affected_component=dockerfile_path
                        )
                        vulnerabilities.append(vuln)
                
                # Check for ADD instead of COPY
                if line.upper().startswith("ADD ") and not line.upper().startswith("ADD --"):
                    vuln = Vulnerability(
                        id=f"dockerfile_add_usage_{line_num}",
                        title="Use of ADD Instead of COPY",
                        description="ADD has additional features that can be security risks, use COPY when possible",
                        severity=VulnerabilitySeverity.LOW,
                        affected_component=dockerfile_path
                    )
                    vulnerabilities.append(vuln)
                
                # Check for latest tag
                if "latest" in line.lower() and ("from" in line.lower() or ":" in line):
                    vuln = Vulnerability(
                        id=f"dockerfile_latest_tag_{line_num}",
                        title="Use of 'latest' Tag",
                        description="Using 'latest' tag can lead to unpredictable builds",
                        severity=VulnerabilitySeverity.LOW,
                        affected_component=dockerfile_path
                    )
                    vulnerabilities.append(vuln)
            
            result.vulnerabilities = vulnerabilities
            result.completed_at = datetime.utcnow()
            result.summary = {
                "total_vulnerabilities": len(vulnerabilities),
                "severity_counts": result.get_severity_counts(),
                "risk_score": result.get_risk_score()
            }
            
        except Exception as e:
            logger.error(f"Dockerfile scan failed: {e}")
            result.metadata["error"] = str(e)
        
        return result
    
    async def scan_container_image(self, image_name: str) -> ScanResult:
        """Scan container image for vulnerabilities."""
        scan_id = f"container_{datetime.utcnow().strftime('%Y%m%d_%H%M%S')}"
        result = ScanResult(
            scan_id=scan_id,
            scan_type=ScanType.CONTAINER,
            target=image_name,
            started_at=datetime.utcnow()
        )
        
        try:
            vulnerabilities = []
            
            # Try different container scanning tools
            scanners = [
                self._run_trivy_scan,
                self._run_grype_scan,
                self._run_clair_scan
            ]
            
            for scanner in scanners:
                try:
                    scanner_vulns = await scanner(image_name)
                    vulnerabilities.extend(scanner_vulns)
                    break  # Use first successful scanner
                except Exception as e:
                    logger.debug(f"Scanner failed: {e}")
                    continue
            
            result.vulnerabilities = vulnerabilities
            result.completed_at = datetime.utcnow()
            result.summary = {
                "total_vulnerabilities": len(vulnerabilities),
                "severity_counts": result.get_severity_counts(),
                "risk_score": result.get_risk_score()
            }
            
        except Exception as e:
            logger.error(f"Container image scan failed: {e}")
            result.metadata["error"] = str(e)
        
        return result
    
    async def _run_trivy_scan(self, image_name: str) -> List[Vulnerability]:
        """Run Trivy container scanner."""
        vulnerabilities = []
        
        try:
            cmd = ["trivy", "image", "--format", "json", image_name]
            process = await asyncio.create_subprocess_exec(
                *cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            
            stdout, stderr = await process.communicate()
            
            if process.returncode == 0:
                data = json.loads(stdout.decode())
                
                for result in data.get("Results", []):
                    for vuln_data in result.get("Vulnerabilities", []):
                        vuln = Vulnerability(
                            id=f"trivy_{vuln_data.get('VulnerabilityID', 'unknown')}",
                            title=vuln_data.get("Title", "Unknown vulnerability"),
                            description=vuln_data.get("Description", ""),
                            severity=VulnerabilitySeverity(vuln_data.get("Severity", "low").lower()),
                            cve_id=vuln_data.get("VulnerabilityID"),
                            affected_component=vuln_data.get("PkgName", ""),
                            affected_version=vuln_data.get("InstalledVersion", ""),
                            fixed_version=vuln_data.get("FixedVersion", ""),
                            references=vuln_data.get("References", [])
                        )
                        vulnerabilities.append(vuln)
        
        except FileNotFoundError:
            raise Exception("Trivy not found, install from: https://github.com/aquasecurity/trivy")
        except Exception as e:
            raise Exception(f"Trivy scan failed: {e}")
        
        return vulnerabilities
    
    async def _run_grype_scan(self, image_name: str) -> List[Vulnerability]:
        """Run Grype container scanner."""
        vulnerabilities = []
        
        try:
            cmd = ["grype", "-o", "json", image_name]
            process = await asyncio.create_subprocess_exec(
                *cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            
            stdout, stderr = await process.communicate()
            
            if process.returncode == 0:
                data = json.loads(stdout.decode())
                
                for vuln_data in data.get("matches", []):
                    vulnerability = vuln_data.get("vulnerability", {})
                    artifact = vuln_data.get("artifact", {})
                    
                    vuln = Vulnerability(
                        id=f"grype_{vulnerability.get('id', 'unknown')}",
                        title=vulnerability.get("description", "Unknown vulnerability"),
                        description=vulnerability.get("description", ""),
                        severity=VulnerabilitySeverity(vulnerability.get("severity", "low").lower()),
                        cve_id=vulnerability.get("id"),
                        affected_component=artifact.get("name", ""),
                        affected_version=artifact.get("version", ""),
                        references=vulnerability.get("urls", [])
                    )
                    vulnerabilities.append(vuln)
        
        except FileNotFoundError:
            raise Exception("Grype not found, install from: https://github.com/anchore/grype")
        except Exception as e:
            raise Exception(f"Grype scan failed: {e}")
        
        return vulnerabilities
    
    async def _run_clair_scan(self, image_name: str) -> List[Vulnerability]:
        """Run Clair container scanner."""
        # Placeholder for Clair integration
        # Clair requires more complex setup with database
        raise Exception("Clair scanner not implemented")


class VulnerabilityManager:
    """Main vulnerability management system."""
    
    def __init__(self):
        self.dependency_scanner = DependencyScanner()
        self.static_scanner = StaticCodeScanner()
        self.container_scanner = ContainerScanner()
        
        self.scan_results: Dict[str, ScanResult] = {}
        self.vulnerability_database: Dict[str, Vulnerability] = {}
        
    async def run_comprehensive_scan(self, target_directory: str) -> Dict[str, ScanResult]:
        """Run comprehensive security scan on a project."""
        results = {}
        
        target_path = Path(target_directory)
        
        # Dependency scans
        requirements_file = target_path / "requirements.txt"
        if requirements_file.exists():
            result = await self.dependency_scanner.scan_python_dependencies(str(requirements_file))
            results["python_dependencies"] = result
            self.scan_results[result.scan_id] = result
        
        package_json = target_path / "package.json"
        if package_json.exists():
            result = await self.dependency_scanner.scan_npm_dependencies(str(package_json))
            results["npm_dependencies"] = result
            self.scan_results[result.scan_id] = result
        
        # Static code analysis
        result = await self.static_scanner.scan_directory(target_directory)
        results["static_code"] = result
        self.scan_results[result.scan_id] = result
        
        # Container scans
        dockerfile = target_path / "Dockerfile"
        if dockerfile.exists():
            result = await self.container_scanner.scan_dockerfile(str(dockerfile))
            results["dockerfile"] = result
            self.scan_results[result.scan_id] = result
        
        return results
    
    def get_vulnerability_summary(self, scan_results: Dict[str, ScanResult]) -> Dict[str, Any]:
        """Generate comprehensive vulnerability summary."""
        total_vulnerabilities = 0
        severity_counts = {severity.value: 0 for severity in VulnerabilitySeverity}
        affected_components = set()
        risk_scores = []
        
        for scan_type, result in scan_results.items():
            total_vulnerabilities += len(result.vulnerabilities)
            
            for vuln in result.vulnerabilities:
                severity_counts[vuln.severity.value] += 1
                if vuln.affected_component:
                    affected_components.add(vuln.affected_component)
            
            risk_scores.append(result.get_risk_score())
        
        overall_risk = sum(risk_scores) / len(risk_scores) if risk_scores else 0.0
        
        return {
            "total_vulnerabilities": total_vulnerabilities,
            "severity_breakdown": severity_counts,
            "affected_components": len(affected_components),
            "overall_risk_score": overall_risk,
            "scan_types_completed": list(scan_results.keys()),
            "recommendations": self._generate_recommendations(scan_results)
        }
    
    def _generate_recommendations(self, scan_results: Dict[str, ScanResult]) -> List[str]:
        """Generate security recommendations based on scan results."""
        recommendations = []
        
        # Check for critical vulnerabilities
        critical_count = sum(
            len([v for v in result.vulnerabilities if v.severity == VulnerabilitySeverity.CRITICAL])
            for result in scan_results.values()
        )
        
        if critical_count > 0:
            recommendations.append(f"Address {critical_count} critical vulnerabilities immediately")
        
        # Check for dependency issues
        if "python_dependencies" in scan_results or "npm_dependencies" in scan_results:
            recommendations.append("Update dependencies to latest secure versions")
            recommendations.append("Consider using dependency pinning and automated updates")
        
        # Check for code quality issues
        if "static_code" in scan_results:
            static_result = scan_results["static_code"]
            if len(static_result.vulnerabilities) > 10:
                recommendations.append("Implement secure coding practices and code review processes")
        
        # Check for container issues
        if "dockerfile" in scan_results:
            recommendations.append("Follow container security best practices")
            recommendations.append("Use non-root users in containers")
        
        return recommendations
    
    async def generate_security_report(self, scan_results: Dict[str, ScanResult]) -> Dict[str, Any]:
        """Generate comprehensive security report."""
        summary = self.get_vulnerability_summary(scan_results)
        
        report = {
            "report_id": f"security_report_{datetime.utcnow().strftime('%Y%m%d_%H%M%S')}",
            "generated_at": datetime.utcnow().isoformat(),
            "summary": summary,
            "detailed_results": {},
            "action_items": []
        }
        
        # Add detailed results
        for scan_type, result in scan_results.items():
            report["detailed_results"][scan_type] = {
                "scan_id": result.scan_id,
                "target": result.target,
                "vulnerabilities": [vuln.to_dict() for vuln in result.vulnerabilities],
                "summary": result.summary,
                "risk_score": result.get_risk_score()
            }
        
        # Generate action items
        action_items = []
        
        # Critical vulnerabilities
        for scan_type, result in scan_results.items():
            critical_vulns = [v for v in result.vulnerabilities if v.severity == VulnerabilitySeverity.CRITICAL]
            for vuln in critical_vulns:
                action_items.append({
                    "priority": "CRITICAL",
                    "action": f"Fix {vuln.title} in {vuln.affected_component}",
                    "description": vuln.description,
                    "fix_version": vuln.fixed_version
                })
        
        # High severity vulnerabilities
        for scan_type, result in scan_results.items():
            high_vulns = [v for v in result.vulnerabilities if v.severity == VulnerabilitySeverity.HIGH]
            for vuln in high_vulns[:5]:  # Limit to top 5
                action_items.append({
                    "priority": "HIGH",
                    "action": f"Address {vuln.title} in {vuln.affected_component}",
                    "description": vuln.description,
                    "fix_version": vuln.fixed_version
                })
        
        report["action_items"] = action_items
        
        return report


# Global vulnerability manager instance
_vuln_manager: Optional[VulnerabilityManager] = None


def get_vulnerability_manager() -> VulnerabilityManager:
    """Get global vulnerability manager instance."""
    global _vuln_manager
    if _vuln_manager is None:
        _vuln_manager = VulnerabilityManager()
    return _vuln_manager


__all__ = [
    "VulnerabilitySeverity",
    "ScanType",
    "Vulnerability", 
    "ScanResult",
    "DependencyScanner",
    "StaticCodeScanner",
    "ContainerScanner",
    "VulnerabilityManager",
    "get_vulnerability_manager"
]