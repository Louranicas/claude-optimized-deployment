{
  "unwrap_calls": [
    {
      "file": "src/infrastructure.rs",
      "line": 128,
      "code": "let _permit = semaphore.acquire().await.unwrap();",
      "context": [
        "                        ",
        "                        tokio::spawn(async move {",
        "                            let _permit = semaphore.acquire().await.unwrap();",
        "                            let key = format!(\"{}:{}\", host, port);",
        "                            "
      ]
    },
    {
      "file": "src/infrastructure.rs",
      "line": 341,
      "code": "&self.validated_configs.get(&config_id).unwrap().value()",
      "context": [
        "        // Return as JSON",
        "        let json = serde_json::to_string_pretty(",
        "            &self.validated_configs.get(&config_id).unwrap().value()",
        "        ).map_err(|e| CoreError::Serialization(format!(\"JSON serialize error: {}\", e)))?;",
        "        "
      ]
    },
    {
      "file": "src/infrastructure.rs",
      "line": 408,
      "code": "regex::Regex::new(r\"(?i)(error|exception|failed)\").unwrap()",
      "context": [
        "        patterns.insert(",
        "            \"error\".to_string(),",
        "            regex::Regex::new(r\"(?i)(error|exception|failed)\").unwrap()",
        "        );",
        "        patterns.insert("
      ]
    },
    {
      "file": "src/infrastructure.rs",
      "line": 412,
      "code": "regex::Regex::new(r\"(?i)(warn|warning|deprecated)\").unwrap()",
      "context": [
        "        patterns.insert(",
        "            \"warning\".to_string(),",
        "            regex::Regex::new(r\"(?i)(warn|warning|deprecated)\").unwrap()",
        "        );",
        "        patterns.insert("
      ]
    },
    {
      "file": "src/infrastructure.rs",
      "line": 416,
      "code": "regex::Regex::new(r\"\\d{4}-\\d{2}-\\d{2}[T\\s]\\d{2}:\\d{2}:\\d{2}\").unwrap()",
      "context": [
        "        patterns.insert(",
        "            \"timestamp\".to_string(),",
        "            regex::Regex::new(r\"\\d{4}-\\d{2}-\\d{2}[T\\s]\\d{2}:\\d{2}:\\d{2}\").unwrap()",
        "        );",
        "        "
      ]
    },
    {
      "file": "src/security_enhanced.rs",
      "line": 43,
      "code": "Regex::new(r\"^[a-zA-Z0-9_\\-\\.\\/]+$\").unwrap()",
      "context": [
        "// Command validation patterns",
        "static SAFE_COMMAND_PATTERN: Lazy<Regex> = Lazy::new(|| {",
        "    Regex::new(r\"^[a-zA-Z0-9_\\-\\.\\/]+$\").unwrap()",
        "});",
        ""
      ]
    },
    {
      "file": "src/security_enhanced.rs",
      "line": 48,
      "code": "Regex::new(r\"(;|\\||&&|\\$\\(|\\`|>|<)\").unwrap(),  // Command injection",
      "context": [
        "static DANGEROUS_PATTERNS: Lazy<Vec<Regex>> = Lazy::new(|| {",
        "    vec![",
        "        Regex::new(r\"(;|\\||&&|\\$\\(|\\`|>|<)\").unwrap(),  // Command injection",
        "        Regex::new(r\"\\.\\.\\/\").unwrap(),                  // Path traversal",
        "        Regex::new(r\"\\$\\{.*\\}\").unwrap(),               // Variable expansion"
      ]
    },
    {
      "file": "src/security_enhanced.rs",
      "line": 49,
      "code": "Regex::new(r\"\\.\\.\\/\").unwrap(),                  // Path traversal",
      "context": [
        "    vec![",
        "        Regex::new(r\"(;|\\||&&|\\$\\(|\\`|>|<)\").unwrap(),  // Command injection",
        "        Regex::new(r\"\\.\\.\\/\").unwrap(),                  // Path traversal",
        "        Regex::new(r\"\\$\\{.*\\}\").unwrap(),               // Variable expansion",
        "        Regex::new(r\"eval|exec|system\").unwrap(),       // Dangerous functions"
      ]
    },
    {
      "file": "src/security_enhanced.rs",
      "line": 50,
      "code": "Regex::new(r\"\\$\\{.*\\}\").unwrap(),               // Variable expansion",
      "context": [
        "        Regex::new(r\"(;|\\||&&|\\$\\(|\\`|>|<)\").unwrap(),  // Command injection",
        "        Regex::new(r\"\\.\\.\\/\").unwrap(),                  // Path traversal",
        "        Regex::new(r\"\\$\\{.*\\}\").unwrap(),               // Variable expansion",
        "        Regex::new(r\"eval|exec|system\").unwrap(),       // Dangerous functions",
        "    ]"
      ]
    },
    {
      "file": "src/security_enhanced.rs",
      "line": 51,
      "code": "Regex::new(r\"eval|exec|system\").unwrap(),       // Dangerous functions",
      "context": [
        "        Regex::new(r\"\\.\\.\\/\").unwrap(),                  // Path traversal",
        "        Regex::new(r\"\\$\\{.*\\}\").unwrap(),               // Variable expansion",
        "        Regex::new(r\"eval|exec|system\").unwrap(),       // Dangerous functions",
        "    ]",
        "});"
      ]
    },
    {
      "file": "src/security_enhanced.rs",
      "line": 331,
      "code": ".unwrap()",
      "context": [
        "        let now = SystemTime::now()",
        "            .duration_since(UNIX_EPOCH)",
        "            .unwrap()",
        "            .as_secs();",
        "        "
      ]
    },
    {
      "file": "src/security_enhanced.rs",
      "line": 483,
      "code": ".unwrap()",
      "context": [
        "            timestamp: SystemTime::now()",
        "                .duration_since(UNIX_EPOCH)",
        "                .unwrap()",
        "                .as_secs(),",
        "            user_id: context.user_id.clone(),"
      ]
    },
    {
      "file": "src/security_enhanced.rs",
      "line": 852,
      "code": "pattern: Regex::new(r#\"(password|passwd|pwd)\\s*=\\s*['\\\"].*['\\\"]\"#).unwrap(),",
      "context": [
        "                SecurityRule {",
        "                    name: \"Hardcoded Credentials\".to_string(),",
        "                    pattern: Regex::new(r#\"(password|passwd|pwd)\\s*=\\s*['\\\"].*['\\\"]\"#).unwrap(),",
        "                    severity: Severity::Critical,",
        "                },"
      ]
    },
    {
      "file": "src/security_enhanced.rs",
      "line": 857,
      "code": "pattern: Regex::new(r\"(MD5|SHA1|DES|RC4)\").unwrap(),",
      "context": [
        "                SecurityRule {",
        "                    name: \"Weak Cryptography\".to_string(),",
        "                    pattern: Regex::new(r\"(MD5|SHA1|DES|RC4)\").unwrap(),",
        "                    severity: Severity::High,",
        "                },"
      ]
    },
    {
      "file": "src/security_enhanced.rs",
      "line": 862,
      "code": "pattern: Regex::new(r\"pickle\\.loads|yaml\\.load\\(\").unwrap(),",
      "context": [
        "                SecurityRule {",
        "                    name: \"Unsafe Deserialization\".to_string(),",
        "                    pattern: Regex::new(r\"pickle\\.loads|yaml\\.load\\(\").unwrap(),",
        "                    severity: Severity::High,",
        "                },"
      ]
    },
    {
      "file": "src/security_enhanced.rs",
      "line": 1153,
      "code": "\"timestamp\": SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs(),",
      "context": [
        "        ",
        "        let comprehensive_report = serde_json::json!({",
        "            \"timestamp\": SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs(),",
        "            \"security_tests\": audit_results,",
        "            \"audit_summary\": serde_json::from_str::<serde_json::Value>(&audit_report).unwrap(),"
      ]
    },
    {
      "file": "src/security_enhanced.rs",
      "line": 1155,
      "code": "\"audit_summary\": serde_json::from_str::<serde_json::Value>(&audit_report).unwrap(),",
      "context": [
        "            \"timestamp\": SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs(),",
        "            \"security_tests\": audit_results,",
        "            \"audit_summary\": serde_json::from_str::<serde_json::Value>(&audit_report).unwrap(),",
        "        });",
        "        "
      ]
    },
    {
      "file": "src/security_enhanced.rs",
      "line": 1258,
      "code": ").unwrap();",
      "context": [
        "            None,",
        "            None,",
        "        ).unwrap();",
        "",
        "        assert_eq!(logs.len(), 1);"
      ]
    },
    {
      "file": "src/adaptive_learning.rs",
      "line": 134,
      "code": "let mut state = self.cross_instance_state.lock().unwrap();",
      "context": [
        "        // Update cross-instance state",
        "        {",
        "            let mut state = self.cross_instance_state.lock().unwrap();",
        "            state.shared_knowledge.extend(merged_knowledge);",
        "            state.sync_timestamp = std::time::SystemTime::now();"
      ]
    },
    {
      "file": "src/adaptive_learning.rs",
      "line": 211,
      "code": "self.process_single_pattern_optimized(pattern.to_slice().unwrap())",
      "context": [
        "            .map(|i| {",
        "                let pattern = patterns.row(i);",
        "                self.process_single_pattern_optimized(pattern.to_slice().unwrap())",
        "            })",
        "            .collect::<Vec<f64>>();"
      ]
    },
    {
      "file": "src/adaptive_learning.rs",
      "line": 227,
      "code": "let metrics = self.performance_metrics.lock().unwrap();",
      "context": [
        "    /// Get performance statistics",
        "    fn get_performance_stats(&self, py: Python<'_>) -> PyResult<PyObject> {",
        "        let metrics = self.performance_metrics.lock().unwrap();",
        "        ",
        "        let result = PyDict::new(py);"
      ]
    },
    {
      "file": "src/adaptive_learning.rs",
      "line": 295,
      "code": ".unwrap()",
      "context": [
        "                std::time::SystemTime::now()",
        "                    .duration_since(std::time::UNIX_EPOCH)",
        "                    .unwrap()",
        "                    .as_nanos()",
        "            ),"
      ]
    },
    {
      "file": "src/adaptive_learning.rs",
      "line": 401,
      "code": "let mut metrics = self.performance_metrics.lock().unwrap();",
      "context": [
        "",
        "    fn update_performance_metrics(&self, processing_time: f64, pattern_count: usize) {",
        "        let mut metrics = self.performance_metrics.lock().unwrap();",
        "        ",
        "        metrics.total_patterns_processed += pattern_count as u64;"
      ]
    },
    {
      "file": "src/adaptive_learning.rs",
      "line": 735,
      "code": "dict.set_item(\"pattern_id\", &pattern.pattern_id).unwrap();",
      "context": [
        "        let py_list = PyList::new(py, patterns.iter().map(|pattern| {",
        "            let dict = PyDict::new(py);",
        "            dict.set_item(\"pattern_id\", &pattern.pattern_id).unwrap();",
        "            dict.set_item(\"confidence\", pattern.confidence).unwrap();",
        "            dict.set_item(\"enhancement_score\", pattern.enhancement_score).unwrap();"
      ]
    },
    {
      "file": "src/adaptive_learning.rs",
      "line": 736,
      "code": "dict.set_item(\"confidence\", pattern.confidence).unwrap();",
      "context": [
        "            let dict = PyDict::new(py);",
        "            dict.set_item(\"pattern_id\", &pattern.pattern_id).unwrap();",
        "            dict.set_item(\"confidence\", pattern.confidence).unwrap();",
        "            dict.set_item(\"enhancement_score\", pattern.enhancement_score).unwrap();",
        "            dict"
      ]
    },
    {
      "file": "src/adaptive_learning.rs",
      "line": 737,
      "code": "dict.set_item(\"enhancement_score\", pattern.enhancement_score).unwrap();",
      "context": [
        "            dict.set_item(\"pattern_id\", &pattern.pattern_id).unwrap();",
        "            dict.set_item(\"confidence\", pattern.confidence).unwrap();",
        "            dict.set_item(\"enhancement_score\", pattern.enhancement_score).unwrap();",
        "            dict",
        "        }));"
      ]
    },
    {
      "file": "src/zero_copy_net.rs",
      "line": 260,
      "code": "let runtime = tokio::runtime::Runtime::new().unwrap();",
      "context": [
        "    fn connect(&self, py: Python, address: String, port: u16) -> PyResult<String> {",
        "        py.allow_threads(|| {",
        "            let runtime = tokio::runtime::Runtime::new().unwrap();",
        "            runtime.block_on(async {",
        "                let addr = format!(\"{}:{}\", address, port);"
      ]
    },
    {
      "file": "src/zero_copy_net.rs",
      "line": 392,
      "code": "let runtime = tokio::runtime::Runtime::new().unwrap();",
      "context": [
        "            ",
        "            // Create new connection",
        "            let runtime = tokio::runtime::Runtime::new().unwrap();",
        "            runtime.block_on(async {",
        "                match TcpStream::connect(&address).await {"
      ]
    },
    {
      "file": "src/performance.rs",
      "line": 159,
      "code": "tx_io.send((task.id.clone(), duration.as_secs_f64())).unwrap();",
      "context": [
        "                    std::thread::sleep(Duration::from_millis(10));",
        "                    let duration = start.elapsed();",
        "                    tx_io.send((task.id.clone(), duration.as_secs_f64())).unwrap();",
        "                });",
        "            });"
      ]
    },
    {
      "file": "src/performance.rs",
      "line": 176,
      "code": "tx_cpu.send((task.id.clone(), duration.as_secs_f64())).unwrap();",
      "context": [
        "                    }",
        "                    let duration = start.elapsed();",
        "                    tx_cpu.send((task.id.clone(), duration.as_secs_f64())).unwrap();",
        "                });",
        "            });"
      ]
    },
    {
      "file": "src/performance.rs",
      "line": 184,
      "code": "let runtime = tokio::runtime::Runtime::new().unwrap();",
      "context": [
        "        if !async_tasks.is_empty() {",
        "            py.allow_threads(|| {",
        "                let runtime = tokio::runtime::Runtime::new().unwrap();",
        "                runtime.block_on(async {",
        "                    for task in async_tasks {"
      ]
    },
    {
      "file": "src/performance.rs",
      "line": 192,
      "code": "tx_async.send((task.id.clone(), duration.as_secs_f64())).unwrap();",
      "context": [
        "                            tokio::time::sleep(Duration::from_millis(5)).await;",
        "                            let duration = start.elapsed();",
        "                            tx_async.send((task.id.clone(), duration.as_secs_f64())).unwrap();",
        "                        });",
        "                    }"
      ]
    },
    {
      "file": "src/performance.rs",
      "line": 267,
      "code": "sorted.sort_by(|a, b| a.partial_cmp(b).unwrap());",
      "context": [
        "                ",
        "                let mut sorted = values.clone();",
        "                sorted.sort_by(|a, b| a.partial_cmp(b).unwrap());",
        "                ",
        "                stats.insert(\"count\".to_string(), count);"
      ]
    },
    {
      "file": "src/performance.rs",
      "line": 271,
      "code": "stats.insert(\"min\".to_string(), *sorted.first().unwrap());",
      "context": [
        "                stats.insert(\"count\".to_string(), count);",
        "                stats.insert(\"mean\".to_string(), mean);",
        "                stats.insert(\"min\".to_string(), *sorted.first().unwrap());",
        "                stats.insert(\"max\".to_string(), *sorted.last().unwrap());",
        "                stats.insert(\"p50\".to_string(), sorted[sorted.len() / 2]);"
      ]
    },
    {
      "file": "src/performance.rs",
      "line": 272,
      "code": "stats.insert(\"max\".to_string(), *sorted.last().unwrap());",
      "context": [
        "                stats.insert(\"mean\".to_string(), mean);",
        "                stats.insert(\"min\".to_string(), *sorted.first().unwrap());",
        "                stats.insert(\"max\".to_string(), *sorted.last().unwrap());",
        "                stats.insert(\"p50\".to_string(), sorted[sorted.len() / 2]);",
        "                stats.insert(\"p95\".to_string(), sorted[(sorted.len() as f64 * 0.95) as usize]);"
      ]
    },
    {
      "file": "src/performance.rs",
      "line": 398,
      "code": "let _json = serde_json::to_string(&vec![1, 2, 3, 4, 5]).unwrap();",
      "context": [
        "                }",
        "                \"serialize\" => {",
        "                    let _json = serde_json::to_string(&vec![1, 2, 3, 4, 5]).unwrap();",
        "                }",
        "                _ => {}"
      ]
    },
    {
      "file": "src/security.rs",
      "line": 208,
      "code": "serde_json::Value::Number(serde_json::Number::from_f64(security_score).unwrap())",
      "context": [
        "        report.insert(",
        "            \"security_score\".to_string(),",
        "            serde_json::Value::Number(serde_json::Number::from_f64(security_score).unwrap())",
        "        );",
        "        "
      ]
    },
    {
      "file": "src/services/lifecycle.rs",
      "line": 483,
      "code": "manager.register_service(service_id, vec![]).await.unwrap();",
      "context": [
        "        ",
        "        // Register service",
        "        manager.register_service(service_id, vec![]).await.unwrap();",
        "        ",
        "        // Check initial state"
      ]
    },
    {
      "file": "src/services/lifecycle.rs",
      "line": 486,
      "code": "let state = manager.get_service_state(service_id).await.unwrap();",
      "context": [
        "        ",
        "        // Check initial state",
        "        let state = manager.get_service_state(service_id).await.unwrap();",
        "        assert_eq!(state, DeploymentState::Pending);",
        "        "
      ]
    },
    {
      "file": "src/services/lifecycle.rs",
      "line": 490,
      "code": "manager.start_service(service_id).await.unwrap();",
      "context": [
        "        ",
        "        // Start service",
        "        manager.start_service(service_id).await.unwrap();",
        "        ",
        "        let state = manager.get_service_state(service_id).await.unwrap();"
      ]
    },
    {
      "file": "src/services/lifecycle.rs",
      "line": 492,
      "code": "let state = manager.get_service_state(service_id).await.unwrap();",
      "context": [
        "        manager.start_service(service_id).await.unwrap();",
        "        ",
        "        let state = manager.get_service_state(service_id).await.unwrap();",
        "        assert_eq!(state, DeploymentState::Running);",
        "        "
      ]
    },
    {
      "file": "src/services/lifecycle.rs",
      "line": 496,
      "code": "manager.stop_service(service_id).await.unwrap();",
      "context": [
        "        ",
        "        // Stop service",
        "        manager.stop_service(service_id).await.unwrap();",
        "        ",
        "        let state = manager.get_service_state(service_id).await.unwrap();"
      ]
    },
    {
      "file": "src/services/lifecycle.rs",
      "line": 498,
      "code": "let state = manager.get_service_state(service_id).await.unwrap();",
      "context": [
        "        manager.stop_service(service_id).await.unwrap();",
        "        ",
        "        let state = manager.get_service_state(service_id).await.unwrap();",
        "        assert_eq!(state, DeploymentState::Stopped);",
        "    }"
      ]
    },
    {
      "file": "src/services/registry.rs",
      "line": 342,
      "code": "registry.register_service(metadata.clone()).await.unwrap();",
      "context": [
        "        };",
        "        ",
        "        registry.register_service(metadata.clone()).await.unwrap();",
        "        ",
        "        let retrieved = registry.get_service(metadata.id).await.unwrap();"
      ]
    },
    {
      "file": "src/services/registry.rs",
      "line": 344,
      "code": "let retrieved = registry.get_service(metadata.id).await.unwrap();",
      "context": [
        "        registry.register_service(metadata.clone()).await.unwrap();",
        "        ",
        "        let retrieved = registry.get_service(metadata.id).await.unwrap();",
        "        assert_eq!(retrieved.name, metadata.name);",
        "        assert_eq!(retrieved.version, metadata.version);"
      ]
    },
    {
      "file": "src/services/registry.rs",
      "line": 381,
      "code": "handle.await.unwrap().unwrap();",
      "context": [
        "        ",
        "        for handle in handles {",
        "            handle.await.unwrap().unwrap();",
        "        }",
        "        "
      ]
    },
    {
      "file": "src/services/registry.rs",
      "line": 384,
      "code": "let services = registry.list_services().await.unwrap();",
      "context": [
        "        }",
        "        ",
        "        let services = registry.list_services().await.unwrap();",
        "        assert_eq!(services.len(), 100);",
        "    }"
      ]
    },
    {
      "file": "src/services/registry.rs",
      "line": 410,
      "code": "registry.register_service(metadata.clone()).await.unwrap();",
      "context": [
        "        };",
        "        ",
        "        registry.register_service(metadata.clone()).await.unwrap();",
        "        ",
        "        // Update state"
      ]
    },
    {
      "file": "src/services/registry.rs",
      "line": 413,
      "code": "registry.update_service_state(metadata.id, DeploymentState::Running).await.unwrap();",
      "context": [
        "        ",
        "        // Update state",
        "        registry.update_service_state(metadata.id, DeploymentState::Running).await.unwrap();",
        "        ",
        "        let updated = registry.get_service(metadata.id).await.unwrap();"
      ]
    },
    {
      "file": "src/services/registry.rs",
      "line": 415,
      "code": "let updated = registry.get_service(metadata.id).await.unwrap();",
      "context": [
        "        registry.update_service_state(metadata.id, DeploymentState::Running).await.unwrap();",
        "        ",
        "        let updated = registry.get_service(metadata.id).await.unwrap();",
        "        assert_eq!(updated.state, DeploymentState::Running);",
        "    }"
      ]
    },
    {
      "file": "src/services/health_check.rs",
      "line": 131,
      "code": "(now - task.last_check.unwrap()).num_seconds() >= task.current_interval_secs as i64",
      "context": [
        "                                let task = entry.value();",
        "                                task.last_check.is_none() || ",
        "                                (now - task.last_check.unwrap()).num_seconds() >= task.current_interval_secs as i64",
        "                            })",
        "                            .map(|entry| (*entry.key(), entry.value().clone()))"
      ]
    },
    {
      "file": "src/services/health_check.rs",
      "line": 147,
      "code": "let _permit = permit.unwrap();",
      "context": [
        "                            ",
        "                            tokio::spawn(async move {",
        "                                let _permit = permit.unwrap();",
        "                                ",
        "                                let result = Self::perform_health_check("
      ]
    },
    {
      "file": "src/orchestrator/scheduler.rs",
      "line": 413,
      "code": "scheduler.schedule_deployment(task.clone()).await.unwrap();",
      "context": [
        "        };",
        "        ",
        "        scheduler.schedule_deployment(task.clone()).await.unwrap();",
        "        ",
        "        let stats = scheduler.get_stats().await;"
      ]
    },
    {
      "file": "src/orchestrator/scheduler.rs",
      "line": 420,
      "code": "assert_eq!(next_task.unwrap().service_id, task.service_id);",
      "context": [
        "        let next_task = scheduler.get_next_task().await;",
        "        assert!(next_task.is_some());",
        "        assert_eq!(next_task.unwrap().service_id, task.service_id);",
        "    }",
        "    "
      ]
    },
    {
      "file": "src/orchestrator/scheduler.rs",
      "line": 456,
      "code": "scheduler.schedule_deployment(low_priority.clone()).await.unwrap();",
      "context": [
        "        };",
        "        ",
        "        scheduler.schedule_deployment(low_priority.clone()).await.unwrap();",
        "        scheduler.schedule_deployment(high_priority.clone()).await.unwrap();",
        "        "
      ]
    },
    {
      "file": "src/orchestrator/scheduler.rs",
      "line": 457,
      "code": "scheduler.schedule_deployment(high_priority.clone()).await.unwrap();",
      "context": [
        "        ",
        "        scheduler.schedule_deployment(low_priority.clone()).await.unwrap();",
        "        scheduler.schedule_deployment(high_priority.clone()).await.unwrap();",
        "        ",
        "        // High priority should be scheduled first"
      ]
    },
    {
      "file": "src/orchestrator/scheduler.rs",
      "line": 460,
      "code": "let next = scheduler.get_next_task().await.unwrap();",
      "context": [
        "        ",
        "        // High priority should be scheduled first",
        "        let next = scheduler.get_next_task().await.unwrap();",
        "        assert_eq!(next.service_id, high_priority.service_id);",
        "    }"
      ]
    },
    {
      "file": "src/orchestrator/executor.rs",
      "line": 402,
      "code": "let result = executor.execute_deployment(service_id).await.unwrap();",
      "context": [
        "        ",
        "        let service_id = Uuid::new_v4();",
        "        let result = executor.execute_deployment(service_id).await.unwrap();",
        "        ",
        "        assert!(result.success);"
      ]
    },
    {
      "file": "src/orchestrator/executor.rs",
      "line": 430,
      "code": "executor_clone.cancel_execution(service_id).await.unwrap();",
      "context": [
        "        ",
        "        // Cancel it",
        "        executor_clone.cancel_execution(service_id).await.unwrap();",
        "        ",
        "        // Wait for result"
      ]
    },
    {
      "file": "src/orchestrator/executor.rs",
      "line": 433,
      "code": "let result = exec_handle.await.unwrap();",
      "context": [
        "        ",
        "        // Wait for result",
        "        let result = exec_handle.await.unwrap();",
        "        assert!(result.is_err() || !result.unwrap().success);",
        "    }"
      ]
    },
    {
      "file": "src/orchestrator/executor.rs",
      "line": 434,
      "code": "assert!(result.is_err() || !result.unwrap().success);",
      "context": [
        "        // Wait for result",
        "        let result = exec_handle.await.unwrap();",
        "        assert!(result.is_err() || !result.unwrap().success);",
        "    }",
        "}"
      ]
    },
    {
      "file": "src/orchestrator/engine.rs",
      "line": 416,
      "code": ").await.unwrap();",
      "context": [
        "            \"1.0.0\".to_string(),",
        "            resources,",
        "        ).await.unwrap();",
        "        ",
        "        assert_eq!(metadata.name, \"test-service\");"
      ]
    },
    {
      "file": "src/mcp_manager/server.rs",
      "line": 305,
      "code": "let server = McpServer::new(\"test-1\".to_string(), config).unwrap();",
      "context": [
        "    async fn test_server_creation() {",
        "        let config = create_test_config();",
        "        let server = McpServer::new(\"test-1\".to_string(), config).unwrap();",
        "        ",
        "        assert_eq!(server.id(), \"test-1\");"
      ]
    },
    {
      "file": "src/mcp_manager/server.rs",
      "line": 316,
      "code": "let server = McpServer::new(\"test-1\".to_string(), config).unwrap();",
      "context": [
        "    async fn test_server_state_transitions() {",
        "        let config = create_test_config();",
        "        let server = McpServer::new(\"test-1\".to_string(), config).unwrap();",
        "        ",
        "        assert_eq!(server.state().await, ServerState::Initializing);"
      ]
    },
    {
      "file": "src/mcp_manager/server.rs",
      "line": 330,
      "code": "let server = McpServer::new(\"test-1\".to_string(), config).unwrap();",
      "context": [
        "    async fn test_server_tags() {",
        "        let config = create_test_config();",
        "        let server = McpServer::new(\"test-1\".to_string(), config).unwrap();",
        "        ",
        "        assert!(server.matches_tags(&[\"test\".to_string()]));"
      ]
    },
    {
      "file": "src/mcp_manager/deployment.rs",
      "line": 425,
      "code": "let server = manager.deploy_server(\"test-1\".to_string(), server_config).await.unwrap();",
      "context": [
        "        ",
        "        let server_config = create_test_config();",
        "        let server = manager.deploy_server(\"test-1\".to_string(), server_config).await.unwrap();",
        "        ",
        "        assert_eq!(server.id(), \"test-1\");"
      ]
    },
    {
      "file": "src/mcp_manager/deployment.rs",
      "line": 441,
      "code": "manager.deploy_server(\"test-1\".to_string(), server_config).await.unwrap();",
      "context": [
        "        ",
        "        let server_config = create_test_config();",
        "        manager.deploy_server(\"test-1\".to_string(), server_config).await.unwrap();",
        "        ",
        "        let info = manager.get_deployment(\"test-1\").await.unwrap();"
      ]
    },
    {
      "file": "src/mcp_manager/deployment.rs",
      "line": 443,
      "code": "let info = manager.get_deployment(\"test-1\").await.unwrap();",
      "context": [
        "        manager.deploy_server(\"test-1\".to_string(), server_config).await.unwrap();",
        "        ",
        "        let info = manager.get_deployment(\"test-1\").await.unwrap();",
        "        assert_eq!(info.state, DeploymentState::Deployed);",
        "        assert_eq!(info.instances, 1);"
      ]
    },
    {
      "file": "src/mcp_manager/registry.rs",
      "line": 103,
      "code": "let server = Arc::new(McpServer::new(\"test\".to_string(), config).unwrap());",
      "context": [
        "        };",
        "        ",
        "        let server = Arc::new(McpServer::new(\"test\".to_string(), config).unwrap());",
        "        ",
        "        // Register"
      ]
    },
    {
      "file": "src/mcp_manager/registry.rs",
      "line": 106,
      "code": "registry.register(\"test\".to_string(), server.clone()).await.unwrap();",
      "context": [
        "        ",
        "        // Register",
        "        registry.register(\"test\".to_string(), server.clone()).await.unwrap();",
        "        assert_eq!(registry.count(), 1);",
        "        "
      ]
    },
    {
      "file": "src/mcp_manager/registry.rs",
      "line": 119,
      "code": "registry.unregister(\"test\").await.unwrap();",
      "context": [
        "        ",
        "        // Unregister",
        "        registry.unregister(\"test\").await.unwrap();",
        "        assert_eq!(registry.count(), 0);",
        "    }"
      ]
    },
    {
      "file": "src/mcp_manager/actor.rs",
      "line": 460,
      "code": "let server_id = runtime.deploy(server_config).await.unwrap();",
      "context": [
        "        };",
        "        ",
        "        let server_id = runtime.deploy(server_config).await.unwrap();",
        "        assert_eq!(server_id, \"test-server\");",
        "        "
      ]
    },
    {
      "file": "src/mcp_manager/actor.rs",
      "line": 464,
      "code": "let servers = runtime.list_servers().await.unwrap();",
      "context": [
        "        ",
        "        // List servers (should have one)",
        "        let servers = runtime.list_servers().await.unwrap();",
        "        assert_eq!(servers.len(), 1);",
        "        assert_eq!(servers[0], \"test-server\");"
      ]
    },
    {
      "file": "src/mcp_manager/actor.rs",
      "line": 469,
      "code": "let metrics = runtime.get_metrics(None).await.unwrap();",
      "context": [
        "        ",
        "        // Get metrics",
        "        let metrics = runtime.get_metrics(None).await.unwrap();",
        "        assert_eq!(metrics.active_servers, 1);",
        "        assert!(metrics.total_commands > 0);"
      ]
    },
    {
      "file": "src/mcp_manager/actor.rs",
      "line": 474,
      "code": "runtime.undeploy(&server_id).await.unwrap();",
      "context": [
        "        ",
        "        // Undeploy",
        "        runtime.undeploy(&server_id).await.unwrap();",
        "        ",
        "        // List servers (should be empty again)"
      ]
    },
    {
      "file": "src/mcp_manager/actor.rs",
      "line": 477,
      "code": "let servers = runtime.list_servers().await.unwrap();",
      "context": [
        "        ",
        "        // List servers (should be empty again)",
        "        let servers = runtime.list_servers().await.unwrap();",
        "        assert!(servers.is_empty());",
        "        "
      ]
    },
    {
      "file": "src/mcp_manager/actor.rs",
      "line": 481,
      "code": "runtime.shutdown().await.unwrap();",
      "context": [
        "        ",
        "        // Shutdown",
        "        runtime.shutdown().await.unwrap();",
        "    }",
        "}"
      ]
    },
    {
      "file": "src/mcp_manager/tests.rs",
      "line": 79,
      "code": "let server1 = lb_hash.select_server(Some(\"user123\")).await.unwrap();",
      "context": [
        "            ",
        "            // Same key should always go to same server",
        "            let server1 = lb_hash.select_server(Some(\"user123\")).await.unwrap();",
        "            let server2 = lb_hash.select_server(Some(\"user123\")).await.unwrap();",
        "            assert_eq!(server1, server2);"
      ]
    },
    {
      "file": "src/mcp_manager/tests.rs",
      "line": 80,
      "code": "let server2 = lb_hash.select_server(Some(\"user123\")).await.unwrap();",
      "context": [
        "            // Same key should always go to same server",
        "            let server1 = lb_hash.select_server(Some(\"user123\")).await.unwrap();",
        "            let server2 = lb_hash.select_server(Some(\"user123\")).await.unwrap();",
        "            assert_eq!(server1, server2);",
        "        });"
      ]
    },
    {
      "file": "src/mcp_manager/tests.rs",
      "line": 127,
      "code": "manager.save_snapshot(\"primary\".to_string(), data).await.unwrap();",
      "context": [
        "            // Test state snapshot",
        "            let data = b\"test state data\".to_vec();",
        "            manager.save_snapshot(\"primary\".to_string(), data).await.unwrap();",
        "        });",
        "    }"
      ]
    },
    {
      "file": "src/mcp_manager/tests.rs",
      "line": 151,
      "code": "let experiment_id = chaos.schedule_experiment(config).await.unwrap();",
      "context": [
        "            };",
        "            ",
        "            let experiment_id = chaos.schedule_experiment(config).await.unwrap();",
        "            assert!(!experiment_id.is_empty());",
        "            "
      ]
    },
    {
      "file": "src/mcp_manager/tests.rs",
      "line": 269,
      "code": "cache.put(\"key1\".to_string(), vec![1, 2, 3], 3).await.unwrap();",
      "context": [
        "            ",
        "            // Test operations",
        "            cache.put(\"key1\".to_string(), vec![1, 2, 3], 3).await.unwrap();",
        "            ",
        "            let value = cache.get(&\"key1\".to_string()).await;"
      ]
    },
    {
      "file": "src/mcp_manager/circuit_breaker.rs",
      "line": 384,
      "code": "assert_eq!(result.unwrap(), 42);",
      "context": [
        "        }).await;",
        "        assert!(result.is_ok());",
        "        assert_eq!(result.unwrap(), 42);",
        "        ",
        "        // Failed executions to open circuit"
      ]
    },
    {
      "file": "src/mcp_manager/manager_v2.rs",
      "line": 257,
      "code": "manager.shutdown().await.unwrap();",
      "context": [
        "        ",
        "        // Shutdown",
        "        manager.shutdown().await.unwrap();",
        "    }",
        "    "
      ]
    },
    {
      "file": "src/mcp_manager/manager_v2.rs",
      "line": 280,
      "code": "let server_id = manager.deploy_server(manager.config.servers[0].clone()).await.unwrap();",
      "context": [
        "        ",
        "        // Deploy server",
        "        let server_id = manager.deploy_server(manager.config.servers[0].clone()).await.unwrap();",
        "        ",
        "        // Execute tool (this would fail in tests without actual server)"
      ]
    },
    {
      "file": "src/mcp_manager/manager_v2.rs",
      "line": 290,
      "code": "manager.shutdown().await.unwrap();",
      "context": [
        "        ",
        "        // Shutdown",
        "        manager.shutdown().await.unwrap();",
        "    }",
        "}"
      ]
    },
    {
      "file": "src/mcp_manager/python_bindings.rs",
      "line": 128,
      "code": "Ok(serde_json::to_string(&response).unwrap())",
      "context": [
        "                    .map_err(|e| PyRuntimeError::new_err(format!(\"Execution failed: {}\", e)))?;",
        "                ",
        "                Ok(serde_json::to_string(&response).unwrap())",
        "            } else {",
        "                Err(PyValueError::new_err(format!(\"Server {} not found\", server_id)))"
      ]
    },
    {
      "file": "src/mcp_manager/python_bindings.rs",
      "line": 196,
      "code": "Ok(serde_json::to_string(&response).unwrap())",
      "context": [
        "                    .map_err(|e| PyRuntimeError::new_err(format!(\"Execution failed: {}\", e)))?;",
        "                ",
        "                Ok(serde_json::to_string(&response).unwrap())",
        "            } else {",
        "                Err(PyValueError::new_err(format!(\"Server {} not found\", server_id)))"
      ]
    },
    {
      "file": "src/mcp_manager/actor_tests.rs",
      "line": 41,
      "code": "let server_id = runtime.deploy(server_config).await.unwrap();",
      "context": [
        "        // Deploy a server",
        "        let server_config = create_test_server_config(\"test1\");",
        "        let server_id = runtime.deploy(server_config).await.unwrap();",
        "        assert_eq!(server_id, \"test1\");",
        "        "
      ]
    },
    {
      "file": "src/mcp_manager/actor_tests.rs",
      "line": 45,
      "code": "let servers = runtime.list_servers().await.unwrap();",
      "context": [
        "        ",
        "        // List servers",
        "        let servers = runtime.list_servers().await.unwrap();",
        "        assert_eq!(servers.len(), 1);",
        "        assert!(servers.contains(&\"test1\".to_string()));"
      ]
    },
    {
      "file": "src/mcp_manager/actor_tests.rs",
      "line": 50,
      "code": "let metrics = runtime.get_metrics(None).await.unwrap();",
      "context": [
        "        ",
        "        // Check metrics",
        "        let metrics = runtime.get_metrics(None).await.unwrap();",
        "        assert_eq!(metrics.active_servers, 1);",
        "        assert!(metrics.total_commands > 0);"
      ]
    },
    {
      "file": "src/mcp_manager/actor_tests.rs",
      "line": 56,
      "code": "runtime.undeploy(&server_id).await.unwrap();",
      "context": [
        "        ",
        "        // Undeploy",
        "        runtime.undeploy(&server_id).await.unwrap();",
        "        ",
        "        // Verify server is gone"
      ]
    },
    {
      "file": "src/mcp_manager/actor_tests.rs",
      "line": 59,
      "code": "let servers = runtime.list_servers().await.unwrap();",
      "context": [
        "        ",
        "        // Verify server is gone",
        "        let servers = runtime.list_servers().await.unwrap();",
        "        assert!(servers.is_empty());",
        "        "
      ]
    },
    {
      "file": "src/mcp_manager/actor_tests.rs",
      "line": 63,
      "code": "runtime.shutdown().await.unwrap();",
      "context": [
        "        ",
        "        // Shutdown",
        "        runtime.shutdown().await.unwrap();",
        "    }",
        "    "
      ]
    },
    {
      "file": "src/mcp_manager/actor_tests.rs",
      "line": 87,
      "code": "let server_id = result.as_ref().unwrap().as_ref().unwrap();",
      "context": [
        "        // Verify all succeeded",
        "        for (i, result) in results.iter().enumerate() {",
        "            let server_id = result.as_ref().unwrap().as_ref().unwrap();",
        "            assert_eq!(server_id, &format!(\"server{}\", i));",
        "        }"
      ]
    },
    {
      "file": "src/mcp_manager/actor_tests.rs",
      "line": 92,
      "code": "let servers = runtime.list_servers().await.unwrap();",
      "context": [
        "        ",
        "        // Check server count",
        "        let servers = runtime.list_servers().await.unwrap();",
        "        assert_eq!(servers.len(), 10);",
        "        "
      ]
    },
    {
      "file": "src/mcp_manager/actor_tests.rs",
      "line": 96,
      "code": "let metrics = runtime.get_metrics(None).await.unwrap();",
      "context": [
        "        ",
        "        // Check metrics",
        "        let metrics = runtime.get_metrics(None).await.unwrap();",
        "        assert_eq!(metrics.active_servers, 10);",
        "        "
      ]
    },
    {
      "file": "src/mcp_manager/actor_tests.rs",
      "line": 99,
      "code": "runtime.shutdown().await.unwrap();",
      "context": [
        "        assert_eq!(metrics.active_servers, 10);",
        "        ",
        "        runtime.shutdown().await.unwrap();",
        "    }",
        "    "
      ]
    },
    {
      "file": "src/mcp_manager/actor_tests.rs",
      "line": 109,
      "code": "runtime.deploy(server_config.clone()).await.unwrap();",
      "context": [
        "        // Deploy a server",
        "        let server_config = create_test_server_config(\"duplicate\");",
        "        runtime.deploy(server_config.clone()).await.unwrap();",
        "        ",
        "        // Try to deploy again with same name"
      ]
    },
    {
      "file": "src/mcp_manager/actor_tests.rs",
      "line": 122,
      "code": "runtime.shutdown().await.unwrap();",
      "context": [
        "        }",
        "        ",
        "        runtime.shutdown().await.unwrap();",
        "    }",
        "    "
      ]
    },
    {
      "file": "src/mcp_manager/actor_tests.rs",
      "line": 141,
      "code": "runtime.shutdown().await.unwrap();",
      "context": [
        "        }",
        "        ",
        "        runtime.shutdown().await.unwrap();",
        "    }",
        "    "
      ]
    },
    {
      "file": "src/mcp_manager/actor_tests.rs",
      "line": 163,
      "code": "assert!(result.unwrap().is_ok());",
      "context": [
        "        for result in results {",
        "            assert!(result.is_ok());",
        "            assert!(result.unwrap().is_ok());",
        "        }",
        "        "
      ]
    },
    {
      "file": "src/mcp_manager/actor_tests.rs",
      "line": 166,
      "code": "runtime.shutdown().await.unwrap();",
      "context": [
        "        }",
        "        ",
        "        runtime.shutdown().await.unwrap();",
        "    }",
        "    "
      ]
    },
    {
      "file": "src/mcp_manager/actor_tests.rs",
      "line": 180,
      "code": "manager.initialize().await.unwrap();",
      "context": [
        "        ",
        "        // Initialize should deploy configured servers",
        "        manager.initialize().await.unwrap();",
        "        ",
        "        // Verify servers were deployed"
      ]
    },
    {
      "file": "src/mcp_manager/actor_tests.rs",
      "line": 183,
      "code": "let servers = manager.list_servers().await.unwrap();",
      "context": [
        "        ",
        "        // Verify servers were deployed",
        "        let servers = manager.list_servers().await.unwrap();",
        "        assert_eq!(servers.len(), 2);",
        "        assert!(servers.contains(&\"config1\".to_string()));"
      ]
    },
    {
      "file": "src/mcp_manager/actor_tests.rs",
      "line": 190,
      "code": "manager.deploy_server(new_server).await.unwrap();",
      "context": [
        "        // Deploy additional server",
        "        let new_server = create_test_server_config(\"dynamic\");",
        "        manager.deploy_server(new_server).await.unwrap();",
        "        ",
        "        // Verify total count"
      ]
    },
    {
      "file": "src/mcp_manager/actor_tests.rs",
      "line": 193,
      "code": "let servers = manager.list_servers().await.unwrap();",
      "context": [
        "        ",
        "        // Verify total count",
        "        let servers = manager.list_servers().await.unwrap();",
        "        assert_eq!(servers.len(), 3);",
        "        "
      ]
    },
    {
      "file": "src/mcp_manager/actor_tests.rs",
      "line": 202,
      "code": "let metrics = manager.get_metrics(None).await.unwrap();",
      "context": [
        "        ",
        "        // Get metrics",
        "        let metrics = manager.get_metrics(None).await.unwrap();",
        "        assert_eq!(metrics.active_servers, 3);",
        "        "
      ]
    },
    {
      "file": "src/mcp_manager/actor_tests.rs",
      "line": 206,
      "code": "manager.shutdown().await.unwrap();",
      "context": [
        "        ",
        "        // Shutdown",
        "        manager.shutdown().await.unwrap();",
        "    }",
        "    "
      ]
    },
    {
      "file": "src/mcp_manager/actor_tests.rs",
      "line": 217,
      "code": "runtime.deploy(config).await.unwrap();",
      "context": [
        "        for i in 0..5 {",
        "            let config = create_test_server_config(&format!(\"shutdown{}\", i));",
        "            runtime.deploy(config).await.unwrap();",
        "        }",
        "        "
      ]
    },
    {
      "file": "src/mcp_manager/actor_tests.rs",
      "line": 229,
      "code": "runtime.shutdown().await.unwrap();",
      "context": [
        "        ",
        "        // Shutdown should wait for operations to complete",
        "        runtime.shutdown().await.unwrap();",
        "        ",
        "        // The long operation should have been cancelled"
      ]
    },
    {
      "file": "src/mcp_manager/actor_tests.rs",
      "line": 242,
      "code": "runtime.deploy(server1).await.unwrap();",
      "context": [
        "        // Perform various operations",
        "        let server1 = create_test_server_config(\"metrics1\");",
        "        runtime.deploy(server1).await.unwrap();",
        "        ",
        "        let server2 = create_test_server_config(\"metrics2\");"
      ]
    },
    {
      "file": "src/mcp_manager/actor_tests.rs",
      "line": 245,
      "code": "runtime.deploy(server2).await.unwrap();",
      "context": [
        "        ",
        "        let server2 = create_test_server_config(\"metrics2\");",
        "        runtime.deploy(server2).await.unwrap();",
        "        ",
        "        // Some successful operations"
      ]
    },
    {
      "file": "src/mcp_manager/actor_tests.rs",
      "line": 248,
      "code": "runtime.list_servers().await.unwrap();",
      "context": [
        "        ",
        "        // Some successful operations",
        "        runtime.list_servers().await.unwrap();",
        "        runtime.health_check(\"metrics1\").await.unwrap();",
        "        "
      ]
    },
    {
      "file": "src/mcp_manager/actor_tests.rs",
      "line": 249,
      "code": "runtime.health_check(\"metrics1\").await.unwrap();",
      "context": [
        "        // Some successful operations",
        "        runtime.list_servers().await.unwrap();",
        "        runtime.health_check(\"metrics1\").await.unwrap();",
        "        ",
        "        // Some failed operations"
      ]
    },
    {
      "file": "src/mcp_manager/actor_tests.rs",
      "line": 256,
      "code": "let metrics = runtime.get_metrics(None).await.unwrap();",
      "context": [
        "        ",
        "        // Check metrics",
        "        let metrics = runtime.get_metrics(None).await.unwrap();",
        "        assert_eq!(metrics.active_servers, 2);",
        "        assert!(metrics.total_commands >= 6); // At least our operations"
      ]
    },
    {
      "file": "src/mcp_manager/actor_tests.rs",
      "line": 263,
      "code": "runtime.shutdown().await.unwrap();",
      "context": [
        "        assert!(metrics.avg_latency_us > 0);",
        "        ",
        "        runtime.shutdown().await.unwrap();",
        "    }",
        "    "
      ]
    },
    {
      "file": "src/mcp_manager/actor_tests.rs",
      "line": 286,
      "code": "runtime.shutdown().await.unwrap();",
      "context": [
        "        }",
        "        ",
        "        runtime.shutdown().await.unwrap();",
        "    }",
        "}"
      ]
    },
    {
      "file": "src/mcp_manager/metrics.rs",
      "line": 19,
      "code": ").unwrap();",
      "context": [
        "        Opts::new(\"mcp_requests_total\", \"Total number of requests\"),",
        "        &[\"server_id\", \"method\", \"status\"]",
        "    ).unwrap();",
        "    ",
        "    /// Response time histogram"
      ]
    },
    {
      "file": "src/mcp_manager/metrics.rs",
      "line": 25,
      "code": ").unwrap();",
      "context": [
        "        HistogramOpts::new(\"mcp_response_time_seconds\", \"Response time in seconds\"),",
        "        &[\"server_id\", \"method\"]",
        "    ).unwrap();",
        "    ",
        "    /// Active connections gauge"
      ]
    },
    {
      "file": "src/mcp_manager/metrics.rs",
      "line": 31,
      "code": ").unwrap();",
      "context": [
        "        Opts::new(\"mcp_active_connections\", \"Number of active connections\"),",
        "        &[\"server_id\"]",
        "    ).unwrap();",
        "    ",
        "    /// Health check results"
      ]
    },
    {
      "file": "src/mcp_manager/metrics.rs",
      "line": 37,
      "code": ").unwrap();",
      "context": [
        "        Opts::new(\"mcp_health_checks_total\", \"Total health check results\"),",
        "        &[\"server_id\", \"result\"]",
        "    ).unwrap();",
        "    ",
        "    /// Circuit breaker state"
      ]
    },
    {
      "file": "src/mcp_manager/metrics.rs",
      "line": 43,
      "code": ").unwrap();",
      "context": [
        "        Opts::new(\"mcp_circuit_breaker_state\", \"Circuit breaker state (0=closed, 1=open, 2=half-open)\"),",
        "        &[\"server_id\"]",
        "    ).unwrap();",
        "    ",
        "    /// Connection pool metrics"
      ]
    },
    {
      "file": "src/mcp_manager/metrics.rs",
      "line": 49,
      "code": ").unwrap();",
      "context": [
        "        Opts::new(\"mcp_connection_pool_size\", \"Connection pool size\"),",
        "        &[\"server_id\", \"state\"]",
        "    ).unwrap();",
        "    ",
        "    /// Server availability"
      ]
    },
    {
      "file": "src/mcp_manager/metrics.rs",
      "line": 55,
      "code": ").unwrap();",
      "context": [
        "        Opts::new(\"mcp_server_availability\", \"Server availability percentage\"),",
        "        &[\"server_id\"]",
        "    ).unwrap();",
        "    ",
        "    /// Error rate"
      ]
    },
    {
      "file": "src/mcp_manager/metrics.rs",
      "line": 61,
      "code": ").unwrap();",
      "context": [
        "        Opts::new(\"mcp_error_rate\", \"Error rate per minute\"),",
        "        &[\"server_id\"]",
        "    ).unwrap();",
        "}",
        ""
      ]
    },
    {
      "file": "src/mcp_manager/metrics.rs",
      "line": 80,
      "code": "registry.register(Box::new(REQUEST_COUNTER.clone())).unwrap();",
      "context": [
        "        ",
        "        // Register metrics",
        "        registry.register(Box::new(REQUEST_COUNTER.clone())).unwrap();",
        "        registry.register(Box::new(RESPONSE_TIME.clone())).unwrap();",
        "        registry.register(Box::new(ACTIVE_CONNECTIONS.clone())).unwrap();"
      ]
    },
    {
      "file": "src/mcp_manager/metrics.rs",
      "line": 81,
      "code": "registry.register(Box::new(RESPONSE_TIME.clone())).unwrap();",
      "context": [
        "        // Register metrics",
        "        registry.register(Box::new(REQUEST_COUNTER.clone())).unwrap();",
        "        registry.register(Box::new(RESPONSE_TIME.clone())).unwrap();",
        "        registry.register(Box::new(ACTIVE_CONNECTIONS.clone())).unwrap();",
        "        registry.register(Box::new(HEALTH_CHECK_RESULTS.clone())).unwrap();"
      ]
    },
    {
      "file": "src/mcp_manager/metrics.rs",
      "line": 82,
      "code": "registry.register(Box::new(ACTIVE_CONNECTIONS.clone())).unwrap();",
      "context": [
        "        registry.register(Box::new(REQUEST_COUNTER.clone())).unwrap();",
        "        registry.register(Box::new(RESPONSE_TIME.clone())).unwrap();",
        "        registry.register(Box::new(ACTIVE_CONNECTIONS.clone())).unwrap();",
        "        registry.register(Box::new(HEALTH_CHECK_RESULTS.clone())).unwrap();",
        "        registry.register(Box::new(CIRCUIT_BREAKER_STATE.clone())).unwrap();"
      ]
    },
    {
      "file": "src/mcp_manager/metrics.rs",
      "line": 83,
      "code": "registry.register(Box::new(HEALTH_CHECK_RESULTS.clone())).unwrap();",
      "context": [
        "        registry.register(Box::new(RESPONSE_TIME.clone())).unwrap();",
        "        registry.register(Box::new(ACTIVE_CONNECTIONS.clone())).unwrap();",
        "        registry.register(Box::new(HEALTH_CHECK_RESULTS.clone())).unwrap();",
        "        registry.register(Box::new(CIRCUIT_BREAKER_STATE.clone())).unwrap();",
        "        registry.register(Box::new(CONNECTION_POOL_SIZE.clone())).unwrap();"
      ]
    },
    {
      "file": "src/mcp_manager/metrics.rs",
      "line": 84,
      "code": "registry.register(Box::new(CIRCUIT_BREAKER_STATE.clone())).unwrap();",
      "context": [
        "        registry.register(Box::new(ACTIVE_CONNECTIONS.clone())).unwrap();",
        "        registry.register(Box::new(HEALTH_CHECK_RESULTS.clone())).unwrap();",
        "        registry.register(Box::new(CIRCUIT_BREAKER_STATE.clone())).unwrap();",
        "        registry.register(Box::new(CONNECTION_POOL_SIZE.clone())).unwrap();",
        "        registry.register(Box::new(SERVER_AVAILABILITY.clone())).unwrap();"
      ]
    },
    {
      "file": "src/mcp_manager/metrics.rs",
      "line": 85,
      "code": "registry.register(Box::new(CONNECTION_POOL_SIZE.clone())).unwrap();",
      "context": [
        "        registry.register(Box::new(HEALTH_CHECK_RESULTS.clone())).unwrap();",
        "        registry.register(Box::new(CIRCUIT_BREAKER_STATE.clone())).unwrap();",
        "        registry.register(Box::new(CONNECTION_POOL_SIZE.clone())).unwrap();",
        "        registry.register(Box::new(SERVER_AVAILABILITY.clone())).unwrap();",
        "        registry.register(Box::new(ERROR_RATE.clone())).unwrap();"
      ]
    },
    {
      "file": "src/mcp_manager/metrics.rs",
      "line": 86,
      "code": "registry.register(Box::new(SERVER_AVAILABILITY.clone())).unwrap();",
      "context": [
        "        registry.register(Box::new(CIRCUIT_BREAKER_STATE.clone())).unwrap();",
        "        registry.register(Box::new(CONNECTION_POOL_SIZE.clone())).unwrap();",
        "        registry.register(Box::new(SERVER_AVAILABILITY.clone())).unwrap();",
        "        registry.register(Box::new(ERROR_RATE.clone())).unwrap();",
        "        "
      ]
    },
    {
      "file": "src/mcp_manager/metrics.rs",
      "line": 87,
      "code": "registry.register(Box::new(ERROR_RATE.clone())).unwrap();",
      "context": [
        "        registry.register(Box::new(CONNECTION_POOL_SIZE.clone())).unwrap();",
        "        registry.register(Box::new(SERVER_AVAILABILITY.clone())).unwrap();",
        "        registry.register(Box::new(ERROR_RATE.clone())).unwrap();",
        "        ",
        "        Self {"
      ]
    },
    {
      "file": "src/mcp_manager/metrics.rs",
      "line": 190,
      "code": "encoder.encode(&metric_families, &mut buffer).unwrap();",
      "context": [
        "        let metric_families = self.registry.gather();",
        "        let mut buffer = Vec::new();",
        "        encoder.encode(&metric_families, &mut buffer).unwrap();",
        "        String::from_utf8(buffer).unwrap()",
        "    }"
      ]
    },
    {
      "file": "src/mcp_manager/metrics.rs",
      "line": 191,
      "code": "String::from_utf8(buffer).unwrap()",
      "context": [
        "        let mut buffer = Vec::new();",
        "        encoder.encode(&metric_families, &mut buffer).unwrap();",
        "        String::from_utf8(buffer).unwrap()",
        "    }",
        ""
      ]
    },
    {
      "file": "src/mcp_manager/metrics.rs",
      "line": 295,
      "code": "encoder.encode(&all_metrics, &mut buffer).unwrap();",
      "context": [
        "        let encoder = prometheus::TextEncoder::new();",
        "        let mut buffer = Vec::new();",
        "        encoder.encode(&all_metrics, &mut buffer).unwrap();",
        "        String::from_utf8(buffer).unwrap()",
        "    }"
      ]
    },
    {
      "file": "src/mcp_manager/metrics.rs",
      "line": 296,
      "code": "String::from_utf8(buffer).unwrap()",
      "context": [
        "        let mut buffer = Vec::new();",
        "        encoder.encode(&all_metrics, &mut buffer).unwrap();",
        "        String::from_utf8(buffer).unwrap()",
        "    }",
        "}"
      ]
    },
    {
      "file": "src/mcp_manager/protocol.rs",
      "line": 109,
      "code": ".unwrap();",
      "context": [
        "            .timeout(Duration::from_secs(30))",
        "            .build()",
        "            .unwrap();",
        "            ",
        "        Self {"
      ]
    },
    {
      "file": "src/reliability/circuit_breaker.rs",
      "line": 388,
      "code": "assert_eq!(result.unwrap(), 42);",
      "context": [
        "        }).await;",
        "        ",
        "        assert_eq!(result.unwrap(), 42);",
        "        assert_eq!(breaker.stats().total_requests, 1);",
        "        assert_eq!(breaker.stats().failed_requests, 0);"
      ]
    },
    {
      "file": "src/reliability/retry_policy.rs",
      "line": 334,
      "code": "assert_eq!(result.unwrap(), 42);",
      "context": [
        "        }).await;",
        "        ",
        "        assert_eq!(result.unwrap(), 42);",
        "        assert_eq!(attempts, 3);",
        "    }"
      ]
    },
    {
      "file": "src/reliability/recovery.rs",
      "line": 434,
      "code": ").await.unwrap();",
      "context": [
        "            \"test-service\".to_string(),",
        "            None",
        "        ).await.unwrap();",
        "        ",
        "        manager.cancel_recovery(service_id).await.unwrap();"
      ]
    },
    {
      "file": "src/reliability/recovery.rs",
      "line": 436,
      "code": "manager.cancel_recovery(service_id).await.unwrap();",
      "context": [
        "        ).await.unwrap();",
        "        ",
        "        manager.cancel_recovery(service_id).await.unwrap();",
        "        ",
        "        let status = manager.get_recovery_status(service_id).await;"
      ]
    },
    {
      "file": "src/reliability/recovery.rs",
      "line": 452,
      "code": ").await.unwrap();",
      "context": [
        "                format!(\"service-{}\", i),",
        "                Some(RecoveryStrategy::RestartWithBackoff)",
        "            ).await.unwrap();",
        "        }",
        "        "
      ]
    },
    {
      "file": "src/memory/hybrid.rs",
      "line": 408,
      "code": ").await.unwrap();",
      "context": [
        "            HashSet::from([\"docker.sock\".to_string()]),",
        "            vec![],",
        "        ).await.unwrap();",
        "        ",
        "        memory.store("
      ]
    },
    {
      "file": "src/memory/hybrid.rs",
      "line": 414,
      "code": ").await.unwrap();",
      "context": [
        "            HashSet::new(),",
        "            vec![(\"build\".to_string(), DependencyType::Sequential, 1.0)],",
        "        ).await.unwrap();",
        "        ",
        "        memory.store("
      ]
    },
    {
      "file": "src/memory/hybrid.rs",
      "line": 420,
      "code": ").await.unwrap();",
      "context": [
        "            HashSet::from([\"kubeconfig\".to_string()]),",
        "            vec![(\"test\".to_string(), DependencyType::Sequential, 1.0)],",
        "        ).await.unwrap();",
        "        ",
        "        // Query for similar patterns and dependencies"
      ]
    },
    {
      "file": "src/memory/hybrid.rs",
      "line": 432,
      "code": "let result = memory.query(query).await.unwrap();",
      "context": [
        "        };",
        "        ",
        "        let result = memory.query(query).await.unwrap();",
        "        ",
        "        // Check results"
      ]
    },
    {
      "file": "src/memory/hybrid.rs",
      "line": 453,
      "code": ").await.unwrap();",
      "context": [
        "            HashSet::from([\"port:8080\".to_string()]),",
        "            vec![],",
        "        ).await.unwrap();",
        "        ",
        "        memory.store("
      ]
    },
    {
      "file": "src/memory/hybrid.rs",
      "line": 459,
      "code": ").await.unwrap();",
      "context": [
        "            HashSet::from([\"port:8080\".to_string()]),",
        "            vec![],",
        "        ).await.unwrap();",
        "        ",
        "        // Query for conflicts"
      ]
    },
    {
      "file": "src/memory/hybrid.rs",
      "line": 471,
      "code": "let result = memory.query(query).await.unwrap();",
      "context": [
        "        };",
        "        ",
        "        let result = memory.query(query).await.unwrap();",
        "        assert_eq!(result.conflicts.len(), 1);",
        "        assert_eq!(result.conflicts[0].2, vec![\"port:8080\"]);"
      ]
    },
    {
      "file": "src/memory/optimization.rs",
      "line": 380,
      "code": "assert_eq!(heap.pop().unwrap().entry_id, \"low\");",
      "context": [
        "        ",
        "        // Should pop in order: low (1.0), medium (5.0), high (10.0)",
        "        assert_eq!(heap.pop().unwrap().entry_id, \"low\");",
        "        assert_eq!(heap.pop().unwrap().entry_id, \"medium\");",
        "        assert_eq!(heap.pop().unwrap().entry_id, \"high\");"
      ]
    },
    {
      "file": "src/memory/optimization.rs",
      "line": 381,
      "code": "assert_eq!(heap.pop().unwrap().entry_id, \"medium\");",
      "context": [
        "        // Should pop in order: low (1.0), medium (5.0), high (10.0)",
        "        assert_eq!(heap.pop().unwrap().entry_id, \"low\");",
        "        assert_eq!(heap.pop().unwrap().entry_id, \"medium\");",
        "        assert_eq!(heap.pop().unwrap().entry_id, \"high\");",
        "    }"
      ]
    },
    {
      "file": "src/memory/optimization.rs",
      "line": 382,
      "code": "assert_eq!(heap.pop().unwrap().entry_id, \"high\");",
      "context": [
        "        assert_eq!(heap.pop().unwrap().entry_id, \"low\");",
        "        assert_eq!(heap.pop().unwrap().entry_id, \"medium\");",
        "        assert_eq!(heap.pop().unwrap().entry_id, \"high\");",
        "    }",
        "    "
      ]
    },
    {
      "file": "src/memory/tensor.rs",
      "line": 66,
      "code": "let cache_size = NonZeroUsize::new(cache_size).unwrap_or(NonZeroUsize::new(1000).unwrap());",
      "context": [
        "    /// Create a new tensor memory instance",
        "    pub fn new(cache_size: usize) -> Self {",
        "        let cache_size = NonZeroUsize::new(cache_size).unwrap_or(NonZeroUsize::new(1000).unwrap());",
        "        ",
        "        Self {"
      ]
    },
    {
      "file": "src/memory/tensor.rs",
      "line": 239,
      "code": "results.sort_by(|a, b| b.similarity_score.partial_cmp(&a.similarity_score).unwrap());",
      "context": [
        "        ",
        "        // Sort by similarity score (descending)",
        "        results.sort_by(|a, b| b.similarity_score.partial_cmp(&a.similarity_score).unwrap());",
        "        ",
        "        // Limit results"
      ]
    },
    {
      "file": "src/testing/performance.rs",
      "line": 794,
      "code": "let metrics = tester.run_benchmark(operation.clone()).await.unwrap();",
      "context": [
        "        ));",
        "",
        "        let metrics = tester.run_benchmark(operation.clone()).await.unwrap();",
        "",
        "        assert_eq!(metrics.successful_operations, 10);"
      ]
    },
    {
      "file": "src/testing/performance.rs",
      "line": 848,
      "code": "let metrics = tester.run_stress_test(operation).await.unwrap();",
      "context": [
        "        ));",
        "",
        "        let metrics = tester.run_stress_test(operation).await.unwrap();",
        "        assert!(metrics.successful_operations > 0);",
        "    }"
      ]
    },
    {
      "file": "src/testing/ffi.rs",
      "line": 108,
      "code": "input_data: serde_json::Number::from_f64(3.14159).map(Value::Number).unwrap(),",
      "context": [
        "        self.add_test_case(FFITestCase {",
        "            name: \"float_positive\".to_string(),",
        "            input_data: serde_json::Number::from_f64(3.14159).map(Value::Number).unwrap(),",
        "            expected_output: serde_json::Number::from_f64(3.14159).map(Value::Number).unwrap(),",
        "            data_type: DataType::Float,"
      ]
    },
    {
      "file": "src/testing/ffi.rs",
      "line": 109,
      "code": "expected_output: serde_json::Number::from_f64(3.14159).map(Value::Number).unwrap(),",
      "context": [
        "            name: \"float_positive\".to_string(),",
        "            input_data: serde_json::Number::from_f64(3.14159).map(Value::Number).unwrap(),",
        "            expected_output: serde_json::Number::from_f64(3.14159).map(Value::Number).unwrap(),",
        "            data_type: DataType::Float,",
        "            should_error: false,"
      ]
    },
    {
      "file": "src/testing/ffi.rs",
      "line": 346,
      "code": "(\"invalid_large_number\", serde_json::Number::from_f64(f64::MAX).map(Value::Number).unwrap()),",
      "context": [
        "        let error_test_cases = vec![",
        "            (\"null_input\", Value::Null),",
        "            (\"invalid_large_number\", serde_json::Number::from_f64(f64::MAX).map(Value::Number).unwrap()),",
        "            (\"very_large_string\", Value::String(\"x\".repeat(1_000_000))),",
        "            (\"deeply_nested_object\", self.create_deeply_nested_object(100)),"
      ]
    },
    {
      "file": "src/testing/ffi.rs",
      "line": 720,
      "code": "assert_eq!(result.unwrap(), input);",
      "context": [
        "        ",
        "        assert!(result.is_ok());",
        "        assert_eq!(result.unwrap(), input);",
        "    }",
        "}"
      ]
    },
    {
      "file": "src/testing/mod.rs",
      "line": 198,
      "code": ".max_by(|a, b| a.memory_mb.partial_cmp(&b.memory_mb).unwrap())",
      "context": [
        "    pub fn get_peak_usage(&self) -> Option<ResourceUsage> {",
        "        self.usage_history.iter()",
        "            .max_by(|a, b| a.memory_mb.partial_cmp(&b.memory_mb).unwrap())",
        "            .cloned()",
        "    }"
      ]
    },
    {
      "file": "src/testing/mod.rs",
      "line": 565,
      "code": "let avg_usage = monitor.get_average_usage().unwrap();",
      "context": [
        "        monitor.record_usage(usage.clone());",
        "        ",
        "        let avg_usage = monitor.get_average_usage().unwrap();",
        "        assert_eq!(avg_usage.memory_mb, 100.0);",
        "        assert_eq!(avg_usage.cpu_percent, 50.0);"
      ]
    },
    {
      "file": "src/network/load_balancer.rs",
      "line": 453,
      "code": "let selected2 = lb.select_backend(None).unwrap();",
      "context": [
        "        ",
        "        // Next selection should go to the other backend",
        "        let selected2 = lb.select_backend(None).unwrap();",
        "        assert_ne!(selected1.id, selected2.id);",
        "        "
      ]
    },
    {
      "file": "src/network/load_balancer.rs",
      "line": 460,
      "code": "let selected3 = lb.select_backend(None).unwrap();",
      "context": [
        "        ",
        "        // Next selection should go to the first backend again",
        "        let selected3 = lb.select_backend(None).unwrap();",
        "        assert_eq!(selected3.id, selected1.id);",
        "    }"
      ]
    },
    {
      "file": "src/network/port_allocator.rs",
      "line": 323,
      "code": "allocator.release_port(&service_id).await.unwrap();",
      "context": [
        "        ",
        "        // Release port",
        "        allocator.release_port(&service_id).await.unwrap();",
        "        assert!(allocator.is_port_available(allocation.port).await);",
        "    }"
      ]
    },
    {
      "file": "src/network/port_allocator.rs",
      "line": 343,
      "code": "allocator.allocate_port(&service_id, Protocol::Tcp).await.unwrap();",
      "context": [
        "            let service_id = Uuid::new_v4();",
        "            service_ids.push(service_id);",
        "            allocator.allocate_port(&service_id, Protocol::Tcp).await.unwrap();",
        "        }",
        "        "
      ]
    },
    {
      "file": "src/network/port_allocator.rs",
      "line": 352,
      "code": "allocator.release_port(&service_ids[0]).await.unwrap();",
      "context": [
        "        ",
        "        // Release one port and try again",
        "        allocator.release_port(&service_ids[0]).await.unwrap();",
        "        let result = allocator.allocate_port(&service_id, Protocol::Tcp).await;",
        "        assert!(result.is_ok());"
      ]
    },
    {
      "file": "src/network/port_allocator.rs",
      "line": 368,
      "code": ").await.unwrap();",
      "context": [
        "            port, ",
        "            Protocol::Http",
        "        ).await.unwrap();",
        "        ",
        "        assert_eq!(allocation.port, port);"
      ]
    },
    {
      "file": "src/network/service_mesh.rs",
      "line": 397,
      "code": "let endpoints = mesh.discover_service(\"test-service\").await.unwrap();",
      "context": [
        "        ",
        "        // Discover service",
        "        let endpoints = mesh.discover_service(\"test-service\").await.unwrap();",
        "        assert_eq!(endpoints.len(), 1);",
        "    }"
      ]
    },
    {
      "file": "src/network/service_mesh.rs",
      "line": 406,
      "code": "mesh.register_service(&service_id, \"policy-test\".to_string()).await.unwrap();",
      "context": [
        "        ",
        "        let service_id = Uuid::new_v4();",
        "        mesh.register_service(&service_id, \"policy-test\".to_string()).await.unwrap();",
        "        ",
        "        // Get default policy"
      ]
    },
    {
      "file": "src/network/service_mesh.rs",
      "line": 409,
      "code": "let policy = mesh.get_traffic_policy(\"policy-test\").await.unwrap();",
      "context": [
        "        ",
        "        // Get default policy",
        "        let policy = mesh.get_traffic_policy(\"policy-test\").await.unwrap();",
        "        assert_eq!(policy.load_balancing, LoadBalancingPolicy::RoundRobin);",
        "        "
      ]
    },
    {
      "file": "src/network/service_mesh.rs",
      "line": 416,
      "code": "mesh.update_traffic_policy(\"policy-test\", new_policy).await.unwrap();",
      "context": [
        "        new_policy.load_balancing = LoadBalancingPolicy::LeastRequest;",
        "        ",
        "        mesh.update_traffic_policy(\"policy-test\", new_policy).await.unwrap();",
        "        ",
        "        let updated = mesh.get_traffic_policy(\"policy-test\").await.unwrap();"
      ]
    },
    {
      "file": "src/network/service_mesh.rs",
      "line": 418,
      "code": "let updated = mesh.get_traffic_policy(\"policy-test\").await.unwrap();",
      "context": [
        "        mesh.update_traffic_policy(\"policy-test\", new_policy).await.unwrap();",
        "        ",
        "        let updated = mesh.get_traffic_policy(\"policy-test\").await.unwrap();",
        "        assert_eq!(updated.load_balancing, LoadBalancingPolicy::LeastRequest);",
        "    }"
      ]
    },
    {
      "file": "src/synthex_bash_god/learning_system.rs",
      "line": 575,
      "code": "let first = self.values.front().unwrap();",
      "context": [
        "        }",
        "",
        "        let first = self.values.front().unwrap();",
        "        let last = self.values.back().unwrap();",
        ""
      ]
    },
    {
      "file": "src/synthex_bash_god/learning_system.rs",
      "line": 576,
      "code": "let last = self.values.back().unwrap();",
      "context": [
        "",
        "        let first = self.values.front().unwrap();",
        "        let last = self.values.back().unwrap();",
        "",
        "        if *first == 0.0 {"
      ]
    },
    {
      "file": "src/synthex_bash_god/command_chain.rs",
      "line": 277,
      "code": "let first_char = self.input.chars().nth(self.position).unwrap();",
      "context": [
        "        }",
        "",
        "        let first_char = self.input.chars().nth(self.position).unwrap();",
        "        ",
        "        if first_char == '\\'' {"
      ]
    },
    {
      "file": "src/synthex_bash_god/command_chain.rs",
      "line": 475,
      "code": "let ch = self.input.chars().nth(self.position).unwrap();",
      "context": [
        "        ",
        "        while self.position < self.input.len() {",
        "            let ch = self.input.chars().nth(self.position).unwrap();",
        "            ",
        "            if \"|&;<>()\".contains(ch) || (ch == '2' && self.input[self.position..].starts_with(\"2>&1\")) {"
      ]
    },
    {
      "file": "src/synthex_bash_god/command_chain.rs",
      "line": 506,
      "code": "if !self.input.chars().nth(self.position).unwrap().is_whitespace() {",
      "context": [
        "    fn skip_whitespace(&mut self) {",
        "        while self.position < self.input.len() {",
        "            if !self.input.chars().nth(self.position).unwrap().is_whitespace() {",
        "                break;",
        "            }"
      ]
    },
    {
      "file": "src/synthex_bash_god/command_chain.rs",
      "line": 530,
      "code": "let ch = self.input.chars().nth(self.position).unwrap();",
      "context": [
        "        ",
        "        while self.position < self.input.len() {",
        "            let ch = self.input.chars().nth(self.position).unwrap();",
        "            ",
        "            if escaped {"
      ]
    },
    {
      "file": "src/synthex_bash_god/execution_engine.rs",
      "line": 397,
      "code": "let results = engine.execute_parallel(chains).await.unwrap();",
      "context": [
        "        }).collect();",
        "        ",
        "        let results = engine.execute_parallel(chains).await.unwrap();",
        "        assert_eq!(results.len(), 5);",
        "        "
      ]
    },
    {
      "file": "src/circle_of_experts/test_module.rs",
      "line": 47,
      "code": "let consensus = result.unwrap();",
      "context": [
        "        ",
        "        assert!(result.is_ok());",
        "        let consensus = result.unwrap();",
        "        assert!(!consensus.consensus_text.is_empty());",
        "        assert!(consensus.confidence_score > 0.0 && consensus.confidence_score <= 1.0);"
      ]
    },
    {
      "file": "src/circle_of_experts/test_module.rs",
      "line": 72,
      "code": "let matrix = consensus::compute_similarity_matrix(&responses, &config).unwrap();",
      "context": [
        "",
        "        let config = CircleConfig::default();",
        "        let matrix = consensus::compute_similarity_matrix(&responses, &config).unwrap();",
        "        ",
        "        assert_eq!(matrix.len(), 2);"
      ]
    },
    {
      "file": "src/circle_of_experts/analyzer.rs",
      "line": 233,
      "code": "let min_time = *timestamps.iter().min().unwrap();",
      "context": [
        "    ",
        "    let timestamps: Vec<u64> = responses.iter().map(|r| r.timestamp).collect();",
        "    let min_time = *timestamps.iter().min().unwrap();",
        "    let max_time = *timestamps.iter().max().unwrap();",
        "    "
      ]
    },
    {
      "file": "src/circle_of_experts/analyzer.rs",
      "line": 234,
      "code": "let max_time = *timestamps.iter().max().unwrap();",
      "context": [
        "    let timestamps: Vec<u64> = responses.iter().map(|r| r.timestamp).collect();",
        "    let min_time = *timestamps.iter().min().unwrap();",
        "    let max_time = *timestamps.iter().max().unwrap();",
        "    ",
        "    // Consider temporal if spread is more than 1 minute"
      ]
    },
    {
      "file": "src/learning_engine/optimizer.rs",
      "line": 670,
      "code": "let (src, dst) = graph.edge_endpoints(e).unwrap();",
      "context": [
        "        let edges: Vec<(usize, usize)> = graph.edge_indices()",
        "            .map(|e| {",
        "                let (src, dst) = graph.edge_endpoints(e).unwrap();",
        "                (graph[src].id, graph[dst].id)",
        "            })"
      ]
    },
    {
      "file": "src/learning_engine/pattern_detector.rs",
      "line": 270,
      "code": "if best_match.is_none() || similarity > best_match.as_ref().unwrap().1 {",
      "context": [
        "            ",
        "            if similarity > self.config.similarity_threshold {",
        "                if best_match.is_none() || similarity > best_match.as_ref().unwrap().1 {",
        "                    best_match = Some((pattern_id.clone(), similarity));",
        "                }"
      ]
    },
    {
      "file": "src/learning_engine/pattern_detector.rs",
      "line": 631,
      "code": "detector.record_pattern(pattern).unwrap();",
      "context": [
        "        };",
        "        ",
        "        detector.record_pattern(pattern).unwrap();",
        "        ",
        "        let commands = vec![\"make build\".to_string(), \"make test\".to_string()];"
      ]
    },
    {
      "file": "src/learning_engine/pattern_detector.rs",
      "line": 634,
      "code": "let detected = detector.detect_patterns(&commands).unwrap();",
      "context": [
        "        ",
        "        let commands = vec![\"make build\".to_string(), \"make test\".to_string()];",
        "        let detected = detector.detect_patterns(&commands).unwrap();",
        "        ",
        "        assert!(!detected.is_empty());"
      ]
    },
    {
      "file": "src/learning_engine/predictor.rs",
      "line": 575,
      "code": "predictions.sort_by(|a, b| b.1.partial_cmp(&a.1).unwrap());",
      "context": [
        "        ",
        "        // Sort by probability",
        "        predictions.sort_by(|a, b| b.1.partial_cmp(&a.1).unwrap());",
        "        predictions.truncate(3); // Top 3 risks",
        "        "
      ]
    },
    {
      "file": "src/synthex_bashgod/execution.rs",
      "line": 441,
      "code": "working_directory: std::env::current_dir().unwrap(),",
      "context": [
        "            chain,",
        "            environment: HashMap::new(),",
        "            working_directory: std::env::current_dir().unwrap(),",
        "            constraints: crate::synthex_bashgod::core::ExecutionConstraints {",
        "                timeout: Duration::from_secs(30),"
      ]
    },
    {
      "file": "src/synthex_bashgod/execution.rs",
      "line": 458,
      "code": "let result = executor.execute(context, ExecutionConfig::default()).await.unwrap();",
      "context": [
        "        };",
        "        ",
        "        let result = executor.execute(context, ExecutionConfig::default()).await.unwrap();",
        "        assert!(result.success);",
        "        assert!(result.output.contains(\"hello\"));"
      ]
    },
    {
      "file": "src/synthex_bashgod/actor.rs",
      "line": 553,
      "code": "tx.send(ActorMessage::Shutdown).await.unwrap();",
      "context": [
        "        ",
        "        // Send shutdown message",
        "        tx.send(ActorMessage::Shutdown).await.unwrap();",
        "        ",
        "        // Run actor (should exit immediately)"
      ]
    },
    {
      "file": "src/synthex_bashgod/supervisor.rs",
      "line": 407,
      "code": "supervisor.start_actor(\"test-actor\", ActorConfig::default()).await.unwrap();",
      "context": [
        "        ",
        "        // Start another actor",
        "        supervisor.start_actor(\"test-actor\", ActorConfig::default()).await.unwrap();",
        "        ",
        "        // Check stats"
      ]
    },
    {
      "file": "src/synthex_bashgod/messages.rs",
      "line": 228,
      "code": ".unwrap()",
      "context": [
        "            timestamp: std::time::SystemTime::now()",
        "                .duration_since(std::time::UNIX_EPOCH)",
        "                .unwrap()",
        "                .as_secs(),",
        "            priority: MessagePriority::default(),"
      ]
    },
    {
      "file": "src/synthex_bashgod/tests.rs",
      "line": 139,
      "code": "let chain_result = result.unwrap();",
      "context": [
        "        assert!(result.is_ok());",
        "        ",
        "        let chain_result = result.unwrap();",
        "        assert!(chain_result.success);",
        "        assert_eq!(chain_result.command_results.len(), 1);"
      ]
    },
    {
      "file": "src/synthex_bashgod/tests.rs",
      "line": 146,
      "code": "let service = create_bashgod_service(BashGodConfig::default()).await.unwrap();",
      "context": [
        "    #[tokio::test]",
        "    async fn test_chain_optimization() {",
        "        let service = create_bashgod_service(BashGodConfig::default()).await.unwrap();",
        "        ",
        "        let chain = CommandChain {"
      ]
    },
    {
      "file": "src/synthex_bashgod/tests.rs",
      "line": 185,
      "code": "let service = create_bashgod_service(BashGodConfig::default()).await.unwrap();",
      "context": [
        "    #[tokio::test]",
        "    async fn test_learning_insights() {",
        "        let service = create_bashgod_service(BashGodConfig::default()).await.unwrap();",
        "        ",
        "        let insights = service.get_insights().await;"
      ]
    },
    {
      "file": "src/synthex_bashgod/tests.rs",
      "line": 191,
      "code": "assert_eq!(insights.unwrap().len(), 0);",
      "context": [
        "        ",
        "        // Initially should be empty",
        "        assert_eq!(insights.unwrap().len(), 0);",
        "    }",
        "}"
      ]
    },
    {
      "file": "src/synthex_bashgod/tests.rs",
      "line": 227,
      "code": "}).await.unwrap();",
      "context": [
        "            working_dir: None,",
        "            resources: ResourceEstimate::default(),",
        "        }).await.unwrap();",
        "        ",
        "        memory.add_command_node(\"cmd2\", &BashCommand {"
      ]
    },
    {
      "file": "src/synthex_bashgod/tests.rs",
      "line": 236,
      "code": "}).await.unwrap();",
      "context": [
        "            working_dir: None,",
        "            resources: ResourceEstimate::default(),",
        "        }).await.unwrap();",
        "        ",
        "        // Add dependency"
      ]
    },
    {
      "file": "src/synthex_bashgod/tests.rs",
      "line": 239,
      "code": "memory.add_dependency(\"cmd1\", \"cmd2\").await.unwrap();",
      "context": [
        "        ",
        "        // Add dependency",
        "        memory.add_dependency(\"cmd1\", \"cmd2\").await.unwrap();",
        "        ",
        "        // Find dependencies"
      ]
    },
    {
      "file": "src/synthex_bashgod/tests.rs",
      "line": 242,
      "code": "let deps = memory.find_dependencies(\"cmd1\").await.unwrap();",
      "context": [
        "        ",
        "        // Find dependencies",
        "        let deps = memory.find_dependencies(\"cmd1\").await.unwrap();",
        "        assert_eq!(deps.len(), 1);",
        "        assert_eq!(deps[0], \"cmd2\");"
      ]
    },
    {
      "file": "src/synthex_bashgod/tests.rs",
      "line": 309,
      "code": "let synergies = detector.detect(&commands, &context).await.unwrap();",
      "context": [
        "        };",
        "        ",
        "        let synergies = detector.detect(&commands, &context).await.unwrap();",
        "        assert!(!synergies.is_empty());",
        "        "
      ]
    },
    {
      "file": "src/synthex_bashgod/tests.rs",
      "line": 365,
      "code": "let result = optimizer.optimize(commands, vec![synergy], &context).await.unwrap();",
      "context": [
        "        };",
        "        ",
        "        let result = optimizer.optimize(commands, vec![synergy], &context).await.unwrap();",
        "        assert!(result.success);",
        "        assert_eq!(result.optimized.len(), 1); // Should merge into single pipeline"
      ]
    },
    {
      "file": "src/synthex_bashgod/tests.rs",
      "line": 404,
      "code": "let enhanced = enhancer.enhance(&cmd, &config).await.unwrap();",
      "context": [
        "        };",
        "        ",
        "        let enhanced = enhancer.enhance(&cmd, &config).await.unwrap();",
        "        assert!(enhanced.mcp_tool.is_some());",
        "        assert!(enhanced.performance_estimate.speedup > 1.0);"
      ]
    },
    {
      "file": "src/synthex_bashgod/tests.rs",
      "line": 470,
      "code": "let result = service.execute_chain(chain).await.unwrap();",
      "context": [
        "        ",
        "        let start = Instant::now();",
        "        let result = service.execute_chain(chain).await.unwrap();",
        "        let duration = start.elapsed();",
        "        "
      ]
    },
    {
      "file": "src/synthex_bashgod/tests.rs",
      "line": 489,
      "code": "memory.store_pattern(&format!(\"pattern-{}\", i), pattern).await.unwrap();",
      "context": [
        "        for i in 0..1000 {",
        "            let pattern: Vec<f32> = (0..128).map(|j| (i * j) as f32).collect();",
        "            memory.store_pattern(&format!(\"pattern-{}\", i), pattern).await.unwrap();",
        "        }",
        "        "
      ]
    },
    {
      "file": "src/synthex_bashgod/tests.rs",
      "line": 497,
      "code": "let similar = memory.find_similar(&search_pattern, 10).await.unwrap();",
      "context": [
        "        let search_pattern: Vec<f32> = (0..128).map(|j| j as f32 * 500.0).collect();",
        "        let search_start = Instant::now();",
        "        let similar = memory.find_similar(&search_pattern, 10).await.unwrap();",
        "        let search_duration = search_start.elapsed();",
        "        "
      ]
    },
    {
      "file": "src/synthex_bashgod/tests.rs",
      "line": 538,
      "code": "assert!(result.is_err() || !result.unwrap().success);",
      "context": [
        "        ",
        "        let result = service.execute_chain(chain).await;",
        "        assert!(result.is_err() || !result.unwrap().success);",
        "    }",
        "    "
      ]
    },
    {
      "file": "src/synthex_bashgod/tests.rs",
      "line": 543,
      "code": "let service = create_bashgod_service(BashGodConfig::default()).await.unwrap();",
      "context": [
        "    #[tokio::test]",
        "    async fn test_resource_limit_enforcement() {",
        "        let service = create_bashgod_service(BashGodConfig::default()).await.unwrap();",
        "        ",
        "        let chain = CommandChain {"
      ]
    },
    {
      "file": "src/synthex_bashgod/tests.rs",
      "line": 576,
      "code": "assert!(result.is_err() || !result.unwrap().success);",
      "context": [
        "        let result = service.execute_chain(chain).await;",
        "        // Should either fail or handle gracefully",
        "        assert!(result.is_err() || !result.unwrap().success);",
        "    }",
        "}"
      ]
    },
    {
      "file": "src/synthex_bashgod/distributed.rs",
      "line": 267,
      "code": ".unwrap()",
      "context": [
        "                timestamp: std::time::SystemTime::now()",
        "                    .duration_since(std::time::UNIX_EPOCH)",
        "                    .unwrap()",
        "                    .as_secs(),",
        "            };"
      ]
    },
    {
      "file": "src/synthex_bashgod/flow_control.rs",
      "line": 392,
      "code": "let permit2 = controller.acquire().await.unwrap();",
      "context": [
        "        // Acquire permits",
        "        let permit1 = controller.acquire().await.unwrap();",
        "        let permit2 = controller.acquire().await.unwrap();",
        "        ",
        "        // Third should be rejected due to limit"
      ]
    },
    {
      "file": "src/synthex_bashgod/flow_control.rs",
      "line": 399,
      "code": "assert!(result.is_err() || result.unwrap().is_err());",
      "context": [
        "            controller.acquire()",
        "        ).await;",
        "        assert!(result.is_err() || result.unwrap().is_err());",
        "        ",
        "        // Drop a permit"
      ]
    },
    {
      "file": "src/synthex_bashgod/flow_control.rs",
      "line": 406,
      "code": "let _permit3 = controller.acquire().await.unwrap();",
      "context": [
        "        // Should now accept",
        "        tokio::time::sleep(Duration::from_millis(50)).await;",
        "        let _permit3 = controller.acquire().await.unwrap();",
        "        ",
        "        let metrics = controller.get_metrics();"
      ]
    },
    {
      "file": "src/resources/memory_manager.rs",
      "line": 364,
      "code": "manager.release(&service_id).await.unwrap();",
      "context": [
        "        ",
        "        // Release allocation",
        "        manager.release(&service_id).await.unwrap();",
        "        assert_eq!(manager.get_allocated_memory().await, 0);",
        "    }"
      ]
    },
    {
      "file": "src/resources/memory_manager.rs",
      "line": 373,
      "code": "manager.allocate(&service_id, 512).await.unwrap();",
      "context": [
        "        ",
        "        let service_id = Uuid::new_v4();",
        "        manager.allocate(&service_id, 512).await.unwrap();",
        "        ",
        "        // Scale up"
      ]
    },
    {
      "file": "src/resources/memory_manager.rs",
      "line": 376,
      "code": "let updated = manager.update_allocation(&service_id, 1024).await.unwrap();",
      "context": [
        "        ",
        "        // Scale up",
        "        let updated = manager.update_allocation(&service_id, 1024).await.unwrap();",
        "        assert_eq!(updated.memory_mb, 1024);",
        "        assert_eq!(manager.get_allocated_memory().await, 1024);"
      ]
    },
    {
      "file": "src/resources/memory_manager.rs",
      "line": 381,
      "code": "let updated = manager.update_allocation(&service_id, 256).await.unwrap();",
      "context": [
        "        ",
        "        // Scale down",
        "        let updated = manager.update_allocation(&service_id, 256).await.unwrap();",
        "        assert_eq!(updated.memory_mb, 256);",
        "        assert_eq!(manager.get_allocated_memory().await, 256);"
      ]
    },
    {
      "file": "src/resources/memory_manager.rs",
      "line": 398,
      "code": "let allocation = manager.allocate(&service_id, 1024).await.unwrap();",
      "context": [
        "        ",
        "        let service_id = Uuid::new_v4();",
        "        let allocation = manager.allocate(&service_id, 1024).await.unwrap();",
        "        ",
        "        assert_eq!(allocation.memory_mb, 1024);"
      ]
    },
    {
      "file": "src/resources/storage_manager.rs",
      "line": 435,
      "code": "manager.release(&service_id).await.unwrap();",
      "context": [
        "        ",
        "        // Release allocation",
        "        manager.release(&service_id).await.unwrap();",
        "        assert_eq!(manager.get_allocated_storage().await, 0);",
        "    }"
      ]
    },
    {
      "file": "src/resources/storage_manager.rs",
      "line": 444,
      "code": "manager.allocate(&service_id, 500).await.unwrap();",
      "context": [
        "        ",
        "        let service_id = Uuid::new_v4();",
        "        manager.allocate(&service_id, 500).await.unwrap();",
        "        ",
        "        // Resize up"
      ]
    },
    {
      "file": "src/resources/storage_manager.rs",
      "line": 447,
      "code": "let resized = manager.resize_allocation(&service_id, 1000).await.unwrap();",
      "context": [
        "        ",
        "        // Resize up",
        "        let resized = manager.resize_allocation(&service_id, 1000).await.unwrap();",
        "        assert_eq!(resized.disk_mb, 1000);",
        "        assert_eq!(manager.get_allocated_storage().await, 1000);"
      ]
    },
    {
      "file": "src/resources/storage_manager.rs",
      "line": 452,
      "code": "let resized = manager.resize_allocation(&service_id, 250).await.unwrap();",
      "context": [
        "        ",
        "        // Resize down",
        "        let resized = manager.resize_allocation(&service_id, 250).await.unwrap();",
        "        assert_eq!(resized.disk_mb, 250);",
        "        assert_eq!(manager.get_allocated_storage().await, 250);"
      ]
    },
    {
      "file": "src/resources/storage_manager.rs",
      "line": 462,
      "code": "manager.allocate(&service_id, 1024).await.unwrap();",
      "context": [
        "        ",
        "        let service_id = Uuid::new_v4();",
        "        manager.allocate(&service_id, 1024).await.unwrap();",
        "        ",
        "        // Set I/O limits"
      ]
    },
    {
      "file": "src/resources/storage_manager.rs",
      "line": 465,
      "code": "manager.set_io_limits(&service_id, Some(1000), Some(100)).await.unwrap();",
      "context": [
        "        ",
        "        // Set I/O limits",
        "        manager.set_io_limits(&service_id, Some(1000), Some(100)).await.unwrap();",
        "        ",
        "        let allocation = manager.allocations.get(&service_id).unwrap();"
      ]
    },
    {
      "file": "src/resources/storage_manager.rs",
      "line": 467,
      "code": "let allocation = manager.allocations.get(&service_id).unwrap();",
      "context": [
        "        manager.set_io_limits(&service_id, Some(1000), Some(100)).await.unwrap();",
        "        ",
        "        let allocation = manager.allocations.get(&service_id).unwrap();",
        "        assert_eq!(allocation.iops_limit, Some(1000));",
        "        assert_eq!(allocation.bandwidth_limit_mbps, Some(100));"
      ]
    },
    {
      "file": "src/resources/cpu_manager.rs",
      "line": 332,
      "code": "manager.release(&service_id).await.unwrap();",
      "context": [
        "        ",
        "        // Release allocation",
        "        manager.release(&service_id).await.unwrap();",
        "        assert_eq!(manager.get_allocated_cores().await, 0.0);",
        "    }"
      ]
    },
    {
      "file": "src/resources/cpu_manager.rs",
      "line": 341,
      "code": "manager.allocate(&service_id, 1.0).await.unwrap();",
      "context": [
        "        ",
        "        let service_id = Uuid::new_v4();",
        "        manager.allocate(&service_id, 1.0).await.unwrap();",
        "        ",
        "        // Scale up"
      ]
    },
    {
      "file": "src/resources/cpu_manager.rs",
      "line": 344,
      "code": "let updated = manager.update_allocation(&service_id, 2.0).await.unwrap();",
      "context": [
        "        ",
        "        // Scale up",
        "        let updated = manager.update_allocation(&service_id, 2.0).await.unwrap();",
        "        assert_eq!(updated.cores, 2.0);",
        "        assert_eq!(manager.get_allocated_cores().await, 2.0);"
      ]
    },
    {
      "file": "src/resources/cpu_manager.rs",
      "line": 349,
      "code": "let updated = manager.update_allocation(&service_id, 0.5).await.unwrap();",
      "context": [
        "        ",
        "        // Scale down",
        "        let updated = manager.update_allocation(&service_id, 0.5).await.unwrap();",
        "        assert_eq!(updated.cores, 0.5);",
        "        assert_eq!(manager.get_allocated_cores().await, 0.5);"
      ]
    },
    {
      "file": "src/resources/mod.rs",
      "line": 208,
      "code": "manager.release_resources(&service_id).await.unwrap();",
      "context": [
        "        ",
        "        // Release resources",
        "        manager.release_resources(&service_id).await.unwrap();",
        "        ",
        "        // Verify allocation removed"
      ]
    },
    {
      "file": "src/bin/mcp_launcher_standalone.rs",
      "line": 211,
      "code": "server.auth_key.as_ref().unwrap()",
      "context": [
        "                    \"\u26a0\ufe0f  {} server skipped: {} not configured\",",
        "                    server.name,",
        "                    server.auth_key.as_ref().unwrap()",
        "                );",
        "            }"
      ]
    },
    {
      "file": "src/synthex/performance_optimizer.rs",
      "line": 272,
      "code": "l1_cache: Arc::new(RwLock::new(LruCache::new(NonZeroUsize::new(l1_size).unwrap()))),",
      "context": [
        "        ",
        "        Ok(Self {",
        "            l1_cache: Arc::new(RwLock::new(LruCache::new(NonZeroUsize::new(l1_size).unwrap()))),",
        "            l2_cache: Arc::new(DashMap::new()),",
        "            l3_cache,"
      ]
    },
    {
      "file": "src/synthex/performance_optimizer.rs",
      "line": 615,
      "code": "assert_eq!(result.unwrap(), Bytes::from(\"value1\"));",
      "context": [
        "        ",
        "        assert!(result.is_some());",
        "        assert_eq!(result.unwrap(), Bytes::from(\"value1\"));",
        "    }",
        "}"
      ]
    },
    {
      "file": "src/synthex/bashgod_optimizer.rs",
      "line": 140,
      "code": ".max_by(|a, b| a.score.partial_cmp(&b.score).unwrap())",
      "context": [
        "        let best_command = scored_variants",
        "            .into_iter()",
        "            .max_by(|a, b| a.score.partial_cmp(&b.score).unwrap())",
        "            .ok_or_else(|| anyhow!(\"No valid command generated\"))?;",
        "        "
      ]
    },
    {
      "file": "src/synthex/bashgod_optimizer.rs",
      "line": 483,
      "code": "matching_patterns.sort_by(|a, b| b.success_rate.partial_cmp(&a.success_rate).unwrap());",
      "context": [
        "        ",
        "        // Sort by success rate",
        "        matching_patterns.sort_by(|a, b| b.success_rate.partial_cmp(&a.success_rate).unwrap());",
        "        ",
        "        Ok(matching_patterns)"
      ]
    },
    {
      "file": "src/synthex/query_parser.rs",
      "line": 223,
      "code": "Regex::new(r\"find|search|look for|locate|discover\").unwrap(),",
      "context": [
        "        // Search patterns",
        "        patterns.insert(QueryIntent::Search, vec![",
        "            Regex::new(r\"find|search|look for|locate|discover\").unwrap(),",
        "            Regex::new(r\"what is|who is|where is|when is\").unwrap(),",
        "        ]);"
      ]
    },
    {
      "file": "src/synthex/query_parser.rs",
      "line": 224,
      "code": "Regex::new(r\"what is|who is|where is|when is\").unwrap(),",
      "context": [
        "        patterns.insert(QueryIntent::Search, vec![",
        "            Regex::new(r\"find|search|look for|locate|discover\").unwrap(),",
        "            Regex::new(r\"what is|who is|where is|when is\").unwrap(),",
        "        ]);",
        "        "
      ]
    },
    {
      "file": "src/synthex/query_parser.rs",
      "line": 229,
      "code": "Regex::new(r\"sum|total|average|count|statistics\").unwrap(),",
      "context": [
        "        // Aggregate patterns",
        "        patterns.insert(QueryIntent::Aggregate, vec![",
        "            Regex::new(r\"sum|total|average|count|statistics\").unwrap(),",
        "            Regex::new(r\"aggregate|combine|merge|collect\").unwrap(),",
        "        ]);"
      ]
    },
    {
      "file": "src/synthex/query_parser.rs",
      "line": 230,
      "code": "Regex::new(r\"aggregate|combine|merge|collect\").unwrap(),",
      "context": [
        "        patterns.insert(QueryIntent::Aggregate, vec![",
        "            Regex::new(r\"sum|total|average|count|statistics\").unwrap(),",
        "            Regex::new(r\"aggregate|combine|merge|collect\").unwrap(),",
        "        ]);",
        "        "
      ]
    },
    {
      "file": "src/synthex/query_parser.rs",
      "line": 235,
      "code": "Regex::new(r\"create|update|delete|modify|execute\").unwrap(),",
      "context": [
        "        // Action patterns",
        "        patterns.insert(QueryIntent::Action, vec![",
        "            Regex::new(r\"create|update|delete|modify|execute\").unwrap(),",
        "            Regex::new(r\"run|start|stop|deploy|configure\").unwrap(),",
        "        ]);"
      ]
    },
    {
      "file": "src/synthex/query_parser.rs",
      "line": 236,
      "code": "Regex::new(r\"run|start|stop|deploy|configure\").unwrap(),",
      "context": [
        "        patterns.insert(QueryIntent::Action, vec![",
        "            Regex::new(r\"create|update|delete|modify|execute\").unwrap(),",
        "            Regex::new(r\"run|start|stop|deploy|configure\").unwrap(),",
        "        ]);",
        "        "
      ]
    },
    {
      "file": "src/synthex/query_parser.rs",
      "line": 313,
      "code": "Regex::new(r\"https?://[^\\s]+\").unwrap()",
      "context": [
        "        entity_patterns.insert(",
        "            EntityType::Url,",
        "            Regex::new(r\"https?://[^\\s]+\").unwrap()",
        "        );",
        "        "
      ]
    },
    {
      "file": "src/synthex/query_parser.rs",
      "line": 318,
      "code": "Regex::new(r\"[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}\").unwrap()",
      "context": [
        "        entity_patterns.insert(",
        "            EntityType::Email,",
        "            Regex::new(r\"[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}\").unwrap()",
        "        );",
        "        "
      ]
    },
    {
      "file": "src/synthex/query_parser.rs",
      "line": 323,
      "code": "Regex::new(r\"\\b\\d+\\.?\\d*\\b\").unwrap()",
      "context": [
        "        entity_patterns.insert(",
        "            EntityType::Number,",
        "            Regex::new(r\"\\b\\d+\\.?\\d*\\b\").unwrap()",
        "        );",
        "        "
      ]
    },
    {
      "file": "src/synthex/engine.rs",
      "line": 364,
      "code": "let status = engine.get_agent_status().await.unwrap();",
      "context": [
        "        assert!(engine.register_agent(\"test_agent\".to_string(), mock_agent).await.is_ok());",
        "        ",
        "        let status = engine.get_agent_status().await.unwrap();",
        "        assert!(status.contains_key(\"test_agent\"));",
        "    }"
      ]
    },
    {
      "file": "src/synthex/config.rs",
      "line": 133,
      "code": "serde_json::from_str(&serde_json::to_string(self).unwrap()).unwrap()",
      "context": [
        "    /// Convert to format suitable for Python",
        "    pub fn to_python_dict(&self) -> HashMap<String, serde_json::Value> {",
        "        serde_json::from_str(&serde_json::to_string(self).unwrap()).unwrap()",
        "    }",
        "    "
      ]
    },
    {
      "file": "src/synthex/knowledge_graph.rs",
      "line": 193,
      "code": "related.sort_by(|a, b| a.1.partial_cmp(&b.1).unwrap());",
      "context": [
        "        ",
        "        // Sort by distance",
        "        related.sort_by(|a, b| a.1.partial_cmp(&b.1).unwrap());",
        "        ",
        "        related"
      ]
    },
    {
      "file": "src/synthex/knowledge_graph.rs",
      "line": 346,
      "code": "similarities.sort_by(|a, b| b.1.partial_cmp(&a.1).unwrap());",
      "context": [
        "        ",
        "        // Sort by similarity (descending)",
        "        similarities.sort_by(|a, b| b.1.partial_cmp(&a.1).unwrap());",
        "        similarities.truncate(top_k);",
        "        "
      ]
    },
    {
      "file": "src/mcp_manager/fusion/command_router.rs",
      "line": 680,
      "code": "let result = router.execute_bash(\"echo 'Hello, World!'\").await.unwrap();",
      "context": [
        "        let router = CommandRouter::new(mcp_manager, tool_registry);",
        "        ",
        "        let result = router.execute_bash(\"echo 'Hello, World!'\").await.unwrap();",
        "        assert_eq!(result.stdout.trim(), \"Hello, World!\");",
        "        assert_eq!(result.exit_code, 0);"
      ]
    },
    {
      "file": "src/mcp_manager/fusion/cross_tool.rs",
      "line": 857,
      "code": "let plan = orchestrator.build_execution_plan(&workflow).unwrap();",
      "context": [
        "        };",
        "        ",
        "        let plan = orchestrator.build_execution_plan(&workflow).unwrap();",
        "        assert_eq!(plan.len(), 2);",
        "        assert_eq!(plan[0], vec![\"step1\".to_string()]);"
      ]
    },
    {
      "file": "src/mcp_manager/fusion/tool_enhancer.rs",
      "line": 19,
      "code": "(Regex::new(r\"^docker\\s+ps\").unwrap(), \"list_containers\"),",
      "context": [
        "    /// Docker command patterns",
        "    static ref DOCKER_PATTERNS: Vec<(Regex, &'static str)> = vec![",
        "        (Regex::new(r\"^docker\\s+ps\").unwrap(), \"list_containers\"),",
        "        (Regex::new(r\"^docker\\s+images\").unwrap(), \"list_images\"),",
        "        (Regex::new(r\"^docker\\s+run\").unwrap(), \"run_container\"),"
      ]
    },
    {
      "file": "src/mcp_manager/fusion/tool_enhancer.rs",
      "line": 20,
      "code": "(Regex::new(r\"^docker\\s+images\").unwrap(), \"list_images\"),",
      "context": [
        "    static ref DOCKER_PATTERNS: Vec<(Regex, &'static str)> = vec![",
        "        (Regex::new(r\"^docker\\s+ps\").unwrap(), \"list_containers\"),",
        "        (Regex::new(r\"^docker\\s+images\").unwrap(), \"list_images\"),",
        "        (Regex::new(r\"^docker\\s+run\").unwrap(), \"run_container\"),",
        "        (Regex::new(r\"^docker\\s+build\").unwrap(), \"build_image\"),"
      ]
    },
    {
      "file": "src/mcp_manager/fusion/tool_enhancer.rs",
      "line": 21,
      "code": "(Regex::new(r\"^docker\\s+run\").unwrap(), \"run_container\"),",
      "context": [
        "        (Regex::new(r\"^docker\\s+ps\").unwrap(), \"list_containers\"),",
        "        (Regex::new(r\"^docker\\s+images\").unwrap(), \"list_images\"),",
        "        (Regex::new(r\"^docker\\s+run\").unwrap(), \"run_container\"),",
        "        (Regex::new(r\"^docker\\s+build\").unwrap(), \"build_image\"),",
        "        (Regex::new(r\"^docker\\s+logs\").unwrap(), \"get_logs\"),"
      ]
    },
    {
      "file": "src/mcp_manager/fusion/tool_enhancer.rs",
      "line": 22,
      "code": "(Regex::new(r\"^docker\\s+build\").unwrap(), \"build_image\"),",
      "context": [
        "        (Regex::new(r\"^docker\\s+images\").unwrap(), \"list_images\"),",
        "        (Regex::new(r\"^docker\\s+run\").unwrap(), \"run_container\"),",
        "        (Regex::new(r\"^docker\\s+build\").unwrap(), \"build_image\"),",
        "        (Regex::new(r\"^docker\\s+logs\").unwrap(), \"get_logs\"),",
        "        (Regex::new(r\"^docker\\s+exec\").unwrap(), \"exec_command\"),"
      ]
    },
    {
      "file": "src/mcp_manager/fusion/tool_enhancer.rs",
      "line": 23,
      "code": "(Regex::new(r\"^docker\\s+logs\").unwrap(), \"get_logs\"),",
      "context": [
        "        (Regex::new(r\"^docker\\s+run\").unwrap(), \"run_container\"),",
        "        (Regex::new(r\"^docker\\s+build\").unwrap(), \"build_image\"),",
        "        (Regex::new(r\"^docker\\s+logs\").unwrap(), \"get_logs\"),",
        "        (Regex::new(r\"^docker\\s+exec\").unwrap(), \"exec_command\"),",
        "        (Regex::new(r\"^docker\\s+stop\").unwrap(), \"stop_container\"),"
      ]
    },
    {
      "file": "src/mcp_manager/fusion/tool_enhancer.rs",
      "line": 24,
      "code": "(Regex::new(r\"^docker\\s+exec\").unwrap(), \"exec_command\"),",
      "context": [
        "        (Regex::new(r\"^docker\\s+build\").unwrap(), \"build_image\"),",
        "        (Regex::new(r\"^docker\\s+logs\").unwrap(), \"get_logs\"),",
        "        (Regex::new(r\"^docker\\s+exec\").unwrap(), \"exec_command\"),",
        "        (Regex::new(r\"^docker\\s+stop\").unwrap(), \"stop_container\"),",
        "        (Regex::new(r\"^docker\\s+rm\").unwrap(), \"remove_container\"),"
      ]
    },
    {
      "file": "src/mcp_manager/fusion/tool_enhancer.rs",
      "line": 25,
      "code": "(Regex::new(r\"^docker\\s+stop\").unwrap(), \"stop_container\"),",
      "context": [
        "        (Regex::new(r\"^docker\\s+logs\").unwrap(), \"get_logs\"),",
        "        (Regex::new(r\"^docker\\s+exec\").unwrap(), \"exec_command\"),",
        "        (Regex::new(r\"^docker\\s+stop\").unwrap(), \"stop_container\"),",
        "        (Regex::new(r\"^docker\\s+rm\").unwrap(), \"remove_container\"),",
        "        (Regex::new(r\"^docker-compose\\s+up\").unwrap(), \"compose_up\"),"
      ]
    },
    {
      "file": "src/mcp_manager/fusion/tool_enhancer.rs",
      "line": 26,
      "code": "(Regex::new(r\"^docker\\s+rm\").unwrap(), \"remove_container\"),",
      "context": [
        "        (Regex::new(r\"^docker\\s+exec\").unwrap(), \"exec_command\"),",
        "        (Regex::new(r\"^docker\\s+stop\").unwrap(), \"stop_container\"),",
        "        (Regex::new(r\"^docker\\s+rm\").unwrap(), \"remove_container\"),",
        "        (Regex::new(r\"^docker-compose\\s+up\").unwrap(), \"compose_up\"),",
        "        (Regex::new(r\"^docker-compose\\s+down\").unwrap(), \"compose_down\"),"
      ]
    },
    {
      "file": "src/mcp_manager/fusion/tool_enhancer.rs",
      "line": 27,
      "code": "(Regex::new(r\"^docker-compose\\s+up\").unwrap(), \"compose_up\"),",
      "context": [
        "        (Regex::new(r\"^docker\\s+stop\").unwrap(), \"stop_container\"),",
        "        (Regex::new(r\"^docker\\s+rm\").unwrap(), \"remove_container\"),",
        "        (Regex::new(r\"^docker-compose\\s+up\").unwrap(), \"compose_up\"),",
        "        (Regex::new(r\"^docker-compose\\s+down\").unwrap(), \"compose_down\"),",
        "    ];"
      ]
    },
    {
      "file": "src/mcp_manager/fusion/tool_enhancer.rs",
      "line": 28,
      "code": "(Regex::new(r\"^docker-compose\\s+down\").unwrap(), \"compose_down\"),",
      "context": [
        "        (Regex::new(r\"^docker\\s+rm\").unwrap(), \"remove_container\"),",
        "        (Regex::new(r\"^docker-compose\\s+up\").unwrap(), \"compose_up\"),",
        "        (Regex::new(r\"^docker-compose\\s+down\").unwrap(), \"compose_down\"),",
        "    ];",
        ""
      ]
    },
    {
      "file": "src/mcp_manager/fusion/tool_enhancer.rs",
      "line": 33,
      "code": "(Regex::new(r\"^git\\s+status\").unwrap(), \"get_status\"),",
      "context": [
        "    /// Git/GitHub command patterns",
        "    static ref GIT_PATTERNS: Vec<(Regex, &'static str)> = vec![",
        "        (Regex::new(r\"^git\\s+status\").unwrap(), \"get_status\"),",
        "        (Regex::new(r\"^git\\s+log\").unwrap(), \"get_commits\"),",
        "        (Regex::new(r\"^git\\s+diff\").unwrap(), \"get_diff\"),"
      ]
    },
    {
      "file": "src/mcp_manager/fusion/tool_enhancer.rs",
      "line": 34,
      "code": "(Regex::new(r\"^git\\s+log\").unwrap(), \"get_commits\"),",
      "context": [
        "    static ref GIT_PATTERNS: Vec<(Regex, &'static str)> = vec![",
        "        (Regex::new(r\"^git\\s+status\").unwrap(), \"get_status\"),",
        "        (Regex::new(r\"^git\\s+log\").unwrap(), \"get_commits\"),",
        "        (Regex::new(r\"^git\\s+diff\").unwrap(), \"get_diff\"),",
        "        (Regex::new(r\"^git\\s+add\").unwrap(), \"stage_files\"),"
      ]
    },
    {
      "file": "src/mcp_manager/fusion/tool_enhancer.rs",
      "line": 35,
      "code": "(Regex::new(r\"^git\\s+diff\").unwrap(), \"get_diff\"),",
      "context": [
        "        (Regex::new(r\"^git\\s+status\").unwrap(), \"get_status\"),",
        "        (Regex::new(r\"^git\\s+log\").unwrap(), \"get_commits\"),",
        "        (Regex::new(r\"^git\\s+diff\").unwrap(), \"get_diff\"),",
        "        (Regex::new(r\"^git\\s+add\").unwrap(), \"stage_files\"),",
        "        (Regex::new(r\"^git\\s+commit\").unwrap(), \"create_commit\"),"
      ]
    },
    {
      "file": "src/mcp_manager/fusion/tool_enhancer.rs",
      "line": 36,
      "code": "(Regex::new(r\"^git\\s+add\").unwrap(), \"stage_files\"),",
      "context": [
        "        (Regex::new(r\"^git\\s+log\").unwrap(), \"get_commits\"),",
        "        (Regex::new(r\"^git\\s+diff\").unwrap(), \"get_diff\"),",
        "        (Regex::new(r\"^git\\s+add\").unwrap(), \"stage_files\"),",
        "        (Regex::new(r\"^git\\s+commit\").unwrap(), \"create_commit\"),",
        "        (Regex::new(r\"^git\\s+push\").unwrap(), \"push_changes\"),"
      ]
    },
    {
      "file": "src/mcp_manager/fusion/tool_enhancer.rs",
      "line": 37,
      "code": "(Regex::new(r\"^git\\s+commit\").unwrap(), \"create_commit\"),",
      "context": [
        "        (Regex::new(r\"^git\\s+diff\").unwrap(), \"get_diff\"),",
        "        (Regex::new(r\"^git\\s+add\").unwrap(), \"stage_files\"),",
        "        (Regex::new(r\"^git\\s+commit\").unwrap(), \"create_commit\"),",
        "        (Regex::new(r\"^git\\s+push\").unwrap(), \"push_changes\"),",
        "        (Regex::new(r\"^git\\s+pull\").unwrap(), \"pull_changes\"),"
      ]
    },
    {
      "file": "src/mcp_manager/fusion/tool_enhancer.rs",
      "line": 38,
      "code": "(Regex::new(r\"^git\\s+push\").unwrap(), \"push_changes\"),",
      "context": [
        "        (Regex::new(r\"^git\\s+add\").unwrap(), \"stage_files\"),",
        "        (Regex::new(r\"^git\\s+commit\").unwrap(), \"create_commit\"),",
        "        (Regex::new(r\"^git\\s+push\").unwrap(), \"push_changes\"),",
        "        (Regex::new(r\"^git\\s+pull\").unwrap(), \"pull_changes\"),",
        "        (Regex::new(r\"^gh\\s+pr\\s+create\").unwrap(), \"create_pull_request\"),"
      ]
    },
    {
      "file": "src/mcp_manager/fusion/tool_enhancer.rs",
      "line": 39,
      "code": "(Regex::new(r\"^git\\s+pull\").unwrap(), \"pull_changes\"),",
      "context": [
        "        (Regex::new(r\"^git\\s+commit\").unwrap(), \"create_commit\"),",
        "        (Regex::new(r\"^git\\s+push\").unwrap(), \"push_changes\"),",
        "        (Regex::new(r\"^git\\s+pull\").unwrap(), \"pull_changes\"),",
        "        (Regex::new(r\"^gh\\s+pr\\s+create\").unwrap(), \"create_pull_request\"),",
        "        (Regex::new(r\"^gh\\s+issue\\s+create\").unwrap(), \"create_issue\"),"
      ]
    },
    {
      "file": "src/mcp_manager/fusion/tool_enhancer.rs",
      "line": 40,
      "code": "(Regex::new(r\"^gh\\s+pr\\s+create\").unwrap(), \"create_pull_request\"),",
      "context": [
        "        (Regex::new(r\"^git\\s+push\").unwrap(), \"push_changes\"),",
        "        (Regex::new(r\"^git\\s+pull\").unwrap(), \"pull_changes\"),",
        "        (Regex::new(r\"^gh\\s+pr\\s+create\").unwrap(), \"create_pull_request\"),",
        "        (Regex::new(r\"^gh\\s+issue\\s+create\").unwrap(), \"create_issue\"),",
        "        (Regex::new(r\"^gh\\s+release\\s+create\").unwrap(), \"create_release\"),"
      ]
    },
    {
      "file": "src/mcp_manager/fusion/tool_enhancer.rs",
      "line": 41,
      "code": "(Regex::new(r\"^gh\\s+issue\\s+create\").unwrap(), \"create_issue\"),",
      "context": [
        "        (Regex::new(r\"^git\\s+pull\").unwrap(), \"pull_changes\"),",
        "        (Regex::new(r\"^gh\\s+pr\\s+create\").unwrap(), \"create_pull_request\"),",
        "        (Regex::new(r\"^gh\\s+issue\\s+create\").unwrap(), \"create_issue\"),",
        "        (Regex::new(r\"^gh\\s+release\\s+create\").unwrap(), \"create_release\"),",
        "    ];"
      ]
    },
    {
      "file": "src/mcp_manager/fusion/tool_enhancer.rs",
      "line": 42,
      "code": "(Regex::new(r\"^gh\\s+release\\s+create\").unwrap(), \"create_release\"),",
      "context": [
        "        (Regex::new(r\"^gh\\s+pr\\s+create\").unwrap(), \"create_pull_request\"),",
        "        (Regex::new(r\"^gh\\s+issue\\s+create\").unwrap(), \"create_issue\"),",
        "        (Regex::new(r\"^gh\\s+release\\s+create\").unwrap(), \"create_release\"),",
        "    ];",
        ""
      ]
    },
    {
      "file": "src/mcp_manager/fusion/tool_enhancer.rs",
      "line": 47,
      "code": "(Regex::new(r\"^ls\\s+\").unwrap(), \"list_directory\"),",
      "context": [
        "    /// File operation patterns",
        "    static ref FILE_PATTERNS: Vec<(Regex, &'static str)> = vec![",
        "        (Regex::new(r\"^ls\\s+\").unwrap(), \"list_directory\"),",
        "        (Regex::new(r\"^cat\\s+\").unwrap(), \"read_file\"),",
        "        (Regex::new(r\"^grep\\s+\").unwrap(), \"search_files\"),"
      ]
    },
    {
      "file": "src/mcp_manager/fusion/tool_enhancer.rs",
      "line": 48,
      "code": "(Regex::new(r\"^cat\\s+\").unwrap(), \"read_file\"),",
      "context": [
        "    static ref FILE_PATTERNS: Vec<(Regex, &'static str)> = vec![",
        "        (Regex::new(r\"^ls\\s+\").unwrap(), \"list_directory\"),",
        "        (Regex::new(r\"^cat\\s+\").unwrap(), \"read_file\"),",
        "        (Regex::new(r\"^grep\\s+\").unwrap(), \"search_files\"),",
        "        (Regex::new(r\"^find\\s+\").unwrap(), \"find_files\"),"
      ]
    },
    {
      "file": "src/mcp_manager/fusion/tool_enhancer.rs",
      "line": 49,
      "code": "(Regex::new(r\"^grep\\s+\").unwrap(), \"search_files\"),",
      "context": [
        "        (Regex::new(r\"^ls\\s+\").unwrap(), \"list_directory\"),",
        "        (Regex::new(r\"^cat\\s+\").unwrap(), \"read_file\"),",
        "        (Regex::new(r\"^grep\\s+\").unwrap(), \"search_files\"),",
        "        (Regex::new(r\"^find\\s+\").unwrap(), \"find_files\"),",
        "        (Regex::new(r\"^cp\\s+\").unwrap(), \"copy_file\"),"
      ]
    },
    {
      "file": "src/mcp_manager/fusion/tool_enhancer.rs",
      "line": 50,
      "code": "(Regex::new(r\"^find\\s+\").unwrap(), \"find_files\"),",
      "context": [
        "        (Regex::new(r\"^cat\\s+\").unwrap(), \"read_file\"),",
        "        (Regex::new(r\"^grep\\s+\").unwrap(), \"search_files\"),",
        "        (Regex::new(r\"^find\\s+\").unwrap(), \"find_files\"),",
        "        (Regex::new(r\"^cp\\s+\").unwrap(), \"copy_file\"),",
        "        (Regex::new(r\"^mv\\s+\").unwrap(), \"move_file\"),"
      ]
    },
    {
      "file": "src/mcp_manager/fusion/tool_enhancer.rs",
      "line": 51,
      "code": "(Regex::new(r\"^cp\\s+\").unwrap(), \"copy_file\"),",
      "context": [
        "        (Regex::new(r\"^grep\\s+\").unwrap(), \"search_files\"),",
        "        (Regex::new(r\"^find\\s+\").unwrap(), \"find_files\"),",
        "        (Regex::new(r\"^cp\\s+\").unwrap(), \"copy_file\"),",
        "        (Regex::new(r\"^mv\\s+\").unwrap(), \"move_file\"),",
        "        (Regex::new(r\"^rm\\s+\").unwrap(), \"delete_file\"),"
      ]
    },
    {
      "file": "src/mcp_manager/fusion/tool_enhancer.rs",
      "line": 52,
      "code": "(Regex::new(r\"^mv\\s+\").unwrap(), \"move_file\"),",
      "context": [
        "        (Regex::new(r\"^find\\s+\").unwrap(), \"find_files\"),",
        "        (Regex::new(r\"^cp\\s+\").unwrap(), \"copy_file\"),",
        "        (Regex::new(r\"^mv\\s+\").unwrap(), \"move_file\"),",
        "        (Regex::new(r\"^rm\\s+\").unwrap(), \"delete_file\"),",
        "        (Regex::new(r\"^mkdir\\s+\").unwrap(), \"create_directory\"),"
      ]
    },
    {
      "file": "src/mcp_manager/fusion/tool_enhancer.rs",
      "line": 53,
      "code": "(Regex::new(r\"^rm\\s+\").unwrap(), \"delete_file\"),",
      "context": [
        "        (Regex::new(r\"^cp\\s+\").unwrap(), \"copy_file\"),",
        "        (Regex::new(r\"^mv\\s+\").unwrap(), \"move_file\"),",
        "        (Regex::new(r\"^rm\\s+\").unwrap(), \"delete_file\"),",
        "        (Regex::new(r\"^mkdir\\s+\").unwrap(), \"create_directory\"),",
        "        (Regex::new(r\"^touch\\s+\").unwrap(), \"create_file\"),"
      ]
    },
    {
      "file": "src/mcp_manager/fusion/tool_enhancer.rs",
      "line": 54,
      "code": "(Regex::new(r\"^mkdir\\s+\").unwrap(), \"create_directory\"),",
      "context": [
        "        (Regex::new(r\"^mv\\s+\").unwrap(), \"move_file\"),",
        "        (Regex::new(r\"^rm\\s+\").unwrap(), \"delete_file\"),",
        "        (Regex::new(r\"^mkdir\\s+\").unwrap(), \"create_directory\"),",
        "        (Regex::new(r\"^touch\\s+\").unwrap(), \"create_file\"),",
        "        (Regex::new(r\"^chmod\\s+\").unwrap(), \"change_permissions\"),"
      ]
    },
    {
      "file": "src/mcp_manager/fusion/tool_enhancer.rs",
      "line": 55,
      "code": "(Regex::new(r\"^touch\\s+\").unwrap(), \"create_file\"),",
      "context": [
        "        (Regex::new(r\"^rm\\s+\").unwrap(), \"delete_file\"),",
        "        (Regex::new(r\"^mkdir\\s+\").unwrap(), \"create_directory\"),",
        "        (Regex::new(r\"^touch\\s+\").unwrap(), \"create_file\"),",
        "        (Regex::new(r\"^chmod\\s+\").unwrap(), \"change_permissions\"),",
        "    ];"
      ]
    },
    {
      "file": "src/mcp_manager/fusion/tool_enhancer.rs",
      "line": 56,
      "code": "(Regex::new(r\"^chmod\\s+\").unwrap(), \"change_permissions\"),",
      "context": [
        "        (Regex::new(r\"^mkdir\\s+\").unwrap(), \"create_directory\"),",
        "        (Regex::new(r\"^touch\\s+\").unwrap(), \"create_file\"),",
        "        (Regex::new(r\"^chmod\\s+\").unwrap(), \"change_permissions\"),",
        "    ];",
        ""
      ]
    },
    {
      "file": "src/mcp_manager/fusion/tool_enhancer.rs",
      "line": 61,
      "code": "(Regex::new(r\"^kubectl\\s+get\\s+pods\").unwrap(), \"list_pods\"),",
      "context": [
        "    /// Kubernetes command patterns",
        "    static ref K8S_PATTERNS: Vec<(Regex, &'static str)> = vec![",
        "        (Regex::new(r\"^kubectl\\s+get\\s+pods\").unwrap(), \"list_pods\"),",
        "        (Regex::new(r\"^kubectl\\s+get\\s+services\").unwrap(), \"list_services\"),",
        "        (Regex::new(r\"^kubectl\\s+apply\").unwrap(), \"apply_manifest\"),"
      ]
    },
    {
      "file": "src/mcp_manager/fusion/tool_enhancer.rs",
      "line": 62,
      "code": "(Regex::new(r\"^kubectl\\s+get\\s+services\").unwrap(), \"list_services\"),",
      "context": [
        "    static ref K8S_PATTERNS: Vec<(Regex, &'static str)> = vec![",
        "        (Regex::new(r\"^kubectl\\s+get\\s+pods\").unwrap(), \"list_pods\"),",
        "        (Regex::new(r\"^kubectl\\s+get\\s+services\").unwrap(), \"list_services\"),",
        "        (Regex::new(r\"^kubectl\\s+apply\").unwrap(), \"apply_manifest\"),",
        "        (Regex::new(r\"^kubectl\\s+delete\").unwrap(), \"delete_resource\"),"
      ]
    },
    {
      "file": "src/mcp_manager/fusion/tool_enhancer.rs",
      "line": 63,
      "code": "(Regex::new(r\"^kubectl\\s+apply\").unwrap(), \"apply_manifest\"),",
      "context": [
        "        (Regex::new(r\"^kubectl\\s+get\\s+pods\").unwrap(), \"list_pods\"),",
        "        (Regex::new(r\"^kubectl\\s+get\\s+services\").unwrap(), \"list_services\"),",
        "        (Regex::new(r\"^kubectl\\s+apply\").unwrap(), \"apply_manifest\"),",
        "        (Regex::new(r\"^kubectl\\s+delete\").unwrap(), \"delete_resource\"),",
        "        (Regex::new(r\"^kubectl\\s+logs\").unwrap(), \"get_pod_logs\"),"
      ]
    },
    {
      "file": "src/mcp_manager/fusion/tool_enhancer.rs",
      "line": 64,
      "code": "(Regex::new(r\"^kubectl\\s+delete\").unwrap(), \"delete_resource\"),",
      "context": [
        "        (Regex::new(r\"^kubectl\\s+get\\s+services\").unwrap(), \"list_services\"),",
        "        (Regex::new(r\"^kubectl\\s+apply\").unwrap(), \"apply_manifest\"),",
        "        (Regex::new(r\"^kubectl\\s+delete\").unwrap(), \"delete_resource\"),",
        "        (Regex::new(r\"^kubectl\\s+logs\").unwrap(), \"get_pod_logs\"),",
        "        (Regex::new(r\"^kubectl\\s+exec\").unwrap(), \"exec_in_pod\"),"
      ]
    },
    {
      "file": "src/mcp_manager/fusion/tool_enhancer.rs",
      "line": 65,
      "code": "(Regex::new(r\"^kubectl\\s+logs\").unwrap(), \"get_pod_logs\"),",
      "context": [
        "        (Regex::new(r\"^kubectl\\s+apply\").unwrap(), \"apply_manifest\"),",
        "        (Regex::new(r\"^kubectl\\s+delete\").unwrap(), \"delete_resource\"),",
        "        (Regex::new(r\"^kubectl\\s+logs\").unwrap(), \"get_pod_logs\"),",
        "        (Regex::new(r\"^kubectl\\s+exec\").unwrap(), \"exec_in_pod\"),",
        "        (Regex::new(r\"^kubectl\\s+describe\").unwrap(), \"describe_resource\"),"
      ]
    },
    {
      "file": "src/mcp_manager/fusion/tool_enhancer.rs",
      "line": 66,
      "code": "(Regex::new(r\"^kubectl\\s+exec\").unwrap(), \"exec_in_pod\"),",
      "context": [
        "        (Regex::new(r\"^kubectl\\s+delete\").unwrap(), \"delete_resource\"),",
        "        (Regex::new(r\"^kubectl\\s+logs\").unwrap(), \"get_pod_logs\"),",
        "        (Regex::new(r\"^kubectl\\s+exec\").unwrap(), \"exec_in_pod\"),",
        "        (Regex::new(r\"^kubectl\\s+describe\").unwrap(), \"describe_resource\"),",
        "        (Regex::new(r\"^kubectl\\s+rollout\").unwrap(), \"manage_rollout\"),"
      ]
    },
    {
      "file": "src/mcp_manager/fusion/tool_enhancer.rs",
      "line": 67,
      "code": "(Regex::new(r\"^kubectl\\s+describe\").unwrap(), \"describe_resource\"),",
      "context": [
        "        (Regex::new(r\"^kubectl\\s+logs\").unwrap(), \"get_pod_logs\"),",
        "        (Regex::new(r\"^kubectl\\s+exec\").unwrap(), \"exec_in_pod\"),",
        "        (Regex::new(r\"^kubectl\\s+describe\").unwrap(), \"describe_resource\"),",
        "        (Regex::new(r\"^kubectl\\s+rollout\").unwrap(), \"manage_rollout\"),",
        "        (Regex::new(r\"^helm\\s+install\").unwrap(), \"helm_install\"),"
      ]
    },
    {
      "file": "src/mcp_manager/fusion/tool_enhancer.rs",
      "line": 68,
      "code": "(Regex::new(r\"^kubectl\\s+rollout\").unwrap(), \"manage_rollout\"),",
      "context": [
        "        (Regex::new(r\"^kubectl\\s+exec\").unwrap(), \"exec_in_pod\"),",
        "        (Regex::new(r\"^kubectl\\s+describe\").unwrap(), \"describe_resource\"),",
        "        (Regex::new(r\"^kubectl\\s+rollout\").unwrap(), \"manage_rollout\"),",
        "        (Regex::new(r\"^helm\\s+install\").unwrap(), \"helm_install\"),",
        "        (Regex::new(r\"^helm\\s+upgrade\").unwrap(), \"helm_upgrade\"),"
      ]
    },
    {
      "file": "src/mcp_manager/fusion/tool_enhancer.rs",
      "line": 69,
      "code": "(Regex::new(r\"^helm\\s+install\").unwrap(), \"helm_install\"),",
      "context": [
        "        (Regex::new(r\"^kubectl\\s+describe\").unwrap(), \"describe_resource\"),",
        "        (Regex::new(r\"^kubectl\\s+rollout\").unwrap(), \"manage_rollout\"),",
        "        (Regex::new(r\"^helm\\s+install\").unwrap(), \"helm_install\"),",
        "        (Regex::new(r\"^helm\\s+upgrade\").unwrap(), \"helm_upgrade\"),",
        "    ];"
      ]
    },
    {
      "file": "src/mcp_manager/fusion/tool_enhancer.rs",
      "line": 70,
      "code": "(Regex::new(r\"^helm\\s+upgrade\").unwrap(), \"helm_upgrade\"),",
      "context": [
        "        (Regex::new(r\"^kubectl\\s+rollout\").unwrap(), \"manage_rollout\"),",
        "        (Regex::new(r\"^helm\\s+install\").unwrap(), \"helm_install\"),",
        "        (Regex::new(r\"^helm\\s+upgrade\").unwrap(), \"helm_upgrade\"),",
        "    ];",
        ""
      ]
    },
    {
      "file": "src/mcp_manager/fusion/tool_enhancer.rs",
      "line": 75,
      "code": "(Regex::new(r\"^curl.*metrics\").unwrap(), \"get_metrics\"),",
      "context": [
        "    /// Monitoring command patterns",
        "    static ref MONITORING_PATTERNS: Vec<(Regex, &'static str)> = vec![",
        "        (Regex::new(r\"^curl.*metrics\").unwrap(), \"get_metrics\"),",
        "        (Regex::new(r\"^prometheus.*query\").unwrap(), \"query_prometheus\"),",
        "        (Regex::new(r\"^grafana.*dashboard\").unwrap(), \"manage_dashboard\"),"
      ]
    },
    {
      "file": "src/mcp_manager/fusion/tool_enhancer.rs",
      "line": 76,
      "code": "(Regex::new(r\"^prometheus.*query\").unwrap(), \"query_prometheus\"),",
      "context": [
        "    static ref MONITORING_PATTERNS: Vec<(Regex, &'static str)> = vec![",
        "        (Regex::new(r\"^curl.*metrics\").unwrap(), \"get_metrics\"),",
        "        (Regex::new(r\"^prometheus.*query\").unwrap(), \"query_prometheus\"),",
        "        (Regex::new(r\"^grafana.*dashboard\").unwrap(), \"manage_dashboard\"),",
        "        (Regex::new(r\"^tail.*log\").unwrap(), \"tail_logs\"),"
      ]
    },
    {
      "file": "src/mcp_manager/fusion/tool_enhancer.rs",
      "line": 77,
      "code": "(Regex::new(r\"^grafana.*dashboard\").unwrap(), \"manage_dashboard\"),",
      "context": [
        "        (Regex::new(r\"^curl.*metrics\").unwrap(), \"get_metrics\"),",
        "        (Regex::new(r\"^prometheus.*query\").unwrap(), \"query_prometheus\"),",
        "        (Regex::new(r\"^grafana.*dashboard\").unwrap(), \"manage_dashboard\"),",
        "        (Regex::new(r\"^tail.*log\").unwrap(), \"tail_logs\"),",
        "        (Regex::new(r\"^journalctl\").unwrap(), \"system_logs\"),"
      ]
    },
    {
      "file": "src/mcp_manager/fusion/tool_enhancer.rs",
      "line": 78,
      "code": "(Regex::new(r\"^tail.*log\").unwrap(), \"tail_logs\"),",
      "context": [
        "        (Regex::new(r\"^prometheus.*query\").unwrap(), \"query_prometheus\"),",
        "        (Regex::new(r\"^grafana.*dashboard\").unwrap(), \"manage_dashboard\"),",
        "        (Regex::new(r\"^tail.*log\").unwrap(), \"tail_logs\"),",
        "        (Regex::new(r\"^journalctl\").unwrap(), \"system_logs\"),",
        "    ];"
      ]
    },
    {
      "file": "src/mcp_manager/fusion/tool_enhancer.rs",
      "line": 79,
      "code": "(Regex::new(r\"^journalctl\").unwrap(), \"system_logs\"),",
      "context": [
        "        (Regex::new(r\"^grafana.*dashboard\").unwrap(), \"manage_dashboard\"),",
        "        (Regex::new(r\"^tail.*log\").unwrap(), \"tail_logs\"),",
        "        (Regex::new(r\"^journalctl\").unwrap(), \"system_logs\"),",
        "    ];",
        "}"
      ]
    },
    {
      "file": "src/mcp_manager/server_types/infrastructure.rs",
      "line": 47,
      "code": "let obj = config.as_object().unwrap();",
      "context": [
        "        }",
        "        ",
        "        let obj = config.as_object().unwrap();",
        "        ",
        "        // Check required fields"
      ]
    },
    {
      "file": "src/mcp_manager/server_types/infrastructure.rs",
      "line": 195,
      "code": "let transformed = handler.transform_request(request).await.unwrap();",
      "context": [
        "        });",
        "        ",
        "        let transformed = handler.transform_request(request).await.unwrap();",
        "        let obj = transformed.as_object().unwrap();",
        "        "
      ]
    },
    {
      "file": "src/mcp_manager/server_types/infrastructure.rs",
      "line": 196,
      "code": "let obj = transformed.as_object().unwrap();",
      "context": [
        "        ",
        "        let transformed = handler.transform_request(request).await.unwrap();",
        "        let obj = transformed.as_object().unwrap();",
        "        ",
        "        assert!(obj.contains_key(\"timestamp\"));"
      ]
    },
    {
      "file": "src/mcp_manager/server_types/infrastructure.rs",
      "line": 211,
      "code": "let transformed = handler.transform_response(response).await.unwrap();",
      "context": [
        "        });",
        "        ",
        "        let transformed = handler.transform_response(response).await.unwrap();",
        "        let obj = transformed.as_object().unwrap();",
        "        "
      ]
    },
    {
      "file": "src/mcp_manager/server_types/infrastructure.rs",
      "line": 212,
      "code": "let obj = transformed.as_object().unwrap();",
      "context": [
        "        ",
        "        let transformed = handler.transform_response(response).await.unwrap();",
        "        let obj = transformed.as_object().unwrap();",
        "        ",
        "        assert_eq!(obj.get(\"standard_status\").unwrap().as_str().unwrap(), \"ok\");"
      ]
    },
    {
      "file": "src/mcp_manager/server_types/infrastructure.rs",
      "line": 214,
      "code": "assert_eq!(obj.get(\"standard_status\").unwrap().as_str().unwrap(), \"ok\");",
      "context": [
        "        let obj = transformed.as_object().unwrap();",
        "        ",
        "        assert_eq!(obj.get(\"standard_status\").unwrap().as_str().unwrap(), \"ok\");",
        "    }",
        "}"
      ]
    },
    {
      "file": "src/mcp_manager/server_types/monitoring.rs",
      "line": 46,
      "code": "let obj = config.as_object().unwrap();",
      "context": [
        "        }",
        "        ",
        "        let obj = config.as_object().unwrap();",
        "        ",
        "        // Check for monitoring-specific fields"
      ]
    },
    {
      "file": "src/mcp_manager/server_types/monitoring.rs",
      "line": 259,
      "code": "let transformed = handler.transform_response(response).await.unwrap();",
      "context": [
        "        });",
        "        ",
        "        let transformed = handler.transform_response(response).await.unwrap();",
        "        let obj = transformed.as_object().unwrap();",
        "        "
      ]
    },
    {
      "file": "src/mcp_manager/server_types/monitoring.rs",
      "line": 260,
      "code": "let obj = transformed.as_object().unwrap();",
      "context": [
        "        ",
        "        let transformed = handler.transform_response(response).await.unwrap();",
        "        let obj = transformed.as_object().unwrap();",
        "        ",
        "        assert!(obj.contains_key(\"standardized_metrics\"));"
      ]
    },
    {
      "file": "src/mcp_manager/server_types/monitoring.rs",
      "line": 263,
      "code": "let std_metrics = obj.get(\"standardized_metrics\").unwrap().as_object().unwrap();",
      "context": [
        "        ",
        "        assert!(obj.contains_key(\"standardized_metrics\"));",
        "        let std_metrics = obj.get(\"standardized_metrics\").unwrap().as_object().unwrap();",
        "        ",
        "        assert!(std_metrics.get(\"cpu\").unwrap().get(\"value\").unwrap().as_f64().unwrap() == 45.5);"
      ]
    },
    {
      "file": "src/mcp_manager/server_types/monitoring.rs",
      "line": 265,
      "code": "assert!(std_metrics.get(\"cpu\").unwrap().get(\"value\").unwrap().as_f64().unwrap() == 45.5);",
      "context": [
        "        let std_metrics = obj.get(\"standardized_metrics\").unwrap().as_object().unwrap();",
        "        ",
        "        assert!(std_metrics.get(\"cpu\").unwrap().get(\"value\").unwrap().as_f64().unwrap() == 45.5);",
        "        assert!(std_metrics.get(\"memory\").unwrap().get(\"value\").unwrap().as_f64().unwrap() == 1024.0);",
        "        assert!(std_metrics.get(\"disk\").unwrap().get(\"value\").unwrap().as_f64().unwrap() == 80.0);"
      ]
    },
    {
      "file": "src/mcp_manager/server_types/monitoring.rs",
      "line": 266,
      "code": "assert!(std_metrics.get(\"memory\").unwrap().get(\"value\").unwrap().as_f64().unwrap() == 1024.0);",
      "context": [
        "        ",
        "        assert!(std_metrics.get(\"cpu\").unwrap().get(\"value\").unwrap().as_f64().unwrap() == 45.5);",
        "        assert!(std_metrics.get(\"memory\").unwrap().get(\"value\").unwrap().as_f64().unwrap() == 1024.0);",
        "        assert!(std_metrics.get(\"disk\").unwrap().get(\"value\").unwrap().as_f64().unwrap() == 80.0);",
        "    }"
      ]
    },
    {
      "file": "src/mcp_manager/server_types/monitoring.rs",
      "line": 267,
      "code": "assert!(std_metrics.get(\"disk\").unwrap().get(\"value\").unwrap().as_f64().unwrap() == 80.0);",
      "context": [
        "        assert!(std_metrics.get(\"cpu\").unwrap().get(\"value\").unwrap().as_f64().unwrap() == 45.5);",
        "        assert!(std_metrics.get(\"memory\").unwrap().get(\"value\").unwrap().as_f64().unwrap() == 1024.0);",
        "        assert!(std_metrics.get(\"disk\").unwrap().get(\"value\").unwrap().as_f64().unwrap() == 80.0);",
        "    }",
        "}"
      ]
    },
    {
      "file": "src/mcp_manager/server_types/security.rs",
      "line": 77,
      "code": "let obj = config.as_object().unwrap();",
      "context": [
        "        }",
        "        ",
        "        let obj = config.as_object().unwrap();",
        "        ",
        "        // Check for security-specific fields"
      ]
    },
    {
      "file": "src/mcp_manager/plugin/registry.rs",
      "line": 526,
      "code": "let id = registry.register(Box::new(plugin)).await.unwrap();",
      "context": [
        "        };",
        "        ",
        "        let id = registry.register(Box::new(plugin)).await.unwrap();",
        "        assert_eq!(id, \"test\");",
        "        "
      ]
    },
    {
      "file": "src/mcp_manager/plugin/version.rs",
      "line": 847,
      "code": "manager.register_version(plugin_id.clone(), info).await.unwrap();",
      "context": [
        "            };",
        "            ",
        "            manager.register_version(plugin_id.clone(), info).await.unwrap();",
        "        }",
        "        "
      ]
    },
    {
      "file": "src/mcp_manager/plugin/version.rs",
      "line": 851,
      "code": "let req = VersionReq::parse(\"^1.0.0\").unwrap();",
      "context": [
        "        ",
        "        // Test resolution",
        "        let req = VersionReq::parse(\"^1.0.0\").unwrap();",
        "        let resolved = manager.resolve_version(&plugin_id, &req).await.unwrap();",
        "        assert_eq!(resolved, Version::parse(\"1.2.0\").unwrap());"
      ]
    },
    {
      "file": "src/mcp_manager/plugin/version.rs",
      "line": 852,
      "code": "let resolved = manager.resolve_version(&plugin_id, &req).await.unwrap();",
      "context": [
        "        // Test resolution",
        "        let req = VersionReq::parse(\"^1.0.0\").unwrap();",
        "        let resolved = manager.resolve_version(&plugin_id, &req).await.unwrap();",
        "        assert_eq!(resolved, Version::parse(\"1.2.0\").unwrap());",
        "        "
      ]
    },
    {
      "file": "src/mcp_manager/plugin/version.rs",
      "line": 853,
      "code": "assert_eq!(resolved, Version::parse(\"1.2.0\").unwrap());",
      "context": [
        "        let req = VersionReq::parse(\"^1.0.0\").unwrap();",
        "        let resolved = manager.resolve_version(&plugin_id, &req).await.unwrap();",
        "        assert_eq!(resolved, Version::parse(\"1.2.0\").unwrap());",
        "        ",
        "        // Test with pre-release"
      ]
    },
    {
      "file": "src/mcp_manager/plugin/version.rs",
      "line": 856,
      "code": "let req = VersionReq::parse(\"^2.0.0\").unwrap();",
      "context": [
        "        ",
        "        // Test with pre-release",
        "        let req = VersionReq::parse(\"^2.0.0\").unwrap();",
        "        let resolved = manager.resolve_version(&plugin_id, &req).await.unwrap();",
        "        assert_eq!(resolved, Version::parse(\"2.0.0\").unwrap());"
      ]
    },
    {
      "file": "src/mcp_manager/plugin/version.rs",
      "line": 857,
      "code": "let resolved = manager.resolve_version(&plugin_id, &req).await.unwrap();",
      "context": [
        "        // Test with pre-release",
        "        let req = VersionReq::parse(\"^2.0.0\").unwrap();",
        "        let resolved = manager.resolve_version(&plugin_id, &req).await.unwrap();",
        "        assert_eq!(resolved, Version::parse(\"2.0.0\").unwrap());",
        "    }"
      ]
    },
    {
      "file": "src/mcp_manager/plugin/version.rs",
      "line": 858,
      "code": "assert_eq!(resolved, Version::parse(\"2.0.0\").unwrap());",
      "context": [
        "        let req = VersionReq::parse(\"^2.0.0\").unwrap();",
        "        let resolved = manager.resolve_version(&plugin_id, &req).await.unwrap();",
        "        assert_eq!(resolved, Version::parse(\"2.0.0\").unwrap());",
        "    }",
        "}"
      ]
    },
    {
      "file": "src/mcp_manager/plugin/negotiation.rs",
      "line": 773,
      "code": "proposals.sort_by(|a, b| b.score.partial_cmp(&a.score).unwrap());",
      "context": [
        "        ",
        "        // Sort by score",
        "        proposals.sort_by(|a, b| b.score.partial_cmp(&a.score).unwrap());",
        "        ",
        "        Ok(proposals)"
      ]
    },
    {
      "file": "src/mcp_manager/plugin/negotiation.rs",
      "line": 994,
      "code": "negotiator.register_plugin(&provider_metadata).await.unwrap();",
      "context": [
        "        };",
        "        ",
        "        negotiator.register_plugin(&provider_metadata).await.unwrap();",
        "        ",
        "        // Start negotiation"
      ]
    },
    {
      "file": "src/mcp_manager/plugin/negotiation.rs",
      "line": 1001,
      "code": "let session_id = negotiator.start_negotiation(\"test-consumer\", required).await.unwrap();",
      "context": [
        "        ];",
        "        ",
        "        let session_id = negotiator.start_negotiation(\"test-consumer\", required).await.unwrap();",
        "        ",
        "        // Wait a bit for negotiation"
      ]
    },
    {
      "file": "src/mcp_manager/plugin/negotiation.rs",
      "line": 1007,
      "code": "let status = negotiator.check_negotiation_status(&session_id).await.unwrap();",
      "context": [
        "        ",
        "        // Check status",
        "        let status = negotiator.check_negotiation_status(&session_id).await.unwrap();",
        "        assert!(matches!(status, NegotiationState::Completed | NegotiationState::Failed));",
        "    }"
      ]
    },
    {
      "file": "src/mcp_manager/plugin/schema.rs",
      "line": 390,
      "code": "serde_json::from_value(schema).unwrap(),",
      "context": [
        "            properties.properties.insert(",
        "                name_str.clone(),",
        "                serde_json::from_value(schema).unwrap(),",
        "            );",
        "        }"
      ]
    },
    {
      "file": "src/mcp_manager/plugin/schema.rs",
      "line": 581,
      "code": "registry.register(schema).unwrap();",
      "context": [
        "            .build();",
        "        ",
        "        registry.register(schema).unwrap();",
        "        ",
        "        // Valid config"
      ]
    },
    {
      "file": "src/mcp_manager/plugin/rollback.rs",
      "line": 763,
      "code": "let strategy = strategies.get(&self.config.default_strategy).unwrap();",
      "context": [
        "        // Validate rollback",
        "        let strategies = self.strategies.read().await;",
        "        let strategy = strategies.get(&self.config.default_strategy).unwrap();",
        "        ",
        "        match strategy.validate_rollback(&source.handle, &target).await {"
      ]
    },
    {
      "file": "src/mcp_manager/plugin/rollback.rs",
      "line": 783,
      "code": "let session = sessions.get_mut(&session_id).unwrap();",
      "context": [
        "        {",
        "            let mut sessions = self.active_rollbacks.lock().await;",
        "            let session = sessions.get_mut(&session_id).unwrap();",
        "            session.state = RollbackState::Preparing;",
        "        }"
      ]
    },
    {
      "file": "src/mcp_manager/plugin/rollback.rs",
      "line": 802,
      "code": "let session = sessions.get_mut(&session_id).unwrap();",
      "context": [
        "        {",
        "            let mut sessions = self.active_rollbacks.lock().await;",
        "            let session = sessions.get_mut(&session_id).unwrap();",
        "            session.state = RollbackState::Executing;",
        "        }"
      ]
    },
    {
      "file": "src/mcp_manager/plugin/rollback.rs",
      "line": 833,
      "code": "let session = sessions.get_mut(&session_id).unwrap();",
      "context": [
        "        {",
        "            let mut sessions = self.active_rollbacks.lock().await;",
        "            let session = sessions.get_mut(&session_id).unwrap();",
        "            session.state = RollbackState::Finalizing;",
        "        }"
      ]
    },
    {
      "file": "src/mcp_manager/plugin/capabilities.rs",
      "line": 616,
      "code": ").await.unwrap();",
      "context": [
        "            \"docker-plugin\".to_string(),",
        "            vec![capability.clone()],",
        "        ).await.unwrap();",
        "        ",
        "        let provider = manager.find_provider(&capability).await.unwrap();"
      ]
    },
    {
      "file": "src/mcp_manager/plugin/capabilities.rs",
      "line": 618,
      "code": "let provider = manager.find_provider(&capability).await.unwrap();",
      "context": [
        "        ).await.unwrap();",
        "        ",
        "        let provider = manager.find_provider(&capability).await.unwrap();",
        "        assert_eq!(provider, Some(\"docker-plugin\".to_string()));",
        "    }"
      ]
    },
    {
      "file": "src/mcp_manager/plugin/mod.rs",
      "line": 402,
      "code": ".unwrap()",
      "context": [
        "        let timestamp = SystemTime::now()",
        "            .duration_since(UNIX_EPOCH)",
        "            .unwrap()",
        "            .as_secs() as i64;",
        "        metrics.last_health_check = Some((timestamp, result.is_ok()));"
      ]
    },
    {
      "file": "src/mcp_manager/plugin/zero_downtime.rs",
      "line": 1153,
      "code": ".unwrap()",
      "context": [
        "                active_instances.iter()",
        "                    .min_by_key(|i| i.metrics.active_connections.load(Ordering::Relaxed))",
        "                    .unwrap()",
        "            }",
        "            RoutingStrategy::LeastResponseTime => {"
      ]
    },
    {
      "file": "src/mcp_manager/plugin/zero_downtime.rs",
      "line": 1158,
      "code": ".unwrap()",
      "context": [
        "                active_instances.iter()",
        "                    .min_by_key(|i| i.metrics.last_response_time_us.load(Ordering::Relaxed))",
        "                    .unwrap()",
        "            }",
        "            _ => active_instances[0],"
      ]
    },
    {
      "file": "src/mcp_manager/plugin/state_transfer.rs",
      "line": 713,
      "code": "let json = serde_json::to_string(&snapshot).unwrap();",
      "context": [
        "        ",
        "        // Serialize",
        "        let json = serde_json::to_string(&snapshot).unwrap();",
        "        ",
        "        // Deserialize"
      ]
    },
    {
      "file": "src/mcp_manager/plugin/state_transfer.rs",
      "line": 716,
      "code": "let restored: StateSnapshot = serde_json::from_str(&json).unwrap();",
      "context": [
        "        ",
        "        // Deserialize",
        "        let restored: StateSnapshot = serde_json::from_str(&json).unwrap();",
        "        ",
        "        assert_eq!(restored.id, snapshot.id);"
      ]
    },
    {
      "file": "src/mcp_manager/optimization/cache.rs",
      "line": 107,
      "code": "let mut storage = self.storage.write().unwrap();",
      "context": [
        "    /// Get a value from the cache",
        "    pub async fn get(&self, key: &K) -> Option<V> {",
        "        let mut storage = self.storage.write().unwrap();",
        "        ",
        "        if let Some(entry) = storage.get_mut(key) {"
      ]
    },
    {
      "file": "src/mcp_manager/optimization/cache.rs",
      "line": 116,
      "code": "self.stats.write().unwrap().expirations += 1;",
      "context": [
        "                    storage.remove(key);",
        "                    self.remove_from_tracking(key).await;",
        "                    self.stats.write().unwrap().expirations += 1;",
        "                    self.stats.write().unwrap().misses += 1;",
        "                    return None;"
      ]
    },
    {
      "file": "src/mcp_manager/optimization/cache.rs",
      "line": 117,
      "code": "self.stats.write().unwrap().misses += 1;",
      "context": [
        "                    self.remove_from_tracking(key).await;",
        "                    self.stats.write().unwrap().expirations += 1;",
        "                    self.stats.write().unwrap().misses += 1;",
        "                    return None;",
        "                }"
      ]
    },
    {
      "file": "src/mcp_manager/optimization/cache.rs",
      "line": 129,
      "code": "self.stats.write().unwrap().hits += 1;",
      "context": [
        "            self.update_access_tracking(key.clone()).await;",
        "            ",
        "            self.stats.write().unwrap().hits += 1;",
        "            Some(entry.value.clone())",
        "        } else {"
      ]
    },
    {
      "file": "src/mcp_manager/optimization/cache.rs",
      "line": 132,
      "code": "self.stats.write().unwrap().misses += 1;",
      "context": [
        "            Some(entry.value.clone())",
        "        } else {",
        "            self.stats.write().unwrap().misses += 1;",
        "            None",
        "        }"
      ]
    },
    {
      "file": "src/mcp_manager/optimization/cache.rs",
      "line": 165,
      "code": "let mut storage = self.storage.write().unwrap();",
      "context": [
        "        ",
        "        // Update storage",
        "        let mut storage = self.storage.write().unwrap();",
        "        let old_entry = storage.insert(key.clone(), entry);",
        "        "
      ]
    },
    {
      "file": "src/mcp_manager/optimization/cache.rs",
      "line": 169,
      "code": "let mut stats = self.stats.write().unwrap();",
      "context": [
        "        ",
        "        // Update stats",
        "        let mut stats = self.stats.write().unwrap();",
        "        stats.entry_count = storage.len();",
        "        stats.total_size += size;"
      ]
    },
    {
      "file": "src/mcp_manager/optimization/cache.rs",
      "line": 186,
      "code": "let mut storage = self.storage.write().unwrap();",
      "context": [
        "    /// Remove a value from the cache",
        "    pub async fn remove(&self, key: &K) -> Option<V> {",
        "        let mut storage = self.storage.write().unwrap();",
        "        ",
        "        if let Some(entry) = storage.remove(key) {"
      ]
    },
    {
      "file": "src/mcp_manager/optimization/cache.rs",
      "line": 189,
      "code": "self.stats.write().unwrap().total_size -= entry.size;",
      "context": [
        "        ",
        "        if let Some(entry) = storage.remove(key) {",
        "            self.stats.write().unwrap().total_size -= entry.size;",
        "            self.stats.write().unwrap().entry_count -= 1;",
        "            "
      ]
    },
    {
      "file": "src/mcp_manager/optimization/cache.rs",
      "line": 190,
      "code": "self.stats.write().unwrap().entry_count -= 1;",
      "context": [
        "        if let Some(entry) = storage.remove(key) {",
        "            self.stats.write().unwrap().total_size -= entry.size;",
        "            self.stats.write().unwrap().entry_count -= 1;",
        "            ",
        "            drop(storage);"
      ]
    },
    {
      "file": "src/mcp_manager/optimization/cache.rs",
      "line": 203,
      "code": "self.storage.write().unwrap().clear();",
      "context": [
        "    /// Clear the cache",
        "    pub async fn clear(&self) {",
        "        self.storage.write().unwrap().clear();",
        "        self.lru_queue.lock().await.clear();",
        "        self.frequency_map.write().unwrap().clear();"
      ]
    },
    {
      "file": "src/mcp_manager/optimization/cache.rs",
      "line": 205,
      "code": "self.frequency_map.write().unwrap().clear();",
      "context": [
        "        self.storage.write().unwrap().clear();",
        "        self.lru_queue.lock().await.clear();",
        "        self.frequency_map.write().unwrap().clear();",
        "        self.fifo_queue.lock().await.clear();",
        "        "
      ]
    },
    {
      "file": "src/mcp_manager/optimization/cache.rs",
      "line": 208,
      "code": "let mut stats = self.stats.write().unwrap();",
      "context": [
        "        self.fifo_queue.lock().await.clear();",
        "        ",
        "        let mut stats = self.stats.write().unwrap();",
        "        stats.total_size = 0;",
        "        stats.entry_count = 0;"
      ]
    },
    {
      "file": "src/mcp_manager/optimization/cache.rs",
      "line": 215,
      "code": "let stats = self.stats.read().unwrap();",
      "context": [
        "    /// Check if eviction is needed",
        "    async fn needs_eviction(&self, additional_size: usize) -> bool {",
        "        let stats = self.stats.read().unwrap();",
        "        ",
        "        stats.entry_count >= self.max_entries ||"
      ]
    },
    {
      "file": "src/mcp_manager/optimization/cache.rs",
      "line": 233,
      "code": "self.stats.write().unwrap().evictions += 1;",
      "context": [
        "        if let Some(key) = key_to_evict {",
        "            self.remove(&key).await;",
        "            self.stats.write().unwrap().evictions += 1;",
        "        }",
        "        "
      ]
    },
    {
      "file": "src/mcp_manager/optimization/cache.rs",
      "line": 247,
      "code": "let frequency_map = self.frequency_map.read().unwrap();",
      "context": [
        "    /// Evict using LFU policy",
        "    async fn evict_lfu(&self) -> Result<Option<K>> {",
        "        let frequency_map = self.frequency_map.read().unwrap();",
        "        ",
        "        frequency_map.iter()"
      ]
    },
    {
      "file": "src/mcp_manager/optimization/cache.rs",
      "line": 264,
      "code": "let storage = self.storage.read().unwrap();",
      "context": [
        "    /// Evict random entry",
        "    async fn evict_random(&self) -> Result<Option<K>> {",
        "        let storage = self.storage.read().unwrap();",
        "        let keys: Vec<_> = storage.keys().cloned().collect();",
        "        "
      ]
    },
    {
      "file": "src/mcp_manager/optimization/cache.rs",
      "line": 278,
      "code": "let storage = self.storage.read().unwrap();",
      "context": [
        "    /// Evict oldest entry",
        "    async fn evict_oldest(&self) -> Result<Option<K>> {",
        "        let storage = self.storage.read().unwrap();",
        "        ",
        "        storage.iter()"
      ]
    },
    {
      "file": "src/mcp_manager/optimization/cache.rs",
      "line": 296,
      "code": "let mut freq_map = self.frequency_map.write().unwrap();",
      "context": [
        "            }",
        "            EvictionPolicy::LFU => {",
        "                let mut freq_map = self.frequency_map.write().unwrap();",
        "                *freq_map.entry(key).or_insert(0) += 1;",
        "            }"
      ]
    },
    {
      "file": "src/mcp_manager/optimization/cache.rs",
      "line": 310,
      "code": "self.frequency_map.write().unwrap().insert(key, 1);",
      "context": [
        "            }",
        "            EvictionPolicy::LFU => {",
        "                self.frequency_map.write().unwrap().insert(key, 1);",
        "            }",
        "            EvictionPolicy::FIFO => {"
      ]
    },
    {
      "file": "src/mcp_manager/optimization/cache.rs",
      "line": 326,
      "code": "self.frequency_map.write().unwrap().remove(key);",
      "context": [
        "            }",
        "            EvictionPolicy::LFU => {",
        "                self.frequency_map.write().unwrap().remove(key);",
        "            }",
        "            EvictionPolicy::FIFO => {"
      ]
    },
    {
      "file": "src/mcp_manager/optimization/cache.rs",
      "line": 350,
      "code": "let storage_map = storage.read().unwrap();",
      "context": [
        "                ",
        "                {",
        "                    let storage_map = storage.read().unwrap();",
        "                    for (key, entry) in storage_map.iter() {",
        "                        if let Some(ttl) = entry.ttl {"
      ]
    },
    {
      "file": "src/mcp_manager/optimization/cache.rs",
      "line": 361,
      "code": "let mut storage_map = storage.write().unwrap();",
      "context": [
        "                ",
        "                if !expired_keys.is_empty() {",
        "                    let mut storage_map = storage.write().unwrap();",
        "                    let mut stats_mut = stats.write().unwrap();",
        "                    "
      ]
    },
    {
      "file": "src/mcp_manager/optimization/cache.rs",
      "line": 362,
      "code": "let mut stats_mut = stats.write().unwrap();",
      "context": [
        "                if !expired_keys.is_empty() {",
        "                    let mut storage_map = storage.write().unwrap();",
        "                    let mut stats_mut = stats.write().unwrap();",
        "                    ",
        "                    for key in expired_keys {"
      ]
    },
    {
      "file": "src/mcp_manager/optimization/cache.rs",
      "line": 378,
      "code": "self.stats.read().unwrap().clone()",
      "context": [
        "    /// Get cache statistics",
        "    pub fn get_stats(&self) -> CacheStats {",
        "        self.stats.read().unwrap().clone()",
        "    }",
        "    "
      ]
    },
    {
      "file": "src/mcp_manager/optimization/cache.rs",
      "line": 383,
      "code": "let stats = self.stats.read().unwrap();",
      "context": [
        "    /// Get cache hit rate",
        "    pub fn get_hit_rate(&self) -> f64 {",
        "        let stats = self.stats.read().unwrap();",
        "        let total = stats.hits + stats.misses;",
        "        "
      ]
    },
    {
      "file": "src/mcp_manager/optimization/cache.rs",
      "line": 395,
      "code": "self.stats.read().unwrap().total_size",
      "context": [
        "    /// Get current size",
        "    pub fn get_size(&self) -> usize {",
        "        self.stats.read().unwrap().total_size",
        "    }",
        "    "
      ]
    },
    {
      "file": "src/mcp_manager/optimization/cache.rs",
      "line": 400,
      "code": "self.stats.read().unwrap().entry_count",
      "context": [
        "    /// Get entry count",
        "    pub fn get_entry_count(&self) -> usize {",
        "        self.stats.read().unwrap().entry_count",
        "    }",
        "}"
      ]
    },
    {
      "file": "src/mcp_manager/optimization/cache.rs",
      "line": 512,
      "code": ").await.unwrap();",
      "context": [
        "            10,",
        "            Some(Duration::from_millis(100))",
        "        ).await.unwrap();",
        "        ",
        "        // Should exist immediately"
      ]
    },
    {
      "file": "src/mcp_manager/optimization/cache.rs",
      "line": 531,
      "code": "cache.put(\"hit\".to_string(), 1, 10).await.unwrap();",
      "context": [
        "        let cache = AdvancedCache::new(100, 10, EvictionPolicy::LRU, None);",
        "        ",
        "        cache.put(\"hit\".to_string(), 1, 10).await.unwrap();",
        "        ",
        "        // Generate hits"
      ]
    },
    {
      "file": "src/mcp_manager/optimization/cache.rs",
      "line": 560,
      "code": "multi_cache.put(\"key\".to_string(), \"value\", 10).await.unwrap();",
      "context": [
        "        ",
        "        // Put in L1",
        "        multi_cache.put(\"key\".to_string(), \"value\", 10).await.unwrap();",
        "        ",
        "        // Get should find in L1"
      ]
    },
    {
      "file": "src/mcp_manager/optimization/prefetch.rs",
      "line": 180,
      "code": "self.stats.write().unwrap().predictions_made += 1;",
      "context": [
        "            if request.confidence >= self.prefetch_threshold {",
        "                let _ = self.prefetch_tx.send(request).await;",
        "                self.stats.write().unwrap().predictions_made += 1;",
        "            }",
        "        }"
      ]
    },
    {
      "file": "src/mcp_manager/optimization/prefetch.rs",
      "line": 187,
      "code": "let sequential_state = self.sequential_state.read().unwrap();",
      "context": [
        "    /// Sequential prediction",
        "    async fn predict_sequential(&self, pattern: &AccessPattern) -> Result<PrefetchRequest> {",
        "        let sequential_state = self.sequential_state.read().unwrap();",
        "        ",
        "        if let Some(sequence) = sequential_state.get(&pattern.key) {"
      ]
    },
    {
      "file": "src/mcp_manager/optimization/prefetch.rs",
      "line": 208,
      "code": "let temporal_patterns = self.temporal_patterns.read().unwrap();",
      "context": [
        "    /// Temporal prediction",
        "    async fn predict_temporal(&self, pattern: &AccessPattern) -> Result<PrefetchRequest> {",
        "        let temporal_patterns = self.temporal_patterns.read().unwrap();",
        "        ",
        "        // Find keys accessed around the same time"
      ]
    },
    {
      "file": "src/mcp_manager/optimization/prefetch.rs",
      "line": 242,
      "code": "let spatial_map = self.spatial_map.read().unwrap();",
      "context": [
        "    /// Spatial prediction",
        "    async fn predict_spatial(&self, pattern: &AccessPattern) -> Result<PrefetchRequest> {",
        "        let spatial_map = self.spatial_map.read().unwrap();",
        "        ",
        "        if let Some(neighbors) = spatial_map.get(&pattern.key) {"
      ]
    },
    {
      "file": "src/mcp_manager/optimization/prefetch.rs",
      "line": 263,
      "code": "let model = self.markov_model.read().unwrap();",
      "context": [
        "    /// Markov chain prediction",
        "    async fn predict_markov(&self, pattern: &AccessPattern) -> Result<PrefetchRequest> {",
        "        let model = self.markov_model.read().unwrap();",
        "        ",
        "        if let Some(transitions) = model.transitions.get(&pattern.key) {"
      ]
    },
    {
      "file": "src/mcp_manager/optimization/prefetch.rs",
      "line": 268,
      "code": "predictions.sort_by(|a, b| b.1.partial_cmp(a.1).unwrap());",
      "context": [
        "            // Get top predictions by probability",
        "            let mut predictions: Vec<_> = transitions.iter().collect();",
        "            predictions.sort_by(|a, b| b.1.partial_cmp(a.1).unwrap());",
        "            ",
        "            let keys: Vec<String> = predictions.iter()"
      ]
    },
    {
      "file": "src/mcp_manager/optimization/prefetch.rs",
      "line": 298,
      "code": "let model = self.neural_model.read().unwrap();",
      "context": [
        "    /// Neural network prediction",
        "    async fn predict_neural(&self, pattern: &AccessPattern) -> Result<PrefetchRequest> {",
        "        let model = self.neural_model.read().unwrap();",
        "        ",
        "        // Simplified neural prediction"
      ]
    },
    {
      "file": "src/mcp_manager/optimization/prefetch.rs",
      "line": 308,
      "code": "indexed_predictions.sort_by(|a, b| b.1.partial_cmp(a.1).unwrap());",
      "context": [
        "            .enumerate()",
        "            .collect();",
        "        indexed_predictions.sort_by(|a, b| b.1.partial_cmp(a.1).unwrap());",
        "        ",
        "        let keys: Vec<String> = indexed_predictions.iter()"
      ]
    },
    {
      "file": "src/mcp_manager/optimization/prefetch.rs",
      "line": 367,
      "code": "sorted_predictions.sort_by(|a, b| b.1.partial_cmp(&a.1).unwrap());",
      "context": [
        "        // Sort by combined confidence",
        "        let mut sorted_predictions: Vec<_> = all_predictions.into_iter().collect();",
        "        sorted_predictions.sort_by(|a, b| b.1.partial_cmp(&a.1).unwrap());",
        "        ",
        "        let keys: Vec<String> = sorted_predictions.iter()"
      ]
    },
    {
      "file": "src/mcp_manager/optimization/prefetch.rs",
      "line": 480,
      "code": "*sequential_state.write().unwrap() = sequences;",
      "context": [
        "                    }",
        "                }",
        "                *sequential_state.write().unwrap() = sequences;",
        "                ",
        "                // Analyze temporal patterns"
      ]
    },
    {
      "file": "src/mcp_manager/optimization/prefetch.rs",
      "line": 493,
      "code": "*temporal_patterns.write().unwrap() = temporal;",
      "context": [
        "                    }",
        "                }",
        "                *temporal_patterns.write().unwrap() = temporal;",
        "                ",
        "                // Analyze spatial patterns (simplified - based on common context)"
      ]
    },
    {
      "file": "src/mcp_manager/optimization/prefetch.rs",
      "line": 512,
      "code": "*spatial_map.write().unwrap() = spatial;",
      "context": [
        "                    }",
        "                }",
        "                *spatial_map.write().unwrap() = spatial;",
        "                ",
        "                // Update Markov model"
      ]
    },
    {
      "file": "src/mcp_manager/optimization/prefetch.rs",
      "line": 515,
      "code": "let mut model = markov_model.write().unwrap();",
      "context": [
        "                ",
        "                // Update Markov model",
        "                let mut model = markov_model.write().unwrap();",
        "                model.transitions.clear();",
        "                model.state_counts.clear();"
      ]
    },
    {
      "file": "src/mcp_manager/optimization/prefetch.rs",
      "line": 564,
      "code": "stats.write().unwrap().total_prefetched += request.keys.len();",
      "context": [
        "                ",
        "                // Update stats",
        "                stats.write().unwrap().total_prefetched += request.keys.len();",
        "            }",
        "        })"
      ]
    },
    {
      "file": "src/mcp_manager/optimization/prefetch.rs",
      "line": 588,
      "code": "let mut model = neural_model.write().unwrap();",
      "context": [
        "                // Train on recent patterns",
        "                // In real implementation, this would use proper backpropagation",
        "                let mut model = neural_model.write().unwrap();",
        "                ",
        "                let history_vec: Vec<_> = history.iter().cloned().collect();"
      ]
    },
    {
      "file": "src/mcp_manager/optimization/prefetch.rs",
      "line": 623,
      "code": "let mut stats = self.stats.write().unwrap();",
      "context": [
        "    /// Update statistics with actual access",
        "    pub fn update_stats(&self, key: &str, was_prefetched: bool) {",
        "        let mut stats = self.stats.write().unwrap();",
        "        ",
        "        if was_prefetched {"
      ]
    },
    {
      "file": "src/mcp_manager/optimization/prefetch.rs",
      "line": 643,
      "code": "self.stats.read().unwrap().clone()",
      "context": [
        "    /// Get statistics",
        "    pub fn get_stats(&self) -> PrefetchStats {",
        "        self.stats.read().unwrap().clone()",
        "    }",
        "}"
      ]
    },
    {
      "file": "src/mcp_manager/optimization/prefetch.rs",
      "line": 671,
      "code": "let sequential_state = prefetcher.sequential_state.read().unwrap();",
      "context": [
        "        ",
        "        // Check if patterns were learned",
        "        let sequential_state = prefetcher.sequential_state.read().unwrap();",
        "        assert!(!sequential_state.is_empty());",
        "    }"
      ]
    },
    {
      "file": "src/mcp_manager/optimization/prefetch.rs",
      "line": 696,
      "code": "let model = prefetcher.markov_model.read().unwrap();",
      "context": [
        "        ",
        "        // Check Markov model",
        "        let model = prefetcher.markov_model.read().unwrap();",
        "        assert!(!model.transitions.is_empty());",
        "        "
      ]
    },
    {
      "file": "src/mcp_manager/resilience/chaos.rs",
      "line": 184,
      "code": "if *self.safety_enabled.read().unwrap() {",
      "context": [
        "        ",
        "        // Check safety",
        "        if *self.safety_enabled.read().unwrap() {",
        "            self.check_safety(&config)?;",
        "        }"
      ]
    },
    {
      "file": "src/mcp_manager/resilience/chaos.rs",
      "line": 203,
      "code": "self.experiments.write().unwrap().insert(id.clone(), result);",
      "context": [
        "        };",
        "        ",
        "        self.experiments.write().unwrap().insert(id.clone(), result);",
        "        ",
        "        // Queue experiment"
      ]
    },
    {
      "file": "src/mcp_manager/resilience/chaos.rs",
      "line": 220,
      "code": "self.service_hooks.write().unwrap().insert(service, hook);",
      "context": [
        "    /// Register a service hook",
        "    pub fn register_service_hook(&self, service: String, hook: Box<dyn ServiceHook>) {",
        "        self.service_hooks.write().unwrap().insert(service, hook);",
        "    }",
        "    "
      ]
    },
    {
      "file": "src/mcp_manager/resilience/chaos.rs",
      "line": 273,
      "code": "let experiment_id = experiments.read().unwrap()",
      "context": [
        "        service_hooks: Arc<RwLock<HashMap<String, Box<dyn ServiceHook>>>>,",
        "    ) -> ExperimentResult {",
        "        let experiment_id = experiments.read().unwrap()",
        "            .values()",
        "            .find(|e| e.experiment_type == config.experiment_type && "
      ]
    },
    {
      "file": "src/mcp_manager/resilience/chaos.rs",
      "line": 281,
      "code": "if let Some(result) = experiments.write().unwrap().get_mut(&experiment_id) {",
      "context": [
        "        ",
        "        // Update status to running",
        "        if let Some(result) = experiments.write().unwrap().get_mut(&experiment_id) {",
        "            result.status = ExperimentStatus::Running;",
        "            result.start_time = Instant::now();"
      ]
    },
    {
      "file": "src/mcp_manager/resilience/chaos.rs",
      "line": 292,
      "code": "if let Some(hook) = service_hooks.read().unwrap().get(&config.target) {",
      "context": [
        "        match config.experiment_type {",
        "            ExperimentType::NetworkLatency => {",
        "                if let Some(hook) = service_hooks.read().unwrap().get(&config.target) {",
        "                    let latency = Duration::from_millis((config.intensity * 1000.0) as u64);",
        "                    if let Err(e) = hook.inject_latency(latency) {"
      ]
    },
    {
      "file": "src/mcp_manager/resilience/chaos.rs",
      "line": 301,
      "code": "if let Some(hook) = service_hooks.read().unwrap().get(&config.target) {",
      "context": [
        "            }",
        "            ExperimentType::ServiceCrash => {",
        "                if let Some(hook) = service_hooks.read().unwrap().get(&config.target) {",
        "                    if let Err(e) = hook.kill_service() {",
        "                        errors.push(format!(\"Failed to kill service: {}\", e));"
      ]
    },
    {
      "file": "src/mcp_manager/resilience/chaos.rs",
      "line": 309,
      "code": "if let Some(hook) = service_hooks.read().unwrap().get(&config.target) {",
      "context": [
        "            }",
        "            ExperimentType::PacketLoss => {",
        "                if let Some(hook) = service_hooks.read().unwrap().get(&config.target) {",
        "                    if let Err(e) = hook.inject_error(config.intensity) {",
        "                        errors.push(format!(\"Failed to inject packet loss: {}\", e));"
      ]
    },
    {
      "file": "src/mcp_manager/resilience/chaos.rs",
      "line": 317,
      "code": "if let Some(hook) = service_hooks.read().unwrap().get(&config.target) {",
      "context": [
        "            }",
        "            ExperimentType::CPUSpike => {",
        "                if let Some(hook) = service_hooks.read().unwrap().get(&config.target) {",
        "                    let cpu_limit = 1.0 - config.intensity; // High intensity = low CPU limit",
        "                    if let Err(e) = hook.inject_resource_limit(cpu_limit, 1.0) {"
      ]
    },
    {
      "file": "src/mcp_manager/resilience/chaos.rs",
      "line": 326,
      "code": "if let Some(hook) = service_hooks.read().unwrap().get(&config.target) {",
      "context": [
        "            }",
        "            ExperimentType::MemoryLeak => {",
        "                if let Some(hook) = service_hooks.read().unwrap().get(&config.target) {",
        "                    let memory_limit = 1.0 - config.intensity;",
        "                    if let Err(e) = hook.inject_resource_limit(1.0, memory_limit) {"
      ]
    },
    {
      "file": "src/mcp_manager/resilience/chaos.rs",
      "line": 335,
      "code": "if let Some(hook) = service_hooks.read().unwrap().get(&config.target) {",
      "context": [
        "            }",
        "            ExperimentType::NetworkPartition => {",
        "                if let Some(hook) = service_hooks.read().unwrap().get(&config.target) {",
        "                    if let Some(partition_target) = config.params.get(\"partition_target\") {",
        "                        if let Err(e) = hook.partition_network(partition_target) {"
      ]
    },
    {
      "file": "src/mcp_manager/resilience/chaos.rs",
      "line": 354,
      "code": "if let Some(result) = experiments.write().unwrap().get_mut(&experiment_id) {",
      "context": [
        "        // Update final result",
        "        let end_time = Instant::now();",
        "        if let Some(result) = experiments.write().unwrap().get_mut(&experiment_id) {",
        "            result.end_time = Some(end_time);",
        "            result.status = if errors.is_empty() {"
      ]
    },
    {
      "file": "src/mcp_manager/resilience/chaos.rs",
      "line": 395,
      "code": "if !*safety_enabled.read().unwrap() {",
      "context": [
        "                interval.tick().await;",
        "                ",
        "                if !*safety_enabled.read().unwrap() {",
        "                    continue;",
        "                }"
      ]
    },
    {
      "file": "src/mcp_manager/resilience/chaos.rs",
      "line": 399,
      "code": "let baseline = baseline_metrics.read().unwrap();",
      "context": [
        "                }",
        "                ",
        "                let baseline = baseline_metrics.read().unwrap();",
        "                let current = current_metrics.read().unwrap();",
        "                "
      ]
    },
    {
      "file": "src/mcp_manager/resilience/chaos.rs",
      "line": 400,
      "code": "let current = current_metrics.read().unwrap();",
      "context": [
        "                ",
        "                let baseline = baseline_metrics.read().unwrap();",
        "                let current = current_metrics.read().unwrap();",
        "                ",
        "                // Check for excessive degradation"
      ]
    },
    {
      "file": "src/mcp_manager/resilience/chaos.rs",
      "line": 411,
      "code": "let running_experiments: Vec<String> = experiments.read().unwrap()",
      "context": [
        "                   latency_increase > max_degradation {",
        "                    // Abort all running experiments",
        "                    let running_experiments: Vec<String> = experiments.read().unwrap()",
        "                        .iter()",
        "                        .filter(|(_, e)| e.status == ExperimentStatus::Running)"
      ]
    },
    {
      "file": "src/mcp_manager/resilience/chaos.rs",
      "line": 437,
      "code": "let mut metrics = current_metrics.write().unwrap();",
      "context": [
        "                // In real implementation, collect actual metrics",
        "                // For now, simulate metric collection",
        "                let mut metrics = current_metrics.write().unwrap();",
        "                ",
        "                // Add some random variation"
      ]
    },
    {
      "file": "src/mcp_manager/resilience/chaos.rs",
      "line": 462,
      "code": "if let Some(result) = experiments.write().unwrap().get_mut(&experiment_id) {",
      "context": [
        "            ",
        "            while let Some(experiment_id) = rx.recv().await {",
        "                if let Some(result) = experiments.write().unwrap().get_mut(&experiment_id) {",
        "                    if result.status == ExperimentStatus::Running {",
        "                        result.status = ExperimentStatus::Aborted;"
      ]
    },
    {
      "file": "src/mcp_manager/resilience/chaos.rs",
      "line": 492,
      "code": "let experiments = self.experiments.read().unwrap();",
      "context": [
        "    /// Check safety constraints",
        "    fn check_safety(&self, config: &ExperimentConfig) -> Result<()> {",
        "        let experiments = self.experiments.read().unwrap();",
        "        ",
        "        // Check for concurrent experiments on same target"
      ]
    },
    {
      "file": "src/mcp_manager/resilience/chaos.rs",
      "line": 527,
      "code": "self.experiments.read().unwrap().get(experiment_id).cloned()",
      "context": [
        "    /// Get experiment results",
        "    pub fn get_experiment_results(&self, experiment_id: &str) -> Option<ExperimentResult> {",
        "        self.experiments.read().unwrap().get(experiment_id).cloned()",
        "    }",
        "    "
      ]
    },
    {
      "file": "src/mcp_manager/resilience/chaos.rs",
      "line": 532,
      "code": "self.experiments.read().unwrap().values().cloned().collect()",
      "context": [
        "    /// Get all experiments",
        "    pub fn get_all_experiments(&self) -> Vec<ExperimentResult> {",
        "        self.experiments.read().unwrap().values().cloned().collect()",
        "    }",
        "    "
      ]
    },
    {
      "file": "src/mcp_manager/resilience/chaos.rs",
      "line": 537,
      "code": "self.current_metrics.read().unwrap().clone()",
      "context": [
        "    /// Get current metrics",
        "    pub fn get_current_metrics(&self) -> SystemMetrics {",
        "        self.current_metrics.read().unwrap().clone()",
        "    }",
        "    "
      ]
    },
    {
      "file": "src/mcp_manager/resilience/chaos.rs",
      "line": 542,
      "code": "let current = self.current_metrics.read().unwrap().clone();",
      "context": [
        "    /// Update baseline metrics",
        "    pub fn update_baseline_metrics(&self) {",
        "        let current = self.current_metrics.read().unwrap().clone();",
        "        *self.baseline_metrics.write().unwrap() = current;",
        "    }"
      ]
    },
    {
      "file": "src/mcp_manager/resilience/chaos.rs",
      "line": 543,
      "code": "*self.baseline_metrics.write().unwrap() = current;",
      "context": [
        "    pub fn update_baseline_metrics(&self) {",
        "        let current = self.current_metrics.read().unwrap().clone();",
        "        *self.baseline_metrics.write().unwrap() = current;",
        "    }",
        "    "
      ]
    },
    {
      "file": "src/mcp_manager/resilience/chaos.rs",
      "line": 548,
      "code": "*self.safety_enabled.write().unwrap() = enabled;",
      "context": [
        "    /// Enable/disable safety checks",
        "    pub fn set_safety_enabled(&self, enabled: bool) {",
        "        *self.safety_enabled.write().unwrap() = enabled;",
        "    }",
        "}"
      ]
    },
    {
      "file": "src/mcp_manager/resilience/chaos.rs",
      "line": 603,
      "code": "let id = chaos.schedule_experiment(config).await.unwrap();",
      "context": [
        "        };",
        "        ",
        "        let id = chaos.schedule_experiment(config).await.unwrap();",
        "        assert!(!id.is_empty());",
        "        "
      ]
    },
    {
      "file": "src/mcp_manager/distributed/failover.rs",
      "line": 248,
      "code": "healthy_backups.choose(&mut rand::thread_rng()).unwrap()",
      "context": [
        "                // Random selection for load distribution",
        "                use rand::seq::SliceRandom;",
        "                healthy_backups.choose(&mut rand::thread_rng()).unwrap()",
        "            }",
        "            FailoverStrategy::PriorityBased => {"
      ]
    },
    {
      "file": "src/mcp_manager/distributed/failover.rs",
      "line": 254,
      "code": ".unwrap()",
      "context": [
        "                healthy_backups.iter()",
        "                    .max_by_key(|s| s.priority())",
        "                    .unwrap()",
        "            }",
        "            FailoverStrategy::Geographic => {"
      ]
    },
    {
      "file": "src/mcp_manager/distributed/failover.rs",
      "line": 379,
      "code": "let backup_id = manager.handle_failure(\"primary-1\").await.unwrap();",
      "context": [
        "        ",
        "        // Test failover",
        "        let backup_id = manager.handle_failure(\"primary-1\").await.unwrap();",
        "        assert_eq!(backup_id, \"backup-1\");",
        "        "
      ]
    },
    {
      "file": "src/mcp_manager/distributed/failover.rs",
      "line": 398,
      "code": "let backup_id = manager.handle_failure(\"primary-1\").await.unwrap();",
      "context": [
        "        ",
        "        // Should select backup-2 (highest priority)",
        "        let backup_id = manager.handle_failure(\"primary-1\").await.unwrap();",
        "        assert_eq!(backup_id, \"backup-2\");",
        "    }"
      ]
    },
    {
      "file": "src/mcp_manager/distributed/failover.rs",
      "line": 413,
      "code": "manager.handle_failure(\"primary-1\").await.unwrap();",
      "context": [
        "        ",
        "        // Perform failover",
        "        manager.handle_failure(\"primary-1\").await.unwrap();",
        "        ",
        "        // Check history"
      ]
    },
    {
      "file": "src/mcp_manager/distributed/failover.rs",
      "line": 421,
      "code": ".unwrap();",
      "context": [
        "        let failure_event = history.iter()",
        "            .find(|e| e.event_type == FailoverEventType::FailureDetected)",
        "            .unwrap();",
        "        assert_eq!(failure_event.source, \"primary-1\");",
        "    }"
      ]
    },
    {
      "file": "src/mcp_manager/distributed/load_balancer.rs",
      "line": 338,
      "code": "let server1 = lb.select_server(\"test-pool\", None).await.unwrap();",
      "context": [
        "        ",
        "        // Test round-robin selection",
        "        let server1 = lb.select_server(\"test-pool\", None).await.unwrap();",
        "        let server2 = lb.select_server(\"test-pool\", None).await.unwrap();",
        "        "
      ]
    },
    {
      "file": "src/mcp_manager/distributed/load_balancer.rs",
      "line": 339,
      "code": "let server2 = lb.select_server(\"test-pool\", None).await.unwrap();",
      "context": [
        "        // Test round-robin selection",
        "        let server1 = lb.select_server(\"test-pool\", None).await.unwrap();",
        "        let server2 = lb.select_server(\"test-pool\", None).await.unwrap();",
        "        ",
        "        assert_ne!(server1.id(), server2.id());"
      ]
    },
    {
      "file": "src/mcp_manager/distributed/load_balancer.rs",
      "line": 355,
      "code": "lb.update_connections(\"test-pool\", \"server-0\", 5).await.unwrap();",
      "context": [
        "        ",
        "        // Update connections",
        "        lb.update_connections(\"test-pool\", \"server-0\", 5).await.unwrap();",
        "        lb.update_connections(\"test-pool\", \"server-1\", 2).await.unwrap();",
        "        "
      ]
    },
    {
      "file": "src/mcp_manager/distributed/load_balancer.rs",
      "line": 356,
      "code": "lb.update_connections(\"test-pool\", \"server-1\", 2).await.unwrap();",
      "context": [
        "        // Update connections",
        "        lb.update_connections(\"test-pool\", \"server-0\", 5).await.unwrap();",
        "        lb.update_connections(\"test-pool\", \"server-1\", 2).await.unwrap();",
        "        ",
        "        // Should select server-2 (0 connections)"
      ]
    },
    {
      "file": "src/mcp_manager/distributed/load_balancer.rs",
      "line": 359,
      "code": "let server = lb.select_server(\"test-pool\", None).await.unwrap();",
      "context": [
        "        ",
        "        // Should select server-2 (0 connections)",
        "        let server = lb.select_server(\"test-pool\", None).await.unwrap();",
        "        assert_eq!(server.id(), \"server-2\");",
        "    }"
      ]
    },
    {
      "file": "src/mcp_manager/distributed/load_balancer.rs",
      "line": 374,
      "code": "let server1 = lb.select_server(\"test-pool\", Some(\"192.168.1.1\")).await.unwrap();",
      "context": [
        "        ",
        "        // Same IP should always get same server",
        "        let server1 = lb.select_server(\"test-pool\", Some(\"192.168.1.1\")).await.unwrap();",
        "        let server2 = lb.select_server(\"test-pool\", Some(\"192.168.1.1\")).await.unwrap();",
        "        "
      ]
    },
    {
      "file": "src/mcp_manager/distributed/load_balancer.rs",
      "line": 375,
      "code": "let server2 = lb.select_server(\"test-pool\", Some(\"192.168.1.1\")).await.unwrap();",
      "context": [
        "        // Same IP should always get same server",
        "        let server1 = lb.select_server(\"test-pool\", Some(\"192.168.1.1\")).await.unwrap();",
        "        let server2 = lb.select_server(\"test-pool\", Some(\"192.168.1.1\")).await.unwrap();",
        "        ",
        "        assert_eq!(server1.id(), server2.id());"
      ]
    },
    {
      "file": "src/synthex_bashgod/synergy/optimizer.rs",
      "line": 695,
      "code": "let result = optimizer.optimize(commands, vec![synergy], &context).await.unwrap();",
      "context": [
        "        };",
        "        ",
        "        let result = optimizer.optimize(commands, vec![synergy], &context).await.unwrap();",
        "        ",
        "        assert!(result.success);"
      ]
    },
    {
      "file": "src/synthex_bashgod/synergy/detector.rs",
      "line": 693,
      "code": "let result = detector.detect(&commands, &context).await.unwrap();",
      "context": [
        "        };",
        "        ",
        "        let result = detector.detect(&commands, &context).await.unwrap();",
        "        ",
        "        assert!(!result.synergies.is_empty());"
      ]
    },
    {
      "file": "src/synthex_bashgod/memory/hybrid.rs",
      "line": 396,
      "code": "memory.store_pattern(pattern.clone()).await.unwrap();",
      "context": [
        "        ",
        "        // Store pattern",
        "        memory.store_pattern(pattern.clone()).await.unwrap();",
        "        ",
        "        // Find similar"
      ]
    },
    {
      "file": "src/synthex_bashgod/memory/hybrid.rs",
      "line": 399,
      "code": "let results = memory.find_similar(&pattern, 0.8).await.unwrap();",
      "context": [
        "        ",
        "        // Find similar",
        "        let results = memory.find_similar(&pattern, 0.8).await.unwrap();",
        "        ",
        "        assert!(!results.is_empty());"
      ]
    },
    {
      "file": "src/synthex_bashgod/memory/hybrid.rs",
      "line": 411,
      "code": ".unwrap();",
      "context": [
        "            .max_graph_nodes(5000)",
        "            .build()",
        "            .unwrap();",
        "        ",
        "        // Add some patterns"
      ]
    },
    {
      "file": "src/synthex_bashgod/memory/hybrid.rs",
      "line": 430,
      "code": "memory.store_pattern(pattern).await.unwrap();",
      "context": [
        "            };",
        "            ",
        "            memory.store_pattern(pattern).await.unwrap();",
        "        }",
        "        "
      ]
    },
    {
      "file": "src/synthex_bashgod/memory/hybrid.rs",
      "line": 434,
      "code": "let stats = memory.get_memory_stats().await.unwrap();",
      "context": [
        "        ",
        "        // Get stats",
        "        let stats = memory.get_memory_stats().await.unwrap();",
        "        ",
        "        assert_eq!(stats.pattern_count, 5);"
      ]
    },
    {
      "file": "src/synthex_bashgod/memory/hybrid.rs",
      "line": 445,
      "code": ".unwrap();",
      "context": [
        "            .enable_cross_optimization(true)",
        "            .build()",
        "            .unwrap();",
        "        ",
        "        // Add patterns"
      ]
    },
    {
      "file": "src/synthex_bashgod/memory/hybrid.rs",
      "line": 467,
      "code": "memory.store_pattern(pattern).await.unwrap();",
      "context": [
        "            };",
        "            ",
        "            memory.store_pattern(pattern).await.unwrap();",
        "        }",
        "        "
      ]
    },
    {
      "file": "src/synthex_bashgod/memory/hybrid.rs",
      "line": 471,
      "code": "let result = memory.optimize_memory().await.unwrap();",
      "context": [
        "        ",
        "        // Optimize",
        "        let result = memory.optimize_memory().await.unwrap();",
        "        ",
        "        // Should have freed some memory"
      ]
    },
    {
      "file": "src/synthex_bashgod/memory/tensor.rs",
      "line": 750,
      "code": "memory.store(pattern.clone()).await.unwrap();",
      "context": [
        "        ",
        "        // Store pattern",
        "        memory.store(pattern.clone()).await.unwrap();",
        "        ",
        "        // Find similar patterns"
      ]
    },
    {
      "file": "src/synthex_bashgod/memory/tensor.rs",
      "line": 753,
      "code": "let results = memory.find_similar(&vec![0.5; 128], 0.9).await.unwrap();",
      "context": [
        "        ",
        "        // Find similar patterns",
        "        let results = memory.find_similar(&vec![0.5; 128], 0.9).await.unwrap();",
        "        ",
        "        assert_eq!(results.len(), 1);"
      ]
    },
    {
      "file": "src/synthex_bashgod/memory/tensor.rs",
      "line": 767,
      "code": "let memory = TensorMemory::new(config).unwrap();",
      "context": [
        "        };",
        "        ",
        "        let memory = TensorMemory::new(config).unwrap();",
        "        ",
        "        // Store initial pattern"
      ]
    },
    {
      "file": "src/synthex_bashgod/memory/tensor.rs",
      "line": 791,
      "code": "memory.store(pattern).await.unwrap();",
      "context": [
        "        };",
        "        ",
        "        memory.store(pattern).await.unwrap();",
        "        ",
        "        // Update statistics"
      ]
    },
    {
      "file": "src/synthex_bashgod/memory/tensor.rs",
      "line": 802,
      "code": "memory.update_stats(\"stats-test\", &execution_result).await.unwrap();",
      "context": [
        "        };",
        "        ",
        "        memory.update_stats(\"stats-test\", &execution_result).await.unwrap();",
        "        ",
        "        // Verify update"
      ]
    },
    {
      "file": "src/synthex_bashgod/memory/tensor.rs",
      "line": 805,
      "code": "let updated = memory.patterns.get(\"stats-test\").unwrap();",
      "context": [
        "        ",
        "        // Verify update",
        "        let updated = memory.patterns.get(\"stats-test\").unwrap();",
        "        assert_eq!(updated.metrics.execution_count, 2);",
        "        assert_eq!(updated.metrics.avg_execution_time_ms, 150.0);"
      ]
    },
    {
      "file": "src/synthex_bashgod/memory/graph.rs",
      "line": 630,
      "code": "memory.add_pattern(&pattern).await.unwrap();",
      "context": [
        "        };",
        "        ",
        "        memory.add_pattern(&pattern).await.unwrap();",
        "        ",
        "        let (patterns, nodes, edges) = memory.get_stats().await;"
      ]
    },
    {
      "file": "src/synthex_bashgod/memory/graph.rs",
      "line": 658,
      "code": "memory.add_pattern(&pattern1).await.unwrap();",
      "context": [
        "        };",
        "        ",
        "        memory.add_pattern(&pattern1).await.unwrap();",
        "        ",
        "        // Add second pattern with connection"
      ]
    },
    {
      "file": "src/synthex_bashgod/memory/graph.rs",
      "line": 676,
      "code": "memory.add_pattern(&pattern2).await.unwrap();",
      "context": [
        "        };",
        "        ",
        "        memory.add_pattern(&pattern2).await.unwrap();",
        "        ",
        "        // Manually add connection between patterns"
      ]
    },
    {
      "file": "src/synthex_bashgod/memory/graph.rs",
      "line": 699,
      "code": "let related = memory.find_related(\"pattern1\", 2).await.unwrap();",
      "context": [
        "        ",
        "        // Find related patterns",
        "        let related = memory.find_related(\"pattern1\", 2).await.unwrap();",
        "        ",
        "        assert!(related.iter().any(|(id, _)| id == \"pattern2\"));"
      ]
    },
    {
      "file": "src/synthex_bashgod/memory/graph.rs",
      "line": 725,
      "code": "memory.add_pattern(&pattern).await.unwrap();",
      "context": [
        "            };",
        "            ",
        "            memory.add_pattern(&pattern).await.unwrap();",
        "        }",
        "        "
      ]
    },
    {
      "file": "src/synthex_bashgod/memory/graph.rs",
      "line": 730,
      "code": "let idx0 = memory.node_index.get(\"pattern0\").unwrap();",
      "context": [
        "        // Add connections to form a cycle",
        "        let mut graph = memory.graph.write().await;",
        "        let idx0 = memory.node_index.get(\"pattern0\").unwrap();",
        "        let idx1 = memory.node_index.get(\"pattern1\").unwrap();",
        "        let idx2 = memory.node_index.get(\"pattern2\").unwrap();"
      ]
    },
    {
      "file": "src/synthex_bashgod/memory/graph.rs",
      "line": 731,
      "code": "let idx1 = memory.node_index.get(\"pattern1\").unwrap();",
      "context": [
        "        let mut graph = memory.graph.write().await;",
        "        let idx0 = memory.node_index.get(\"pattern0\").unwrap();",
        "        let idx1 = memory.node_index.get(\"pattern1\").unwrap();",
        "        let idx2 = memory.node_index.get(\"pattern2\").unwrap();",
        "        "
      ]
    },
    {
      "file": "src/synthex_bashgod/memory/graph.rs",
      "line": 732,
      "code": "let idx2 = memory.node_index.get(\"pattern2\").unwrap();",
      "context": [
        "        let idx0 = memory.node_index.get(\"pattern0\").unwrap();",
        "        let idx1 = memory.node_index.get(\"pattern1\").unwrap();",
        "        let idx2 = memory.node_index.get(\"pattern2\").unwrap();",
        "        ",
        "        for (from, to) in &[(*idx0, *idx1), (*idx1, *idx2), (*idx2, *idx0)] {"
      ]
    },
    {
      "file": "src/synthex_bashgod/memory/graph.rs",
      "line": 752,
      "code": "let communities = memory.detect_communities().await.unwrap();",
      "context": [
        "        ",
        "        // Detect communities",
        "        let communities = memory.detect_communities().await.unwrap();",
        "        ",
        "        // Should detect at least one community"
      ]
    },
    {
      "file": "src/synthex_bashgod/memory/mod.rs",
      "line": 252,
      "code": "lru_cache: lru::LruCache::new(capacity.try_into().unwrap()),",
      "context": [
        "    pub fn new(capacity: usize) -> Self {",
        "        Self {",
        "            lru_cache: lru::LruCache::new(capacity.try_into().unwrap()),",
        "            feature_index: dashmap::DashMap::new(),",
        "        }"
      ]
    },
    {
      "file": "src/synthex_bashgod/mcp_integration/server_manager.rs",
      "line": 120,
      "code": ".unwrap();",
      "context": [
        "            .timeout(Duration::from_secs(30))",
        "            .build()",
        "            .unwrap();",
        "        ",
        "        let servers = Arc::new(DashMap::new());"
      ]
    },
    {
      "file": "src/synthex_bashgod/mcp_integration/server_manager.rs",
      "line": 475,
      "code": "let servers = manager.list_servers().await.unwrap();",
      "context": [
        "        let manager = MCPServerManager::new(vec![config]);",
        "        ",
        "        let servers = manager.list_servers().await.unwrap();",
        "        assert_eq!(servers.len(), 1);",
        "        assert_eq!(servers[0].name, \"test-server\");"
      ]
    },
    {
      "file": "src/synthex_bashgod/mcp_integration/tool_enhancer.rs",
      "line": 313,
      "code": "bash_pattern: regex::Regex::new(pattern).unwrap(),",
      "context": [
        "    fn create_docker_mapping(pattern: &str, tool: &str) -> CommandMapping {",
        "        CommandMapping {",
        "            bash_pattern: regex::Regex::new(pattern).unwrap(),",
        "            server: \"docker\".to_string(),",
        "            tool: tool.to_string(),"
      ]
    },
    {
      "file": "src/synthex_bashgod/mcp_integration/tool_enhancer.rs",
      "line": 328,
      "code": "bash_pattern: regex::Regex::new(pattern).unwrap(),",
      "context": [
        "    fn create_git_mapping(pattern: &str, tool: &str) -> CommandMapping {",
        "        CommandMapping {",
        "            bash_pattern: regex::Regex::new(pattern).unwrap(),",
        "            server: \"git\".to_string(),",
        "            tool: tool.to_string(),"
      ]
    },
    {
      "file": "src/synthex_bashgod/mcp_integration/tool_enhancer.rs",
      "line": 343,
      "code": "bash_pattern: regex::Regex::new(pattern).unwrap(),",
      "context": [
        "    fn create_k8s_mapping(pattern: &str, tool: &str) -> CommandMapping {",
        "        CommandMapping {",
        "            bash_pattern: regex::Regex::new(pattern).unwrap(),",
        "            server: \"kubernetes\".to_string(),",
        "            tool: tool.to_string(),"
      ]
    },
    {
      "file": "src/synthex_bashgod/mcp_integration/tool_enhancer.rs",
      "line": 358,
      "code": "bash_pattern: regex::Regex::new(pattern).unwrap(),",
      "context": [
        "    fn create_fs_mapping(pattern: &str, tool: &str) -> CommandMapping {",
        "        CommandMapping {",
        "            bash_pattern: regex::Regex::new(pattern).unwrap(),",
        "            server: \"filesystem\".to_string(),",
        "            tool: tool.to_string(),"
      ]
    },
    {
      "file": "src/synthex_bashgod/learning/pattern_detector.rs",
      "line": 117,
      "code": "pattern: regex::Regex::new(r\"^(.+)$\").unwrap(),",
      "context": [
        "                pattern_type: PatternType::Repetition,",
        "                matcher: Box::new(RegexPatternMatcher {",
        "                    pattern: regex::Regex::new(r\"^(.+)$\").unwrap(),",
        "                }),",
        "                severity: PatternSeverity::Warning,"
      ]
    },
    {
      "file": "src/synthex_bashgod/learning/pattern_detector.rs",
      "line": 126,
      "code": "pattern: regex::Regex::new(r\"cat\\s+.+\\s*\\|\\s*grep\").unwrap(),",
      "context": [
        "                pattern_type: PatternType::ResourceWaste,",
        "                matcher: Box::new(RegexPatternMatcher {",
        "                    pattern: regex::Regex::new(r\"cat\\s+.+\\s*\\|\\s*grep\").unwrap(),",
        "                }),",
        "                severity: PatternSeverity::Warning,"
      ]
    },
    {
      "file": "src/synthex_bashgod/learning/pattern_detector.rs",
      "line": 135,
      "code": "pattern: regex::Regex::new(r\"eval\\s+\").unwrap(),",
      "context": [
        "                pattern_type: PatternType::SecurityRisk,",
        "                matcher: Box::new(RegexPatternMatcher {",
        "                    pattern: regex::Regex::new(r\"eval\\s+\").unwrap(),",
        "                }),",
        "                severity: PatternSeverity::Critical,"
      ]
    },
    {
      "file": "src/synthex_bashgod/learning/predictor.rs",
      "line": 500,
      "code": "pattern: regex::Regex::new(r\"sudo|/root/|/etc/\").unwrap(),",
      "context": [
        "            id: \"permission-denied\".to_string(),",
        "            issue_type: IssueType::PermissionDenied,",
        "            pattern: regex::Regex::new(r\"sudo|/root/|/etc/\").unwrap(),",
        "            base_probability: 0.3,",
        "            mitigations: vec!["
      ]
    },
    {
      "file": "src/synthex_bashgod/learning/predictor.rs",
      "line": 512,
      "code": "pattern: regex::Regex::new(r\"find.*-exec|grep -r|tar|zip\").unwrap(),",
      "context": [
        "            id: \"memory-intensive\".to_string(),",
        "            issue_type: IssueType::ResourceExhaustion,",
        "            pattern: regex::Regex::new(r\"find.*-exec|grep -r|tar|zip\").unwrap(),",
        "            base_probability: 0.2,",
        "            mitigations: vec!["
      ]
    },
    {
      "file": "src/synthex_bashgod/learning/predictor.rs",
      "line": 524,
      "code": "pattern: regex::Regex::new(r\"curl|wget|git clone|docker pull\").unwrap(),",
      "context": [
        "            id: \"timeout-risk\".to_string(),",
        "            issue_type: IssueType::TimeoutRisk,",
        "            pattern: regex::Regex::new(r\"curl|wget|git clone|docker pull\").unwrap(),",
        "            base_probability: 0.15,",
        "            mitigations: vec!["
      ]
    },
    {
      "file": "src/synthex/agents/database_agent.rs",
      "line": 144,
      "code": "all_results.sort_by(|a, b| b.score.partial_cmp(&a.score).unwrap());",
      "context": [
        "        ",
        "        // Sort by score",
        "        all_results.sort_by(|a, b| b.score.partial_cmp(&a.score).unwrap());",
        "        all_results.truncate(options.max_results);",
        "        "
      ]
    },
    {
      "file": "src/synthex/agents/api_agent.rs",
      "line": 169,
      "code": "match request.try_clone().unwrap().send().await {",
      "context": [
        "            attempts += 1;",
        "            ",
        "            match request.try_clone().unwrap().send().await {",
        "                Ok(response) if response.status().is_success() => return Ok(response),",
        "                Ok(response) => {"
      ]
    },
    {
      "file": "src/synthex/agents/api_agent.rs",
      "line": 343,
      "code": "all_results.sort_by(|a, b| b.score.partial_cmp(&a.score).unwrap());",
      "context": [
        "        ",
        "        // Sort by score and limit",
        "        all_results.sort_by(|a, b| b.score.partial_cmp(&a.score).unwrap());",
        "        all_results.truncate(options.max_results);",
        "        "
      ]
    },
    {
      "file": "src/synthex/agents/api_agent.rs",
      "line": 371,
      "code": "let (_, endpoint) = endpoints.iter().next().unwrap();",
      "context": [
        "        ",
        "        // Check first endpoint",
        "        let (_, endpoint) = endpoints.iter().next().unwrap();",
        "        let start = std::time::Instant::now();",
        "        "
      ]
    }
  ],
  "panic_calls": [
    {
      "file": "src/mcp_manager/actor_tests.rs",
      "line": 119,
      "code": "_ => panic!(\"Expected AlreadyExists error\"),",
      "context": [
        "                assert!(msg.contains(\"duplicate\"));",
        "            }",
        "            _ => panic!(\"Expected AlreadyExists error\"),",
        "        }",
        "        "
      ]
    },
    {
      "file": "src/mcp_manager/actor_tests.rs",
      "line": 138,
      "code": "_ => panic!(\"Expected NotFound error\"),",
      "context": [
        "                assert!(msg.contains(\"nonexistent\"));",
        "            }",
        "            _ => panic!(\"Expected NotFound error\"),",
        "        }",
        "        "
      ]
    },
    {
      "file": "src/mcp_manager/actor_tests.rs",
      "line": 282,
      "code": "e => panic!(\"Unexpected error type: {:?}\", e),",
      "context": [
        "            match error.unwrap_err() {",
        "                McpError::NotFound(_) => {}, // Expected",
        "                e => panic!(\"Unexpected error type: {:?}\", e),",
        "            }",
        "        }"
      ]
    }
  ],
  "expect_calls": [],
  "missing_error_propagation": [],
  "custom_error_types": [
    {
      "file": "src/ffi_security.rs",
      "type": "FFISecurityError",
      "definition": {
        "has_error_impl": false,
        "has_display_impl": false,
        "uses_thiserror": true
      }
    },
    {
      "file": "src/lib.rs",
      "type": "CoreError",
      "definition": {
        "has_error_impl": false,
        "has_display_impl": false,
        "uses_thiserror": false
      }
    },
    {
      "file": "src/services/mod.rs",
      "type": "ServiceError",
      "definition": {
        "has_error_impl": false,
        "has_display_impl": false,
        "uses_thiserror": false
      }
    },
    {
      "file": "src/orchestrator/mod.rs",
      "type": "OrchestratorError",
      "definition": {
        "has_error_impl": false,
        "has_display_impl": false,
        "uses_thiserror": false
      }
    },
    {
      "file": "src/mcp_manager/errors.rs",
      "type": "McpError",
      "definition": {
        "has_error_impl": true,
        "has_display_impl": true,
        "uses_thiserror": false
      }
    },
    {
      "file": "src/mcp_manager/error.rs",
      "type": "MCPError",
      "definition": {
        "has_error_impl": false,
        "has_display_impl": false,
        "uses_thiserror": true
      }
    },
    {
      "file": "src/mcp_manager/protocol.rs",
      "type": "MCPResponseError",
      "definition": {
        "has_error_impl": false,
        "has_display_impl": false,
        "uses_thiserror": false
      }
    },
    {
      "file": "src/reliability/mod.rs",
      "type": "ReliabilityError",
      "definition": {
        "has_error_impl": false,
        "has_display_impl": false,
        "uses_thiserror": false
      }
    },
    {
      "file": "src/memory/mod.rs",
      "type": "MemoryError",
      "definition": {
        "has_error_impl": false,
        "has_display_impl": false,
        "uses_thiserror": false
      }
    },
    {
      "file": "src/network/mod.rs",
      "type": "NetworkError",
      "definition": {
        "has_error_impl": false,
        "has_display_impl": false,
        "uses_thiserror": false
      }
    },
    {
      "file": "src/synthex_bashgod/mod.rs",
      "type": "SBGError",
      "definition": {
        "has_error_impl": false,
        "has_display_impl": false,
        "uses_thiserror": true
      }
    },
    {
      "file": "src/resources/mod.rs",
      "type": "ResourceError",
      "definition": {
        "has_error_impl": false,
        "has_display_impl": false,
        "uses_thiserror": false
      }
    },
    {
      "file": "src/synthex/parallel_executor.rs",
      "type": "SearchError",
      "definition": {
        "has_error_impl": false,
        "has_display_impl": false,
        "uses_thiserror": false
      }
    },
    {
      "file": "src/synthex/mod.rs",
      "type": "SynthexError",
      "definition": {
        "has_error_impl": false,
        "has_display_impl": false,
        "uses_thiserror": true
      }
    },
    {
      "file": "src/mcp_manager/fusion/cross_tool.rs",
      "type": "ErrorHandler",
      "definition": {
        "has_error_impl": false,
        "has_display_impl": false,
        "uses_thiserror": false
      }
    },
    {
      "file": "src/mcp_manager/protocols/mod.rs",
      "type": "ErrorResponse",
      "definition": {
        "has_error_impl": false,
        "has_display_impl": false,
        "uses_thiserror": false
      }
    },
    {
      "file": "src/mcp_manager/plugin/traits.rs",
      "type": "ConfigValidationError",
      "definition": {
        "has_error_impl": false,
        "has_display_impl": false,
        "uses_thiserror": false
      }
    },
    {
      "file": "src/mcp_manager/plugin/mod.rs",
      "type": "PluginError",
      "definition": {
        "has_error_impl": false,
        "has_display_impl": false,
        "uses_thiserror": true
      }
    }
  ],
  "good_patterns": [
    {
      "file": "src/ffi_security.rs",
      "pattern": "Uses thiserror for error derivation"
    },
    {
      "file": "src/lib.rs",
      "pattern": "Uses thiserror for error derivation"
    },
    {
      "file": "src/services/mod.rs",
      "pattern": "Uses thiserror for error derivation"
    },
    {
      "file": "src/services/mod.rs",
      "pattern": "Uses anyhow for error handling"
    },
    {
      "file": "src/orchestrator/mod.rs",
      "pattern": "Uses thiserror for error derivation"
    },
    {
      "file": "src/orchestrator/mod.rs",
      "pattern": "Uses anyhow for error handling"
    },
    {
      "file": "src/mcp_manager/error.rs",
      "pattern": "Uses thiserror for error derivation"
    },
    {
      "file": "src/reliability/mod.rs",
      "pattern": "Uses thiserror for error derivation"
    },
    {
      "file": "src/reliability/mod.rs",
      "pattern": "Uses anyhow for error handling"
    },
    {
      "file": "src/memory/mod.rs",
      "pattern": "Uses thiserror for error derivation"
    },
    {
      "file": "src/testing/performance.rs",
      "pattern": "Uses anyhow for error handling"
    },
    {
      "file": "src/testing/ffi.rs",
      "pattern": "Uses anyhow for error handling"
    },
    {
      "file": "src/testing/mod.rs",
      "pattern": "Uses anyhow for error handling"
    },
    {
      "file": "src/network/mod.rs",
      "pattern": "Uses thiserror for error derivation"
    },
    {
      "file": "src/network/mod.rs",
      "pattern": "Uses anyhow for error handling"
    },
    {
      "file": "src/synthex_bash_god/mod.rs",
      "pattern": "Uses anyhow for error handling"
    },
    {
      "file": "src/learning_engine/optimizer.rs",
      "pattern": "Provides error context"
    },
    {
      "file": "src/learning_engine/pattern_detector.rs",
      "pattern": "Uses anyhow for error handling"
    },
    {
      "file": "src/learning_engine/predictor.rs",
      "pattern": "Provides error context"
    },
    {
      "file": "src/synthex_bashgod/mod.rs",
      "pattern": "Uses thiserror for error derivation"
    },
    {
      "file": "src/resources/mod.rs",
      "pattern": "Uses thiserror for error derivation"
    },
    {
      "file": "src/resources/mod.rs",
      "pattern": "Uses anyhow for error handling"
    },
    {
      "file": "src/synthex/mod.rs",
      "pattern": "Uses thiserror for error derivation"
    },
    {
      "file": "src/mcp_manager/protocols/websocket.rs",
      "pattern": "Provides error context"
    },
    {
      "file": "src/mcp_manager/protocols/mod.rs",
      "pattern": "Uses anyhow for error handling"
    },
    {
      "file": "src/mcp_manager/protocols/http.rs",
      "pattern": "Provides error context"
    },
    {
      "file": "src/mcp_manager/plugin/mod.rs",
      "pattern": "Uses thiserror for error derivation"
    },
    {
      "file": "src/synthex/tests/agent_tests.rs",
      "pattern": "Provides error context"
    },
    {
      "file": "src/synthex/tests/integration_tests.rs",
      "pattern": "Provides error context"
    },
    {
      "file": "src/synthex/tests/query_tests.rs",
      "pattern": "Provides error context"
    },
    {
      "file": "src/synthex/tests/test_utils.rs",
      "pattern": "Provides error context"
    },
    {
      "file": "src/synthex/tests/mcp_v2_tests.rs",
      "pattern": "Provides error context"
    }
  ],
  "error_messages": []
}