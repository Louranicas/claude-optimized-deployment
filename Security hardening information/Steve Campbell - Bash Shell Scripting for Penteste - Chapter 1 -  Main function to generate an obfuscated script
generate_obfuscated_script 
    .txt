# Security Chapter Extract
Book: Steve Campbell - Bash Shell Scripting for Pentesters (2024, Packt Publishing Pvt Ltd) - libgen.li
Chapter: 1 - # Main function to generate an obfuscated script
generate_obfuscated_script() {
    local original_script="$1"
    local obfuscated_script=""
    while IFS= read -r line; do
        if [[ -n "$line" && ! "$line" =~ ^[[:space:]]*# ]]; then
            obfuscated_line=$(apply_multiple_obfuscations "$line")
            obfuscated_script+="$obfuscated_line"$'\n'
        else
            obfuscated_script+="$line"$'\n'
        fi
    done < "$original_script"
    echo "$obfuscated_script"
}
Security Relevance Score: 6
Word Count: 729
Extracted: 2025-06-13 23:41:12

---

# Main function to generate an obfuscated script
generate_obfuscated_script() {
    local original_script="$1"
    local obfuscated_script=""
    while IFS= read -r line; do
        if [[ -n "$line" && ! "$line" =~ ^[[:space:]]*# ]]; then
            obfuscated_line=$(apply_multiple_obfuscations "$line")
            obfuscated_script+="$obfuscated_line"$'\n'
        else
            obfuscated_script+="$line"$'\n'
        fi
    done < "$original_script"
    echo "$obfuscated_script"
}


     In the preceding code, the original script code is processed line by line and sent to the
    


      apply_multiple_obfuscations
     


     function.
    

     Once the function has processed the data and applied obfuscation, it is appended to the
    



       obfuscated_script
      




      variable.
     



# Usage
original_script="original_script.sh"
obfuscated_script=$(generate_obfuscated_script "$original_script")
echo "$obfuscated_script" > obfuscated_script.sh


     This updated
    



     script
    



     introduces the
    


      apply_multiple_obfuscations
     


     function, which applies a random number of obfuscation techniques to each line of the script.
    

     This approach creates a more complex and varied obfuscation pattern, making it harder to identify patterns
    


      or signatures.
     




     After generating obfuscated scripts, it’s important to test and validate them against common AV and EDR products.
    

     This process helps ensure that our obfuscation techniques are effective and allows us to refine our methods based on
    


      the results.
     




     Here’s a basic script that demonstrates how we might approach testing our obfusc
    





     ated scripts.
    

     It can be found in the GitHub repository as
    


      ch14_auto_obfuscate_6.sh
     


     .
    

     You’ll need to obtain a VirusTotal API key and replace the
    


      YOUR_API_KEY
     


     string before running the script.
    

     You can find instructions for obtaining an API key
    


      at
     




       ht
      





       tps://docs.virustotal.com/docs/please-give-me-an-api-key
      




      :
     



#!/usr/bin/env bash
# Source the obfuscation script
source ch14_auto_obfuscate_1.sh
# Function to test a script against AV/EDR solutions
test_script() {
    local script="$1"
    local result=""
    # Simulate testing against different AV/EDR solutions
    # In a real scenario, you would use actual AV/EDR products or online scanning services
    result+="ClamAV: $(clamscan "$script")"$'\n'
    result+="VirusTotal: $(curl -s -F "file=@$script" https://www.virustotal.com/vtapi/v2/file/scan --form apikey=YOUR_API_KEY)"$'\n'
    echo "$result"
}


     The
    


      test_script
     


     function
    



     in
    



     the preceding code block is responsible for performing a scan using the ClamAV software and checking for detections on the
    


      VirusTotal website.
     



# Generate and test multiple variations of obfuscated scripts
generate_and_test() {
    local original_script="$1"
    local num_variations="$2"
    for ((i=1; i<=num_variations; i++)); do
        echo "Testing variation $i"
        obfuscated_script=$(generate_obfuscated_script "$original_script")
        echo "$obfuscated_script" > "obfuscated_script_$i.sh"
        test_result=$(test_script "obfuscated_script_$i.sh")
        echo "$test_result"
        echo "-------------------------"
    done
}


     The preceding code block is responsible for generating and testing multiple iterations
    


      of obfuscation.
     



# Usage
original_script="original_script.sh"
num_variations=5
generate_and_test "$original_script" "$num_variations"


     This script demonstrates a basic approach to testing obfuscated scripts.
    

     The
    


      test_script
     


     function
    



     simulates testing a
    



     script against different AV/EDR solutions.
    

     In a real-world scenario, you would replace these simulations with actual scans using AV/EDR products or online
    


      scanning services.
     




     The
    


      generate_and_test
     


     function generates multiple variations of obfuscated scripts and tests each one.
    

     This allows us to see how different combinations of obfuscation techniques perform against
    


      detection systems.
     




     The script generates a specified number of obfuscated variations and runs them through the testing process, providing results for
    


      each variation.
     




     It’s important to note that this is a simplified example for demonstration purposes.
    

     In practice, testing against AV/EDR solutions would involve more comprehensive methods, potentially including
    


      the following:
     





      Using a dedicated testing environment
     


       or sandbox
      




      Employing multiple AV/EDR products for
     


       thorough testing
      




      Analyzing behavioral detection in addition to
     


       signature-based detection
      




      Continuously updating the testing process as AV/EDR
     


       solutions evolve
      





     By systematically testing and validating our obfuscated scripts, we can refine our obfuscation techniques and ensure that they remain effective against current
    


      detection methods.
     




     Throughout this section, we learned how to create a comprehensive system for generating, obfuscating, and
    



     testing evasion
    



     scripts in Bash.
    

     This automated approach not only saves time but also allows for the creation of more sophisticated and effective
    


      evasion techniques.
     






     Summary
    



     In this chapter, we explored techniques for evading detection by AV and EDR systems during pentests, focusing on Bash shell scripting.
    

     We covered methods for gathering information about the security environment, basic and advanced obfuscation techniques, and strategies for automating the generation of
    


      evasive scripts.
     




     We learned how to use Bash commands to identify installed security software and active monitoring processes.
    

     We examined various obfuscation methods, including variable name obfuscation, command substitution, and encoding techniques.
    

     We also covered advanced evasion tactics such as timing-based evasion and transferring data using DNS.
    

     Finally, we discussed the development of a framework for generating obfuscated Bash scripts and testing their effectiveness against common AV and
    


      EDR solutions.
     




     The value of these techniques will become apparent as more stakeholders install endpoint protection agents on Linux systems.
    

     This will make it more difficult to pentest and your new obfuscation skills will be of
    


      great benefit.
     




     In
