# Security Chapter Extract
Book: Steve Campbell - Bash Shell Scripting for Pentesters_ Master the art of command-line exploitation and enhance your penetration testing workflows (2024, Packt Publishing) - libgen.li
Chapter: 11 - Install libpcap for naabu:
$ sudo apt install -y libpcap-dev
That wraps up installing all of the needed ProjectDiscovery tools.
Install NetExec
NetExec is a network service exploitation tool that helps automate assessing the security of large networks  
(NetExec wiki, https://www.netexec.wiki/).
In my opinion, NetExec is one of the most useful tools for internal network pentesting. It supports 
most of the network protocols needed during internal network pentesting, plus Microsoft Active 
Directory testing.
There are far too many features to list here. Some of the things I use NetExec for include the following:
• Scanning for vulnerabilities; NetExec includes some useful modules to test for 
common vulnerabilities
• Brute-force attacks on authentication to test for weak passwords
Summary
 17
• Spraying a password or password hash against servers to find where the supplied credentials 
have local administrator access
• Command execution
• Gathering credentials
• Enumerating SMB shares for read/write access
Enter the following command to install NetExec:
$ sudo apt install -y pipx git && pipx ensurepath && pipx install 
git+https://github.com/Pennyw0rth/NetExec
That wraps up the process of installing the most common pentesting tools that are not installed by default.
Summary
In this chapter, you were introduced to the indispensable world of Bash shell scripting, a cornerstone 
skill for anyone aspiring to excel in pentesting. This chapter began by demystifying what Bash is and 
underscoring its significance in cybersecurity tasks. It wasn’t just about memorizing commands; it was 
about leveraging Bash to automate repetitive tasks, manipulate data, and conduct security assessments 
with efficiency. The journey continued with guidance on selecting the appropriate operating system 
that supports Bash, setting the stage for successful scripting endeavors. Then, we rolled up our sleeves 
to configure our hacker shell, customizing its appearance and behavior to reflect personal tastes and 
preferences. This customization wasn’t just for aesthetics; it was about creating a functional and 
efficient working environment. Finally, this chapter introduced essential pentesting tools, walking 
you through their installation and basic usage. At this point, you're equipped with a well-prepared 
environment and a foundational understanding of how Bash scripting can significantly enhance your 
pentesting capabilities.
The next chapter will cover techniques for working with files and directories.
Security Relevance Score: 17
Word Count: 3675
Extracted: 2025-06-13 23:40:19

---

Install libpcap for naabu:
$ sudo apt install -y libpcap-dev
That wraps up installing all of the needed ProjectDiscovery tools.
Install NetExec
NetExec is a network service exploitation tool that helps automate assessing the security of large networks  
(NetExec wiki, https://www.netexec.wiki/).
In my opinion, NetExec is one of the most useful tools for internal network pentesting. It supports 
most of the network protocols needed during internal network pentesting, plus Microsoft Active 
Directory testing.
There are far too many features to list here. Some of the things I use NetExec for include the following:
• Scanning for vulnerabilities; NetExec includes some useful modules to test for 
common vulnerabilities
• Brute-force attacks on authentication to test for weak passwords
Summary
 17
• Spraying a password or password hash against servers to find where the supplied credentials 
have local administrator access
• Command execution
• Gathering credentials
• Enumerating SMB shares for read/write access
Enter the following command to install NetExec:
$ sudo apt install -y pipx git && pipx ensurepath && pipx install 
git+https://github.com/Pennyw0rth/NetExec
That wraps up the process of installing the most common pentesting tools that are not installed by default.
Summary
In this chapter, you were introduced to the indispensable world of Bash shell scripting, a cornerstone 
skill for anyone aspiring to excel in pentesting. This chapter began by demystifying what Bash is and 
underscoring its significance in cybersecurity tasks. It wasn’t just about memorizing commands; it was 
about leveraging Bash to automate repetitive tasks, manipulate data, and conduct security assessments 
with efficiency. The journey continued with guidance on selecting the appropriate operating system 
that supports Bash, setting the stage for successful scripting endeavors. Then, we rolled up our sleeves 
to configure our hacker shell, customizing its appearance and behavior to reflect personal tastes and 
preferences. This customization wasn’t just for aesthetics; it was about creating a functional and 
efficient working environment. Finally, this chapter introduced essential pentesting tools, walking 
you through their installation and basic usage. At this point, you're equipped with a well-prepared 
environment and a foundational understanding of how Bash scripting can significantly enhance your 
pentesting capabilities.
The next chapter will cover techniques for working with files and directories.

2
File and Directory Management
Mastering Bash file and directory management equips you with the skills to navigate the filesystem 
efficiently, manipulate files and directories, control access through permissions, and automate routine 
tasks. These abilities are essential for anyone looking to harness the full power of their Linux or Unix 
system. With practice, patience, and a bit of creativity, you can turn the complexity of the filesystem 
into a well-organized collection of files and directories at your command.
By the end of this chapter, you will become skilled at creating, deleting, copying, and moving files. Y ou 
will understand the significance of absolute and relative paths. This will also include an introduction 
to directory structures and how to efficiently navigate the filesystem in a Bash environment. Y ou’ll 
grasp the concept of user and group permissions in a Linux environment. Y ou’ll learn the difference 
between hard links and symbolic links ( symlinks or soft links), how to create them, and scenarios 
where each type of link is useful.
In this chapter, we’re going to cover the following main topics:
• Working with files and directories
• Directory navigation and manipulation
• File permissions and ownership
• Linking files—hard links and symlinks
Technical requirements
Access to a Linux system with a Bash shell is required to follow along. All commands used in this chapter 
can be found in the GitHub code repository located at https://github.com/PacktPublishing/
Bash-Shell-Scripting-for-Pentesters/tree/main/Chapter02 .
Working with files and directories
In this section, we’ll cover commands for working with files and directories and how to navigate the 
filesystem. We’ll start with the ls command, which is used to list files, directories, and their permissions.
File and Directory Management 20
The ls command in Bash is like the Swiss Army knife for listing directory contents. It’s simple yet 
packed with options to customize the output to your needs. Let’s dive into how you can use ls to 
make your life at the terminal easier and more productive.
At its most basic, ls will list the files and directories in your current directory using the following command:
~ $ ls
Desktop  Documents  Downloads  Music  Pictures
This will display all non-hidden files and directories. Hidden files (those starting with a dot) won’t 
show up. To see hidden files as well, use the -a option to get the following output:
Figure 2.1 – Hidden files are shown when using the -a option with the ls command
Now, you’ll see everything, including files such as .bashrc.
If you want to view a listing of files and directories in a location different from the current directory, 
add the directory location to the end of the ls command as shown next:
$ ls /opt
In a shell command such as ls *.txt, the asterisk (* ) is referred to as a glob  character. The *  character 
matches any sequence of characters, so this command lists all files in the current directory that have a 
.txt extension. Y ou could also use the glob character to list all files that start with a specified string 
and end with any character or series of characters using the ls sometext* command.
Use the -l option for more details, such as file permissions, number of links, owner, group, size, 
and timestamp:
Figure 2.2 – Extended file and directory information is displayed using the ls command -l option

Working with files and directories
 21
This long format is incredibly useful for getting a quick overview of the filesystem’s state.
When using -l, file sizes are listed in bytes by default. Add the -h option to make sizes more readable 
(for example, KB, MB). This makes it easier to gauge file sizes at a glance:
Figure 2.3 – The ls command -h option displays file sizes in a human-readable format
To see the most recently modified files at the top, use the -t option. To sort the output of ls -t in 
reverse, include the -r option. Combine this with -h to get a detailed, human-readable list of files 
sorted by modification time, as shown in the following figure:
Figure 2.4 – The ls command options show how to sort based on file modification time
Sorting files by size can quickly show you the largest or smallest files in a directory. The following 
command will sort the output of ls based on file size:
$ ls -lS
Tip
Sometimes, you want to see not just the contents of the current directory but all subdirectories 
as well. Use -R to show the contents of all subdirectories recursively.
Some common actions you may want to take on a file or directory besides listing them with the ls  
command include making, copying, and deleting them.
Y ou can make a new file or directory with the touch and mkdir commands, respectively.

File and Directory Management 22
Make a new empty file, as shown next, using the touch command:
$ touch test.txt
Make a new directory, as shown, using the mkdir command:
$ mkdir [path and name of new directory]
If you want to create multiple nested directories in a path, include the -p option. For example, suppose 
you want to create a new directory named first , and inside of first , you want to create a second  
directory. The following example creates this new directory structure:
$ mkdir -p first/second
Y ou can copy files and directories using the cp command. The syntax of the cp command is shown here:
$ cp [source] [destination]
To delete a file, use the rm command. Be careful with this command because deletions cannot be 
recovered. If you’re deleting a directory, include the -r option to recursively delete files and directories 
contained in the directory. The following command demonstrates how to delete a file using rm:
$ rm [file]
Now that you’ve learned how to list, create, and delete files, it’s time to move on to learning how to 
navigate your filesystem in the next section.
Directory navigation and manipulation
In this section, you’ll learn the layout of the Linux filesystem directories, the purpose of common 
directories, and how to navigate your way around the system. By the end of this section, you should 
be comfortable with the location and design decisions of the filesystem and will be using common 
Bash commands to navigate it like a pro.
Filesystem design and hierarchy
At the heart of Bash file management is an understanding of the filesystem hierarchy. Here, we’ll review 
the various filesystem directories and their purpose. We’ll also review particular directories of interest 
to pentest. This will enable you to be confident as you navigate your filesystem.
Imagine the filesystem as a tree with branches spreading out from the trunk.
Directory navigation and manipulation
 23
Using the tree command, you can find a high-level overview of the filesystem, as shown in the 
following figure:
Figure 2.5 – An overview of the filesystem hierarchy
Let’s understand the elements of this high-level overview as follows:
• /: At the root of this structure lies the /  directory, known simply as the root. This is the starting 
point: the base from which everything else extends. Imagine it as a tree trunk from which all 
other paths diverge. The following figure demonstrates running the tree command without 
specifying the number of levels to show the full layout of the filesystem:

File and Directory Management 24
Figure 2.6 – A deeper understanding of the directory structure as a tree is discovered
• /bin: Directly under the root, you’ll find /bin, a directory filled with essential user binaries 
or programs. These are the tools every user has access to and are necessary for daily operations.
• /boot: The /boot directory contains files required for booting the system, such as the Linux 
kernel and initial RAM disk (initrd) files.
• /dev: The /dev directory contains device files that represent hardware devices and special files.
• /etc: The /etc directory contains many configuration files that are critical to the operation 
of the system. As a pentest, you may be interested in certain files and directories within /etc. 
Here are some of the most notable ones:
 /etc/passwd: This file contains essential information about users on the system, such as 
user IDs, group IDs, home directories, and shells.
 /etc/group: This file contains a list of groups on the system, along with their group IDs 
and member usernames.
 /etc/shadow: This file stores password information for users, including hashed passwords 
and account expiration dates.
 /etc/sudoers : This file contains a list of users and groups that are allowed to use the 
sudo command to execute commands with elevated privileges.

Directory navigation and manipulation
 25
 /etc/sysconfig : This directory contains configuration files for various system services 
and applications, such as network settings, display manager configurations, and firewall rules.
 /etc/network: This directory contains configuration files for network interfaces, including 
IP addresses, subnet masks, and Domain Name System (DNS ) server settings.
 /etc/hosts: This file maps hostnames to IP addresses, allowing the system to resolve 
hostnames to IP addresses without relying on DNS servers.
 /etc/services: This file lists services that are available on the system, along with their 
port numbers and protocols.
 /etc/protocols : This file lists network protocols that are supported by the system, 
along with their version numbers and other configuration details.
 /etc/fstab: This file contains information about filesystems that are mounted on the 
system, including mount points, filesystem types, and options.
• /home: User-specific data resides in /home, a collection of personal spaces within the filesystem. 
Each user’s directory is like their home, storing personal files and settings.
• /lib: System libraries, the shared resources that programs need to run, are kept in /lib.
• /mnt: For mounting external devices or filesystems, there are/mnt and /media. These act 
as docks for external filesystems.
• /opt: Optional or third-party software is stored in /opt. It’s common for pentesters to clone 
git repositories to their own directory under /opt to run tools that aren’t installed in the 
usual /bin directories.
• /proc: The /proc directory stores information about running processes.
• /root: The home directory of the root user is located at /root. Because root is the superuser, 
its files are stored separately from other users found under /home.
• /run: The /run directory is a temporary filesystem that stores transient information since 
the last boot.
• /sbin: Adjacent to /bin is /sbin, housing system binaries. These are utilities typically 
reserved for the system administrator.
• /srv: The /srv directory stores data used by system services.
• /sys: The /sys directory provides an interface to kernel objects and their attributes.
• /tmp: The /tmp directory stores temporary files that are removed on system reboot.
• /usr: The /usr directory is a broader collection of user binaries, libraries, documentation, 
and more. It’s like a city’s commercial district, offering a wide array of services beyond the 
essentials found in /bin and /lib.
File and Directory Management 26
• /var: The /var directory on a Linux system is a key component of the filesystem hierarchy, 
with its primary purpose being to store variable data, files, and directories expected to grow in 
size over time. This can include logs, spool files, temporary files, and other types of transient 
or dynamic data that change or expand as the system operates. The structure and contents of 
the /var directory are designed to accommodate the storage of variable data across system 
reboots, ensuring that data persists between sessions. Here are some significant subdirectories 
within /var and their typical uses:
 /var/log: Contains log files generated by the system and various applications running 
on it. These logs can include system logs, application logs, and logs of system events, which 
are crucial for troubleshooting and monitoring system health.
 /var/spool: Used for queuing up tasks and data, such as print jobs, mail, and other 
queued tasks. This area is designed to hold data that is awaiting processing by some service 
or application.
 /var/tmp: Intended for temporary files that are preserved between system reboots. 
Unlike /tmp, which may also store temporary files, /var/tmp is not meant to be deleted 
or cleared at reboot.
 /var/cache: Stores cached data from applications. This data can be regenerated as needed, 
but it’s stored to improve performance by reducing the need to recalculate or fetch the same 
data repeatedly.
 /var/mail: Holds users’ email messages in some configurations. This directory is essential 
for systems that handle on-site mail storage.
 /var/www : Commonly used as the default directory for web server content. This 
includes websites hosted on the server, and it’s a standard location for web files in many  
Linux distributions.
 /var/lib: Contains dynamic state information that programs typically modify while they 
run. This can include databases, application state files, and other data that applications need 
to store and manage during operation.
Y ou can read the documentation of the Linux filesystem hierarchy by entering the hier command 
as shown next:
$ man hier
Tip
The man command is short for manual. Remember to use man when you need to discover 
options and conventions required by a command.
Directory navigation and manipulation
 27
Although the current working directory may be displayed in the Bash shell prompt, you can print the 
current directory using the pwd command as shown here:
~ $ pwd
/home/steve
Now that you’ve discovered the filesystem layout and understand its hierarchy and design, let’s move 
on to find out how to navigate it in the next section.
Filesystem navigation commands
Navigating the filesystem can be done using various tools and techniques. The most common way is 
to use the command-line interface (CLI) and navigate through directories using the cd command. 
For example, to change to the /home directory, you would type the following:
$ cd /home
Previously, we mentioned how the tilde (~) character is a shortcut to typing the full path to the user 
directory, so you could also navigate to your home directory by using the tilde after the cd command, 
as shown here:
$ cd ~
If you have tab completion configured in your profile, you can also use the tab key to autocomplete 
directory names as you type, making it easier to navigate the filesystem.
In addition to cd, the Bash shell provides several commands to navigate through directories, including 
pushd  and popd . These two commands are like a trail of breadcrumbs left in the wilderness, helping you 
track where you’ve been so that you can easily return. When you pushd into a directory, Bash remembers 
your current location before moving you to the new one. Need to get back? Just popd, and you’re returned 
to your previous directory. It’s like having a teleportation device in your command-line toolkit. The following 
command output demonstrates the use of the pushd and popd commands to navigate the filesystem:
~ $ pushd /var/log
/var/log ~
/var/log $ pushd /etc
/etc /var/log ~
/etc $ popd
/var/log ~
/var/log $ popd
~
~ $
File and Directory Management 28
This would be a good time to mention absolute  versus relative  paths. An absolute path is the full path, 
starting from the root (/) of the drive. An absolute path to a file in your home directory would be /
home/user/filename. The relative path would be in relation to the directory you’re currently 
in. The current directory is represented by a period and slash ( ./). One directory up in the hierarchy 
is represented by ../. Two levels up would be ../../, and so on. To go down into a subdirectory 
from where you are now, you’ d simply use the directory name. For example, to reference a file two 
directories down from the current directory, this would be directory1/directory2/filename.
Now, imagine you’re working deep within a directory tree and need to jump back several levels. Typing 
cd ../../.. is not only tedious but also prone to error. Enter the cd - command, a simple yet 
powerful shortcut that instantly takes you back to the last directory you were in. It’s like having an 
undo button for your navigation mistakes. Here, we see how it works and takes us back to where we 
came from:
~ $ cd /opt
/opt $ cd -
/home/steve
~ $
But what if you could jump to frequently used directories without remembering their paths? That’s where 
aliases come into play. By adding lines such as alias docs='cd /home/user/documents'  
to your .bashrc  file, you create shortcuts for those long-winded paths. Suddenly, moving to your 
documents folder is as easy as typing docs. It’s like setting up personal shortcuts in a vast city.
For those who love efficiency, the Ctrl  + R reverse search functionality is a game-changer. Press these 
keys and start typing part of a previously used command. Bash will search through your history and 
suggest commands that match. It’s like having a search engine for your command history, saving you 
from retyping long commands.
Lastly, let’s not forget about tab completion, a feature that feels almost magical. Start typing the name 
of a directory or file and hit the Tab  key. Bash will either autocomplete it for you or show you the 
possible completions if there’s more than one match. It’s similar to having a personal assistant who 
finishes your sentences but for directory navigation.
In conclusion, mastering these advanced Bash navigation tips and tricks can transform your command-
line experience from frustrating to fluid. Whether it’s jumping back and forth between directories 
with pushd and popd, creating shortcuts with aliases, or leveraging the power of reverse search 
and tab completion, these techniques are all about making your life easier. So, next time you open 
the terminal, remember these tricks and watch how quickly you can move through your filesystem.
By now, you should have a firm grasp of the filesystem layout and be confident as you navigate around 
the system. Next, we’ll explore filesystem permissions.
File permissions and ownership
 29
File permissions and ownership
Earlier in this chapter, you may have noticed a string that looked similar to drwxr-xr-x  in the 
output of the ls -l  command. This represents the permissions of a file or directory. Linux filesystem 
permissions are like the rules at a playground. They determine who can play on the swings (access files), 
who can invite friends to play (change permissions), and who can set rules (ownership). Understanding 
these permissions is crucial for anyone looking to manage a Linux system effectively. Let’s break it 
down into simple terms, including the use of chown, chmod, SUID, and SGID.
Ownership and groups
Every file and directory in Linux has an owner and a group associated with it. Think of the owner as 
the parent who has control over their child’s toy and the group as selected friends who can play with 
it under certain conditions. The following description may help:
• Owner : The user who has control over the file or directory
• Group : A set of users who share certain permissions
Changing ownership – chown
To change who owns a file or directory, we use the chown  command (this may require prefixing the 
command with sudo):
$ chown [user]:[group] [file]
This command changes both the owner and the group of the file. If you want to change just the owner 
or the group, you can omit the group in the command. However, if you omit the user, the group must 
be preceded with a colon character. The following command demonstrates how to change only the 
group ownership of a file:
$ chown :[group] [file name]
That would leave the owner intact but change the group on the file or directory permissions.
If you have a file and want to apply the same permissions used on a reference file, include the 
--reference parameter, as shown here:
$ chown --reference=file1 file2
There are two common chown options that you should be familiar with:
• -h: Affect symlinks instead of any referenced file
• -R: Operate on files and directories recursively
