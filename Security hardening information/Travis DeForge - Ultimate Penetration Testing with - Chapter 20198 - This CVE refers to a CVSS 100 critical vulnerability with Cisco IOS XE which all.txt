# Security Chapter Extract
Book: Travis DeForge - Ultimate Penetration Testing with Nmap_ Master Cybersecurity Assessments for Network Security, Monitoring, and Scanning Using N (2024, Orange Education Pvt Ltd, AVA™) - libgen.li
Chapter: 20198 - This CVE refers to a CVSS 10.0 critical vulnerability with Cisco IOS XE, which allowed an unauthenticated remote user to bypass authentication and create a local administrator user. This CVE was released in October of 2023 and was known to have been widely exploited. A popular method of maintaining persistence after exploitation was to use an available implant; thus, the script we will create here will be meant to check for the implant, rather than the vulnerability itself.
CVE-2023-20198 was a particularly dangerous vulnerability because it was so trivial to exploit, literally a single line curl command was able to create the local user account. Similarly, the associated implant could also be identified with a curl command. This simplicity enables this indicator of compromise (IoC) to be an excellent example of simple things that can be semi-automated with NSE scripts.
First, there is a commonly used format for NSE scripts, which includes a description and administrative information such as the author, license, NSE categories, and usage. We will start with these items at the top of the script:
description = [[
This script checks for the presence of an implant that has been associated with the exploitation of CVE-2023-20198 which allows an unauthenticated user to create a local user of the highest privilege level on Cisco IOS XE Web Management User Interface. It should be noted, this script checks for the commonly used implant to identify an indicator of compromise (IoC) it does not determine the target's vulnerability to the exploit itself.
]]
author = "Travis DeForge"
license = "Same as Nmap--See https://nmap.org/book/man-legal.html"
categories = {"malware", "safe"}
-- @usage
-- nmap --script CVE-2023-20198-Implant-Checker.nse <target(s)>
With those administrative details out of the way, the actual script can be provided. In this instance, we simply need Nmap to run curl -k -x POST <target>/webui/logoutconfirm.html?logon_hash=1 and print the output for us. To do this, we will first define the action, and then specify the target IP address within the URL path:
-- Define the action function
action = function(host, port)
local target_ip = host.ip
 -- Define the URL with the target IP addresses
local url = "https://" .. target_ip .. "/webui/logoutconfirm.html?logon_hash=1"
To finish the NSE script, now we just need to define the command to execute and print the results for analysis:
-- Execute
local command = 'curl -k -X POST "' .. url .. '"'
local handle = io.popen(command)
local result = handle:read("*a")
handle:close()
-- Print the server response
return result
end
While this is an extremely niche and very simple example of what can be converted into an NSE script; it is meant to be used as inspiration for you to identify other actions within your own workflows, which could be better optimized with Nmap.
Challenge: Create a Custom NSE Script and Post it to GitHub
Throughout this book, you have used Nmap for a wide swath of use cases and been exposed to the nearly limitless combination of different functions within it. Take the opportunity to reflect on some of the operations you have experimented with and how you could expand, simplify, or automate some of those operations into a consolidated NSE script of your own.
Posting scripts of this nature on your GitHub account will not only provide more credibility to yourself as a security engineer, but it will also help out the rest of the security community. It’s a win-win.
Challenge: Test and Refine a Custom Script in the Lab environment
Once you have your custom script created, regardless of whether it is an adaptation of CVE-2023-20198 or something different entirely, experiment with ways to iteratively improve the initial version. Experiment with methods of building obfuscation into the script, optimizing the timing profiles, or refining the output.
This can also be done by forking new versions of existing scripts and making your own modifications. This is meant to be an exercise in recognizing that you are not limited in your capacity with Nmap just because a script doesn’t currently do what you need. You have the capability to modify, improve, and create additional functionality through NSE scripts at any time.
As always, don’t forget to add the new version to your GitHub!
Challenge: Scanning with Multiple Concurrent Scripts
For this challenge, determine a combination of scripts that synergize well together, which you may want to call during the same scan. This could be something as simple as using a prerule broadcast script with the --newtargets flag to populate a target list and then using the postrule vulners.nse script to identify vulnerability information on those systems.
Keep in mind the order in which the scans will be conducted, the types of scans they are, and whether the output from one will be the input for another (if necessary). By identifying the combinations of concurrent scripts that fit your preferences and use cases, you will rapidly assemble a catalog of go-to Nmap commands that you will be able to use time and time again on different engagements.
Conclusion
Throughout this book, we have seen numerous examples of Nmap being leveraged to do powerful things, from obfuscation to optimization and everything in between. Undoubtedly one of the most powerful aspects of Nmap is the scripting engine. By understanding how the NSE scripts work, where to find them, how to incorporate them into your workflow, and even how to create custom ones yourself, you will be able to elevate your penetration testing skills to the next level.
In this chapter, we took a deeper look at the components of NSE scripts, how they work, what rules govern their function, and even how to construct your first custom script. With these tools at your disposal, the potential is limited only by your creativity.
In the next chapter, we will wrap up our Nmap deep dive by exploring industry best practices related to port and vulnerability scanning. We will cover verification of findings to reduce the rate of false positive and false negative results, communicating results to clients, as well as common mistakes made by inexperienced practitioners.
Points to Remember
Security Relevance Score: 13
Word Count: 1381
Extracted: 2025-06-13 23:40:38

---

This CVE refers to a CVSS 10.0 critical vulnerability with Cisco IOS XE, which allowed an unauthenticated remote user to bypass authentication and create a local administrator user. This CVE was released in October of 2023 and was known to have been widely exploited. A popular method of maintaining persistence after exploitation was to use an available implant; thus, the script we will create here will be meant to check for the implant, rather than the vulnerability itself.
CVE-2023-20198 was a particularly dangerous vulnerability because it was so trivial to exploit, literally a single line curl command was able to create the local user account. Similarly, the associated implant could also be identified with a curl command. This simplicity enables this indicator of compromise (IoC) to be an excellent example of simple things that can be semi-automated with NSE scripts.
First, there is a commonly used format for NSE scripts, which includes a description and administrative information such as the author, license, NSE categories, and usage. We will start with these items at the top of the script:
description = [[
This script checks for the presence of an implant that has been associated with the exploitation of CVE-2023-20198 which allows an unauthenticated user to create a local user of the highest privilege level on Cisco IOS XE Web Management User Interface. It should be noted, this script checks for the commonly used implant to identify an indicator of compromise (IoC) it does not determine the target's vulnerability to the exploit itself.
]]
author = "Travis DeForge"
license = "Same as Nmap--See https://nmap.org/book/man-legal.html"
categories = {"malware", "safe"}
-- @usage
-- nmap --script CVE-2023-20198-Implant-Checker.nse <target(s)>
With those administrative details out of the way, the actual script can be provided. In this instance, we simply need Nmap to run curl -k -x POST <target>/webui/logoutconfirm.html?logon_hash=1 and print the output for us. To do this, we will first define the action, and then specify the target IP address within the URL path:
-- Define the action function
action = function(host, port)
local target_ip = host.ip
 -- Define the URL with the target IP addresses
local url = "https://" .. target_ip .. "/webui/logoutconfirm.html?logon_hash=1"
To finish the NSE script, now we just need to define the command to execute and print the results for analysis:
-- Execute
local command = 'curl -k -X POST "' .. url .. '"'
local handle = io.popen(command)
local result = handle:read("*a")
handle:close()
-- Print the server response
return result
end
While this is an extremely niche and very simple example of what can be converted into an NSE script; it is meant to be used as inspiration for you to identify other actions within your own workflows, which could be better optimized with Nmap.
Challenge: Create a Custom NSE Script and Post it to GitHub
Throughout this book, you have used Nmap for a wide swath of use cases and been exposed to the nearly limitless combination of different functions within it. Take the opportunity to reflect on some of the operations you have experimented with and how you could expand, simplify, or automate some of those operations into a consolidated NSE script of your own.
Posting scripts of this nature on your GitHub account will not only provide more credibility to yourself as a security engineer, but it will also help out the rest of the security community. It’s a win-win.
Challenge: Test and Refine a Custom Script in the Lab environment
Once you have your custom script created, regardless of whether it is an adaptation of CVE-2023-20198 or something different entirely, experiment with ways to iteratively improve the initial version. Experiment with methods of building obfuscation into the script, optimizing the timing profiles, or refining the output.
This can also be done by forking new versions of existing scripts and making your own modifications. This is meant to be an exercise in recognizing that you are not limited in your capacity with Nmap just because a script doesn’t currently do what you need. You have the capability to modify, improve, and create additional functionality through NSE scripts at any time.
As always, don’t forget to add the new version to your GitHub!
Challenge: Scanning with Multiple Concurrent Scripts
For this challenge, determine a combination of scripts that synergize well together, which you may want to call during the same scan. This could be something as simple as using a prerule broadcast script with the --newtargets flag to populate a target list and then using the postrule vulners.nse script to identify vulnerability information on those systems.
Keep in mind the order in which the scans will be conducted, the types of scans they are, and whether the output from one will be the input for another (if necessary). By identifying the combinations of concurrent scripts that fit your preferences and use cases, you will rapidly assemble a catalog of go-to Nmap commands that you will be able to use time and time again on different engagements.
Conclusion
Throughout this book, we have seen numerous examples of Nmap being leveraged to do powerful things, from obfuscation to optimization and everything in between. Undoubtedly one of the most powerful aspects of Nmap is the scripting engine. By understanding how the NSE scripts work, where to find them, how to incorporate them into your workflow, and even how to create custom ones yourself, you will be able to elevate your penetration testing skills to the next level.
In this chapter, we took a deeper look at the components of NSE scripts, how they work, what rules govern their function, and even how to construct your first custom script. With these tools at your disposal, the potential is limited only by your creativity.
In the next chapter, we will wrap up our Nmap deep dive by exploring industry best practices related to port and vulnerability scanning. We will cover verification of findings to reduce the rate of false positive and false negative results, communicating results to clients, as well as common mistakes made by inexperienced practitioners.
Points to Remember

The Nmap scripting engine (NSE) is widely considered to be Nmap’s most powerful feature, enabling users to customize their own functionality to fit their workflows and preferences using the Lua scripting language.
The categories of NSE scripts are extremely important to understand and check before running scripts. This can be the difference between ensuring the script you run is safe or accidentally causing a denial-of-service condition in a production environment.
NSE scripts can run at varying times in relation to the standard scanning function of Nmap, including prerule and postrule. Understanding when specific scripts run will be important for any troubleshooting or to ensure that you are not getting a false positive or false negative result.
If you choose to write custom NSE scripts, strongly consider posting them to a public GitHub repository with a comprehensive description. This is a simple but impactful way to give back to the information security community.

Multiple Choice Questions

 NSE scripts are written in which language?

Rust
Python
C#
Lua
 Which category of NSE scripts are most closely associated with active reconnaissance?

Default
Safe
Discovery
External
 Which category of NSE scripts would be used to identify indicators of compromise on a system?

Exploit
Auth
Intrusive
Malware
 Which categories of NSE scripts have the greatest probability of causing a system to go offline (Choose 4)?

Auth
Broadcast
Brute
Default
Discovery
DoS
Exploit
External
Fuzzer
Malware
Vuln
Intrusive
Safe
Version
 Scripts that run before Nmap’s scanning phase are referred to as what type of NSE script?

Prerule
Host
Service
Postrule
 Scripts that run individually on each host are referred to as what type of NSE script?

Prerule
Host
Service
Postrule
 What is the most common type of NSE script?

Prerule
Host
Service
Postrule
 Which of the following is the proper syntax to run all scripts in the Safe and Discovery category against the post scanme.nmap.org?

Nmap --script safe & discovery scanme.nmap.org
Nmap --script “safe & discovery” scanme.nmap.org
Nmap --script safe and discovery scanme.nmap.org
Nmap --script “safe and discovery” scanme.nmap.org
 In Kali Linux, where in the file system can you find the NSE scripts by default?

 /usr/share/nmap/scripts
/home/nmap/scripts
/root/nmap/scripts
/etc/shadow
 Which of the following is generally not included in the administrative section of an NSE script?

Description
Author
License
Nmap Version

Answers
