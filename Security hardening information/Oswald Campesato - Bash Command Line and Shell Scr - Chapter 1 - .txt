# Security Chapter Extract
Book: Oswald Campesato - Bash Command Line and Shell Scripts (2020, Mercury Learning and Information LLC.) - libgen.li
Chapter: 1 - ):
Security Relevance Score: 2
Word Count: 970
Extracted: 2025-06-13 23:40:50

---

):
echo $SHELL
Based on the output of the env command that you saw earlier in this section, the output of the preceding command is here:
SHELL=/bin/bash
One other point: if you do not specify the $ character, you will not see the value of the environment variable. For example, if you type:
echo SHELL
Then you will see the following output:
SHELL
Later you will learn how to change the value of a variable, and if you are feeling impatient, you can see some interesting examples of setting an environment variable:
https://stackoverflow.com/questions/13998075/setting-environment-variable-for-one-program-call-in-bash-using-env
Useful Environment Variables
This section discusses some important environment variables, most of which you probably will not need to modify, but it’s useful to be aware of the existence of these variables and their purpose.
The HOME variable contains the absolute path of the user’s home directory
The HOSTNAME variable specifies the Internet name of the host
The LOGNAME variable specifies the user’s login name
The PATH variable specifies the search path (see next subsection)
The SHELL variable specifies the absolute path of the current shell
The USER specifies the user’s current username. This value might be different than the login name if a superuser executes the su command to emulate another user’s permissions.
Setting the PATH Environment Variable
Programs and other executable files can reside in many directories, so operating systems provide a search path that lists the directories that the OS searches for executable files. Tip: if a directory containing an executable file is not included in your PATH environment variable, simply add that directory to your PATH environment variable so that you can invoke an executable file by specifying just the filename: you don’t need to specify the full path to the executable file.
The search path is stored in an environment variable, which is a named string maintained by the operating system. Every environment variable contains information available to the command shell and other programs.
One detail to keep in mind: the path variable is named PATH in bash or Path in Windows (bash is case-sensitive; Windows is not). Set the PATH in bash/Linux as shown here:
export PATH=$HOME/anaconda:$PATH
Here is the command that adds the Python directory to the PATH variable for the current command shell when you are using the bash shell:
export PATH="$PATH:/usr/local/bin/python"
Another way to do the same thing as the preceding code snippet (when you are in the Bourne shell or ksh shell) is with this command:
PATH="$PATH:/usr/local/bin/python"
NOTE
/usr/local/bin/python is the full path of the Python directory
Specifying Aliases and Environment Variables
You can define an environment variable and its value in a straightforward manner. For example, the following command initializes an environment variable called h1:
h1=$HOME/test
Now if you enter the following command:
echo $h1
If the value of $HOME is /Users/jsmith, then you will see the following output on OS X:
/Users/jsmith/test
The next code snippet shows you how to set the alias ll so that it displays a long listing of a directory:
alias ll="ls -l"
The following three alias definitions involve the ls command and various switches:
alias ll="ls – l"
alias lt="ls – lt"
alias ltr="ls – ltr"
As an example, you can replace the command ls -ltr (the letters “l,” “t,” and “r”) that you saw earlier in the chapter with the ltr alias and you will see the same reversed time-based long listing of filenames (reproduced here):
total 56
-rwx------ 1 ocampesato staff 176 Apr 06 19:21 sslinstructions.txt
-rw-r--r-- 1 ocampesato staff 12 Apr 06 19:21 output.txt
-rw-r--r-- 1 ocampesato staff 11 Apr 06 19:21 outfile.txt
-rwx------ 1 ocampesato staff 12 Apr 06 19:21 kyrgyzstan.txt
-rwx------ 1 ocampesato staff 478 Apr 06 19:21 iphonemeetup.txt
-rwx------ 1 ocampesato staff 146 Apr 06 19:21 checkincommands.txt
-rwx------ 1 ocampesato staff 25 Apr 06 19:21 applecare.txt
The bash shell supports the pipe (“|”) symbol that sends the output of one command to the input of another command, which is executed in a left-to-right fashion. For example, the following alias “pipes” the output of ls -1tr to the more command:
alias ltrm="ls – ltr|more"
In a similar manner, you can define aliases for directory-related commands:
alias ltd="ls – lt | grep '^d'"

alias ltdm="ls – lt | grep '^d'|more"
FINDING EXECUTABLE FILES
There are several commands available for finding executable files (binary files or shell scripts) by searching the directories in the PATH environment variable: which, whence, whereis, and whatis. The first pair of commands produce similar results as the which command, as discussed below.
The which command gives the full path to whatever executable that you specify or a blank line if the executable is not in any directory that is specified in the PATH environment variable.” This is useful for finding out whether a particular command or utility is installed in the system.
which rm
The output of the preceding command is here:
/bin/rm
The whereis command provides the information that you get from the where command:
$ whereis rm

/bin/rm
The whatis command looks up the specified command in the whatis database, which is useful for identifying system commands and important configuration files:
git-rm(1)		- Remove files from the working tree
and from the index

grm(1), rm(1)		- remove files or directories

rm(1), unlink(1)	- remove directory entries
Consider it a simplified “man” command, which displays concise details about bash commands (e.g., type man ls and you will see several pages of explanation regarding the ls command).
THE PRINTF COMMAND AND THE ECHO COMMAND
In brief, use the printf command instead of the echo command if you need to control the output format. One key difference is that the echo command prints a newline character, whereas the printf statement does not print a newline character. Keep this point in mind when you see the printf statement in the awk code samples in
