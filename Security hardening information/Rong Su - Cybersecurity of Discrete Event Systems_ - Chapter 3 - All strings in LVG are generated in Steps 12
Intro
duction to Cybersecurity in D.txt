# Security Chapter Extract
Book: Rong Su - Cybersecurity of Discrete Event Systems_ From Smart Attacks to Resilient Defence (2024, CRC Press) - libgen.li
Chapter: 3 - All strings in L(V/G) are generated in Steps (1)–(2).
Intro
duction to Cybersecurity in Discrete Event Systems ■25
Figure 1.13 Automaton
realization of V.
The marked behaviour of V/G is defined as follows:
Lm(V/G) = L(V/G) ∩Lm(G).
In the case that L(V/G) is regular (i.e., it can be generated by a finite
state automaton), there exists an FSA S= (Z,Σ, η, z 0, Zm) such that
L(V/G) = L(S∧G) and Lm(V/G) = Lm(S∧G).
Figure 1.13 depicts the realization of Vby automaton S, where
the output control pattern of Sfor each observation input Po(s)∈
Po(L(G)) is simply the collection of all outgoing transitions after Po(s)
inS, i.e., EnS(Po(s)) := {σ∈Σ|Po(s)σ∈L(S)}.
There are two fundamental questions in the Ramadge-Wonham
paradigm, which are listed below:
Problem 1.1 What language K⊆Lm(G)admits a supervisor Vsuch
thatK=Lm(V/G)?
Problem 1.2 How can one synthesize a supervisor Vsuch that
Lm(V/G) ⊆E⊆Lm(G), where Eis a requirement language, and
the closed-loop system is nonblocking (to ensure that every incomplete
task may be completed later), i.e., L(V/G) = Lm(V/
G)?
To answer the first question, two fundamental concepts are
introduced, i.e., controllability and observability.
Definition 1.4 (Controllability) A language K⊆Lm(G) is
controllable with respect to Gand Σ uc, ifKΣuc∩L(G)⊆K. □
26■Cybersecurit
y of Discrete Event Systems
Definition 1.5 (Observability) [11] A language K⊆L(G) is
observable with respect to GandPo, if
(∀s, s′∈K)(∀σ∈Σ)[
sσ∈K∧s′σ∈L(G)∧P o(s)=Po(
s′)]⇒s′σ∈K.
A
language K⊆L(G) is (prefix) normal with respect to GandPo, if
P−1
o(Po(K))∩L(G) =K.
A
language K⊆C⊆L(G) is relatively observable [125] with respect
toC,GandPo,or
simply C-observable, if
for all s∈K,s′∈Cand
σ∈Σ,
[sσ∈K∧s′σ∈L(G)∧Po(s)=Po(
s′)]⇒s′σ∈K.
□
It
is known that observability is not closed under the set union,
unlike (prefix) normality and C-observ abilit
y. It has been shown that
(prefix) normality implies observability, and observability together with
the condition that Σ c⊆Σoimplies (prefix) normality. Because K⊆C,
we can see that C-observ ab
ility implies observability. On the other
hand, when Kis (prefix) normal with respect to GandPo,Kis also C-
observ able,
namely (prefix) normality implies C-observ abilit
y. With the
concepts of controllability and observability, a sufficient and necessary
condition to ensure the existence of a supervisory control mapping for
a given language K⊆Lm(G) is given in the following theorem.
Theorem 1.1 A language K⊆Lm(G) is realizable by a supervisory
control mapping V, i.e., K=Lm(V/G), if and only if Kis controllable
with respect to Gand Σ uc, and observable with respect to GandPo,
andLm(G)-closed, i.e., K∩Lm(G)=K. □
In
tuitively, controllability of Kensures the existence of a supervisor
Vthat does not disable any uncontrollable event, and observability of
Kensures that Vcan be defined over Po(L(G)). The last condition of
being Lm(G)-closed is to ensure that any string s∈Kcan be identified
(via only the marking information of the plant) when it occurs. Since
the supervisor Vdoes not carry any marking information, to recognize
Intro
duction to Cybersecurity in Discrete Event Systems ■27
a string in K, we can only rely on the marking of the plant G, i.e., we
need to ensure that, under the influence of V, a string s∈Kholds if
and only if s∈L(V/G) and s∈Lm(G).
To answer the second question, we need to find a controllable,
observable, and nonblocking sublanguage of E. A solution is typically
not unique. This may cause practical issues, as sometimes trivial
solutions may be generated. To avoid this unpleasant situation, it has
been shown that, controllable and observable languages form a partially
ordered set (poset) with the partial order induced by the set inclusion.
Thus, typically a maximal controllable and observable sublanguage
within a given requirement language Eis sought in synthesis. When
observability is strengthened as relative observability or normality, the
poset becomes an upper semilattice and a unique supremal element
exists, which is sought in most supervisor synthesis literature. Tools
are available to synthesize such supremal controllable and normal
(or relatively observable) sublanguages, see, e.g., SuSYNA developed
at Nanyang Technological University (https://personal.ntu.edu.sg/
rsu/Downloads.htm), TCT [122] (https://www.control.utoronto.ca/
∼wonham/Research.html) developed at the University of Toronto,
and Supremica [123] (https://supremica.org/) developed at Chalmers
University of Technology .
This section is not meant to provide a thorough overview of
supervisory control theory, which would fit in a separate monograph.
More advanced supervisory control theory, e.g., decentralized control,
modular control, distributed control, hierarchical control, symbolic
synthesis, etc., can be found in Refs. [2,3].
Security Relevance Score: 4
Word Count: 982
Extracted: 2025-06-13 23:40:25

---

All strings in L(V/G) are generated in Steps (1)–(2).
Intro
duction to Cybersecurity in Discrete Event Systems ■25
Figure 1.13 Automaton
realization of V.
The marked behaviour of V/G is defined as follows:
Lm(V/G) = L(V/G) ∩Lm(G).
In the case that L(V/G) is regular (i.e., it can be generated by a finite
state automaton), there exists an FSA S= (Z,Σ, η, z 0, Zm) such that
L(V/G) = L(S∧G) and Lm(V/G) = Lm(S∧G).
Figure 1.13 depicts the realization of Vby automaton S, where
the output control pattern of Sfor each observation input Po(s)∈
Po(L(G)) is simply the collection of all outgoing transitions after Po(s)
inS, i.e., EnS(Po(s)) := {σ∈Σ|Po(s)σ∈L(S)}.
There are two fundamental questions in the Ramadge-Wonham
paradigm, which are listed below:
Problem 1.1 What language K⊆Lm(G)admits a supervisor Vsuch
thatK=Lm(V/G)?
Problem 1.2 How can one synthesize a supervisor Vsuch that
Lm(V/G) ⊆E⊆Lm(G), where Eis a requirement language, and
the closed-loop system is nonblocking (to ensure that every incomplete
task may be completed later), i.e., L(V/G) = Lm(V/
G)?
To answer the first question, two fundamental concepts are
introduced, i.e., controllability and observability.
Definition 1.4 (Controllability) A language K⊆Lm(G) is
controllable with respect to Gand Σ uc, ifKΣuc∩L(G)⊆K. □
26■Cybersecurit
y of Discrete Event Systems
Definition 1.5 (Observability) [11] A language K⊆L(G) is
observable with respect to GandPo, if
(∀s, s′∈K)(∀σ∈Σ)[
sσ∈K∧s′σ∈L(G)∧P o(s)=Po(
s′)]⇒s′σ∈K.
A
language K⊆L(G) is (prefix) normal with respect to GandPo, if
P−1
o(Po(K))∩L(G) =K.
A
language K⊆C⊆L(G) is relatively observable [125] with respect
toC,GandPo,or
simply C-observable, if
for all s∈K,s′∈Cand
σ∈Σ,
[sσ∈K∧s′σ∈L(G)∧Po(s)=Po(
s′)]⇒s′σ∈K.
□
It
is known that observability is not closed under the set union,
unlike (prefix) normality and C-observ abilit
y. It has been shown that
(prefix) normality implies observability, and observability together with
the condition that Σ c⊆Σoimplies (prefix) normality. Because K⊆C,
we can see that C-observ ab
ility implies observability. On the other
hand, when Kis (prefix) normal with respect to GandPo,Kis also C-
observ able,
namely (prefix) normality implies C-observ abilit
y. With the
concepts of controllability and observability, a sufficient and necessary
condition to ensure the existence of a supervisory control mapping for
a given language K⊆Lm(G) is given in the following theorem.
Theorem 1.1 A language K⊆Lm(G) is realizable by a supervisory
control mapping V, i.e., K=Lm(V/G), if and only if Kis controllable
with respect to Gand Σ uc, and observable with respect to GandPo,
andLm(G)-closed, i.e., K∩Lm(G)=K. □
In
tuitively, controllability of Kensures the existence of a supervisor
Vthat does not disable any uncontrollable event, and observability of
Kensures that Vcan be defined over Po(L(G)). The last condition of
being Lm(G)-closed is to ensure that any string s∈Kcan be identified
(via only the marking information of the plant) when it occurs. Since
the supervisor Vdoes not carry any marking information, to recognize
Intro
duction to Cybersecurity in Discrete Event Systems ■27
a string in K, we can only rely on the marking of the plant G, i.e., we
need to ensure that, under the influence of V, a string s∈Kholds if
and only if s∈L(V/G) and s∈Lm(G).
To answer the second question, we need to find a controllable,
observable, and nonblocking sublanguage of E. A solution is typically
not unique. This may cause practical issues, as sometimes trivial
solutions may be generated. To avoid this unpleasant situation, it has
been shown that, controllable and observable languages form a partially
ordered set (poset) with the partial order induced by the set inclusion.
Thus, typically a maximal controllable and observable sublanguage
within a given requirement language Eis sought in synthesis. When
observability is strengthened as relative observability or normality, the
poset becomes an upper semilattice and a unique supremal element
exists, which is sought in most supervisor synthesis literature. Tools
are available to synthesize such supremal controllable and normal
(or relatively observable) sublanguages, see, e.g., SuSYNA developed
at Nanyang Technological University (https://personal.ntu.edu.sg/
rsu/Downloads.htm), TCT [122] (https://www.control.utoronto.ca/
∼wonham/Research.html) developed at the University of Toronto,
and Supremica [123] (https://supremica.org/) developed at Chalmers
University of Technology .
This section is not meant to provide a thorough overview of
supervisory control theory, which would fit in a separate monograph.
More advanced supervisory control theory, e.g., decentralized control,
modular control, distributed control, hierarchical control, symbolic
synthesis, etc., can be found in Refs. [2,3].

I
Mo
deling and Synthesis of Smart
Attacks

CH
A P T E R2
Sm
art Sensor Attacks
We
start with sensor attacks, which are commonly seen in our daily life
and conceptually simple. Such simplicity will make it relatively easy
for us to introduce a formal modeling framework and relevant design
techniques. We will follow a natural order of thinking typically used
by a rational person to investigate a new phenomenon and answer the
following questions: what is a sensor attack; when can we say a sensor
attack is smart; how to design a smart sensor attack; and finally, how
to defend a system against all smart sensor attacks. A sensor attack in
this chapter will be modeled as a function, which maps each intercepted
plant observable output to a “faked” observable output that eventually
affects the output of a given supervisor. We will illustrate that, by
“smartly” changing the supervisor’s observable input, a sensor attack
can leverage on existing supervisory control function to inflict damage
to the plant, without being detected by the supervisor. That is, we
consider an attack to be smart if it is kept covert (or stealthy) until
irreversible damage is inflicted on a target system. We will explain how
to decide whether a given closed-loop system permits a smart sensor
attack. Upon such knowledge, we will introduce one method to design
a supervisor that is robust to all possible smart sensor attacks. This
chapter serves as one major building block for subsequent technical
development.
2.1 INTRODUCTION
Acyb
er-physical system (CPS) is a mechanism controlled or monitored
by computer-based algorithms. Examples of CPS include smart grid,
DOI: 10.1201/9781003333883-3 31
