# Security Chapter Extract
Book: Steve Campbell - Bash Shell Scripting for Pentesters_ Master the art of command-line exploitation and enhance your penetration testing workflows (2024, Packt Publishing) - libgen.li
Chapter: 01 - Introduction to Bash
Bash, also known as the Bourne Again Shell, is a command-line shell interpreter and scripting language. 
Bash  was created by Brian Fox in 1989 as a free software replacement for the Bourne shell, which was 
proprietary software. (Bash – GNU Project – Free Software Foundation, https://www.gnu.org/
software/bash/). It’s the most common Linux shell. Bash also introduced the ability to combine 
multiple commands into shell scripts that could be run by entering one command.
When you open a Terminal on a Linux system and enter commands, your Bash shell manages interactions 
with the operating system and running executables and scripts. Bash and Linux executables form a 
symbiotic relationship, each enhancing the functionality and efficiency of the other. Bash serves as 
the gateway for users and scripts to interact with the Linux kernel, the core of the operating system. 
It interprets user commands, whether entered directly into the Terminal or scripted in files, and 
initiates actions within the system. Linux executables, on the other hand, are the workhorses that 
carry out these actions. They are binary files, often written in programming languages such as C or 
C++, compiled to run efficiently on Linux systems. When a user issues a command in Bash, it often 
involves invoking one or more of these executables to perform a task.
Introduction to Bash
 5
The following are some of Bash’s features:
• Command execution with arguments: Commands can be binaries, built-in shell commands, 
and scripts.
• Command completion: A feature that helps the user by automatically completing partially 
typed commands or filenames upon the Tab  key being pressed.
• Command history: Command history allows you to quickly reuse commands previously 
entered in the shell.
• Job control : Sending commands to the background and bringing them to the foreground.
• Shell functions and alias : A function groups related code under a name that can be called when 
needed. An alias allows the user to shorten complex commands to a single name.
• Arrays : Arrays store elements in a list that we can later retrieve and process.
• Command and brace expansion: Command expansion uses the result of a command as the 
input for another command. Brace expansion allows strings to be generated.
• Pipelines and redirection: The output of one command is used as input for another command.
• Environment variables: Dynamic values are assigned to name tags, which are frequently used 
to represent system configuration or store information about the environment.
• Filesystem navigation: Bash provides commands to change directories, print the current 
directory, and find files and directories.
• Help : The man command, short for manual , provides the user with information and examples 
of how to execute commands.
Bash scripting is one of the most important skills that I’ve learned in my pentesting career and that 
I use daily. When you’re developing applications, at some point, you’ll find the need to use another 
scripting language, such as Python. In most cases, anything you could want to do at the Terminal can 
be done in Bash, with Bash orchestrating the input and output and parsing the data from multiple 
tools. Bash is so deeply integrated with the Linux operating system that it makes sense to learn it before 
branching out into scripting languages such as Python or Ruby. Despite knowing multiple scripting 
and programming languages, Bash is the one that I use most often due to its tight integration with the 
shell and how easy it is to quickly get results with a one-line or even one-word command.
On any given day in my work as a pentester, I use Bash to parse data or automate chaining together 
multiple tools. When a customer gives me scoping data, I must frequently copy a list of scoped IP 
addresses or hostnames from a Rules of Engagement document, email, or Excel spreadsheet and paste 
it into a text file. Inevitably, there are stray characters in the data, or the data isn’t formatted cleanly for 
use as a list of scan targets. I can use Bash to clean up the file data and format it as I need for testing 
purposes with one simple line of code entered in my Terminal.
Bash Command-Line and Its Hacking Environment 6
Pentesting tools accept data in various formats, and output scan results or data in common formats 
such as XML, JSON, or plain text. The plain text output may be formatted with multiple spaces, tabs, 
or a combination. I pipe the contents of a source file and pass it through the Bash pipeline to parse, 
clean, reformat, and sort the data. I may use a combination of Bash commands to perform these 
actions in between the output of one command and the input of another in an automation pipeline. 
Bash truly is an indispensable tool in a pentester’s toolbox.
The following are some common uses for Bash scripting in my pentesting workflow:
• Automated network scanning: I frequently process the output of Masscan, a fast TCP scanner, 
and feed it to Nmap for in-depth service detection and script scanning.
• Password cracking: I use a Bash script for a complex series of password cracking functions 
related to cracking Microsoft LM and NTLM hashes and formatting the output of Hashcat for 
input into a reporting tool.
• Searching text: Searching for IP addresses or other details in text.
• Scoping automation : I use subdomain enumeration tools with a Bash script to ensure the 
discovered subdomains are in the scope of the pentest rules of engagement.
• Formatting data: I use Bash to parse and reformat the output of Nuclei scans to enumerate 
subdomains and web applications from TLS certificates and reformat the data for use in 
bypassing content delivery networks  (CDNs ) to bypass a web application firewall  (WA F ) 
and scan the target directly.
• Searching and sorting Nmap reports: After scanning hundreds or even thousands of IP 
addresses, I use Bash to parse the gnmap files to create text files containing targets organized 
by TCP or UDP ports for use in more targeted scans. For example, all SMB servers or HTTP 
servers’ IP addresses are carved out and placed into files named smb.txt and http.txt.
• Sorting data and deduplication: Sort the unique IP addresses into a file for deduplication.
• Data conversion: Convert first and last names into various formats for password spraying. 
If I can get a list of employee names through Open Source Intelligence  (OSINT ), I’ll look 
at anything that may tip me off to how their Active Directory names are formatted, such as 
f.last or first.last, and use Bash to format the names appropriately.
• Data filtering: Occasionally, I have to remove Terminal color codes from tool output log files 
for use in reporting because I forgot to include a command-line flag for no color, or the tool 
may not have this option. I don’t want to screenshot data for my customer’s report with it 
containing color codes that make the data confusing to read.
• Iterating over data: I use Bash for and while loops to loop through a file and run a command 
on each line. A good example of this is when you need to use a tool that scans one host at a 
time with no option to process multiple targets.
Lab setup
 7
I’m confident that learning Bash scripting will make you more efficient with your time and more 
effective in your job. When you can automate time-intensive, boring tasks using Bash, it frees up your 
time to take on more important things. Wouldn’t it be great to have more time for learning or research 
instead of wasting it on manual tasks that can be automated with little effort?
Now that we have a basic understanding of Bash and why it’s useful in our pentesting endeavors, let’s 
explore how to set up a lab environment where you can safely learn and follow along with the exercises. 
In the next section, we’ll explore setting up your lab environment so that you can follow along with me.
Lab setup
Bash isn’t the only shell interpreter for Linux and Unix systems, but it is the most common. Other 
shells were influenced by Bash. Y ou may also encounter Zsh on macOS and Kali Linux.
Y ou might be wondering why this book has chosen to focus on Bash, despite some operating systems 
switching to Zsh. While macOS and Kali have switched to Zsh for new user accounts, they still have 
Bash installed. Most code written for Bash will also work on Zsh with a few minor changes. Y ou 
can include a shebang  line in your shell scripts to ensure that the Bash interpreter runs your script 
on systems where multiple shells are installed. While performing security assessments, you’re very 
likely to encounter Linux servers where Bash is the default shell. It will be essential for a pentester to 
understand how to interact with Bash to exploit applications, escalate privileges, and move laterally.
Fortunately, there are many ways you can access a Bash shell for free. This section will explore a variety 
of ways you can access a Bash shell in an ideal setting so that you can follow along and learn how 
to use Bash for pentesting. We will also explore vulnerable lab environments where you can safely 
practice using Bash and pentesting tools.
Virtual machines are the preferred way to follow along with this book’s activities, as well as when 
performing pentesting. Y ou may be tempted to install your pentesting tools and exploit code on the 
same system you use for business or personal activities. It’s easy to damage your system by installing 
software prerequisites for various tools. There’s always a risk of hacking tools containing malware and 
infecting the same system that you use from day to day to send emails or access the web. A virtual 
machine provides a convenient sandbox environment with everything you need to quickly refresh or 
replace a testing environment. I have chosen to use Kali Linux in all demonstrations. We want to avoid 
installing pentesting tools and exploit code in the same system we use daily for business or personal 
use. It’s best to use a clean testing environment to avoid creating software dependency issues for us. 
Kali makes it easy to install the needed software packages related to pentesting.
Virtual machines
Using a virtual machine is the preferred method. During a pentest, you’ll likely install a multitude 
of tools and exploit proof of concept code. At some point, you’ll also save sensitive data about your 
customer or target. A virtual machine provides a convenient container that you can snapshot and 
restore, or  delete and replace easily after an assessment.
Bash Command-Line and Its Hacking Environment 8
There are numerous free and paid virtualization solutions to fit any need:
• Oracle VirtualBox is a free x86 virtualization hypervisor. It’s available for Windows, macOS 
(Intel chipset), and Linux. VirtualBox is user-friendly, making it a popular choice for beginners 
and professionals alike. It supports a wide range of guest operating systems and offers features 
such as snapshots, seamless mode, and shared folders.
• VMware offers a free version of their virtualization software called VMware Workstation Player 
for non-commercial use. It’s compatible with Windows and Linux hosts. Workstation Player 
is easy to use and supports VMware’s VMDK virtual disk format, and it’s also compatible with 
virtual machines created by other VMware products.
• Microsoft Hyper-V is free and available on Windows 10 Pro, Enterprise, and Education editions. 
While it’s more commonly used in server environments, Hyper-V can also be a good option 
for desktop virtualization on Microsoft Windows hosts.
Tip
For those on macOS with the Apple CPU, your virtualization options are UTM, Parallels, and 
VMWare Fusion. UTM is the only free option.
Docker containers
Docker containers offer a lightweight option over virtual machines. Docker offers a runtime for 
Windows, Linux, and macOS. Containers are more lightweight and efficient on lower-end hardware 
than virtual machines because they use the host’s kernel, so they don’t have to virtualize hardware as 
traditional hypervisors do.
Because Docker uses the host’s kernel, you’re limited to running containers while utilizing the same 
operating system as the host. Docker Desktop is an alternative that uses a virtual machine to run 
containers with a different operating system from the host.
Based on my experience, there are some positive and negative points to consider about using Docker.
Docker is more lightweight and is a good alternative to traditional hypervisors when your hardware 
is less robust. The minimum hardware resources I would assign to a virtual machine running Kali 
Linux is 4 GB of RAM and 40 GB of disk space. Y ou’re not always going to be using that 4 GB/40 GB. 
At the same time, you’re limited to those values unless you shut down the virtual machine, adjust the 
RAM, and extend the disk. A Docker container runs in a native process (excluding Docker Desktop), 
so it uses only as much memory and disk space as needed to run the container.
Lab setup
 9
On a Linux host, you can attach a container directly to the host network and open and close ports as 
needed, provided you include specific command-line arguments. This allows you to dynamically open 
listening server ports on the host’s network adapter without stopping and starting the container. Y ou 
can also attach a container to a USB or serial port to interface with hardware devices. I sometimes 
use this option when I need to run an old Python2 pentesting application that interfaces with a USB 
or serial device for radio frequency and hardware hacking.
When using Docker Desktop, NAT is used to connect container network ports to the host’s network, 
so the container must be stopped and restarted if you need to close or open additional ports. With 
Docker Desktop, it isn’t possible to attach a container to hardware devices. This can be aggravating 
when you’ve configured an application and its dependencies on a container and then lose your work 
and have to start over when you destroy the container and start a new instance, just to open another 
TCP port for a reverse listener or server application.
In summary, my preference is to use Docker only on a Linux host, and I use it for three specific 
pentesting use cases:
• It provides an easy way to isolate old Python 2 applications and avoid dependency hell. There 
are official Docker containers for all Python 2 and 3 versions.
• I use it to create and run applications that aren’t available through my package manager, and 
I want to avoid wasting time solving dependency issues. For example, a particular hacking 
tool is available through the Kali software repository, but not in Ubuntu. I can create a thin 
Kali container that uses only enough resources to run the contained application and use an 
alias in my ~/.bashrc file to reduce a long docker run command to a single word I can 
enter in my Terminal. This is a much faster and more lightweight option than a heavy virtual 
machine when I just want to run a single application that can’t be run or would be difficult to 
run on my host system.
• When I want to practice exploiting or creating an exploit tool for a recently announced vulnerable 
web application, I can frequently find a Docker container that allows me to immediately start 
the vulnerable application without spending precious time installing and configuring it.
Docker containers are perfect for specific use cases. However, they’re less preferred than virtual machines. 
Next, we’ll explore using live USB systems as an alternative to virtual machines and containers.
Live USB
A live USB is an operating system image written to a USB disk in a way that makes it bootable. Live 
USB is a good choice to use when your computer doesn’t have the hardware resources to run a virtual 
machine. Y ou can use imaging software to burn Linux ISO disks to USB and boot a Linux operating 
system. After you finish your work on Linux, you simply restart the computer and remove the USB drive 
to revert to the installed operating system. Some Linux distributions enable you to create persistent 
storage on the USB drive so that you don’t lose your changes when you reboot.
Bash Command-Line and Its Hacking Environment 10
The following are some general steps for running a Linux distribution from live USB:
Security Relevance Score: 19
Word Count: 2743
Extracted: 2025-06-13 23:40:19

---

Introduction to Bash
Bash, also known as the Bourne Again Shell, is a command-line shell interpreter and scripting language. 
Bash  was created by Brian Fox in 1989 as a free software replacement for the Bourne shell, which was 
proprietary software. (Bash – GNU Project – Free Software Foundation, https://www.gnu.org/
software/bash/). It’s the most common Linux shell. Bash also introduced the ability to combine 
multiple commands into shell scripts that could be run by entering one command.
When you open a Terminal on a Linux system and enter commands, your Bash shell manages interactions 
with the operating system and running executables and scripts. Bash and Linux executables form a 
symbiotic relationship, each enhancing the functionality and efficiency of the other. Bash serves as 
the gateway for users and scripts to interact with the Linux kernel, the core of the operating system. 
It interprets user commands, whether entered directly into the Terminal or scripted in files, and 
initiates actions within the system. Linux executables, on the other hand, are the workhorses that 
carry out these actions. They are binary files, often written in programming languages such as C or 
C++, compiled to run efficiently on Linux systems. When a user issues a command in Bash, it often 
involves invoking one or more of these executables to perform a task.
Introduction to Bash
 5
The following are some of Bash’s features:
• Command execution with arguments: Commands can be binaries, built-in shell commands, 
and scripts.
• Command completion: A feature that helps the user by automatically completing partially 
typed commands or filenames upon the Tab  key being pressed.
• Command history: Command history allows you to quickly reuse commands previously 
entered in the shell.
• Job control : Sending commands to the background and bringing them to the foreground.
• Shell functions and alias : A function groups related code under a name that can be called when 
needed. An alias allows the user to shorten complex commands to a single name.
• Arrays : Arrays store elements in a list that we can later retrieve and process.
• Command and brace expansion: Command expansion uses the result of a command as the 
input for another command. Brace expansion allows strings to be generated.
• Pipelines and redirection: The output of one command is used as input for another command.
• Environment variables: Dynamic values are assigned to name tags, which are frequently used 
to represent system configuration or store information about the environment.
• Filesystem navigation: Bash provides commands to change directories, print the current 
directory, and find files and directories.
• Help : The man command, short for manual , provides the user with information and examples 
of how to execute commands.
Bash scripting is one of the most important skills that I’ve learned in my pentesting career and that 
I use daily. When you’re developing applications, at some point, you’ll find the need to use another 
scripting language, such as Python. In most cases, anything you could want to do at the Terminal can 
be done in Bash, with Bash orchestrating the input and output and parsing the data from multiple 
tools. Bash is so deeply integrated with the Linux operating system that it makes sense to learn it before 
branching out into scripting languages such as Python or Ruby. Despite knowing multiple scripting 
and programming languages, Bash is the one that I use most often due to its tight integration with the 
shell and how easy it is to quickly get results with a one-line or even one-word command.
On any given day in my work as a pentester, I use Bash to parse data or automate chaining together 
multiple tools. When a customer gives me scoping data, I must frequently copy a list of scoped IP 
addresses or hostnames from a Rules of Engagement document, email, or Excel spreadsheet and paste 
it into a text file. Inevitably, there are stray characters in the data, or the data isn’t formatted cleanly for 
use as a list of scan targets. I can use Bash to clean up the file data and format it as I need for testing 
purposes with one simple line of code entered in my Terminal.
Bash Command-Line and Its Hacking Environment 6
Pentesting tools accept data in various formats, and output scan results or data in common formats 
such as XML, JSON, or plain text. The plain text output may be formatted with multiple spaces, tabs, 
or a combination. I pipe the contents of a source file and pass it through the Bash pipeline to parse, 
clean, reformat, and sort the data. I may use a combination of Bash commands to perform these 
actions in between the output of one command and the input of another in an automation pipeline. 
Bash truly is an indispensable tool in a pentester’s toolbox.
The following are some common uses for Bash scripting in my pentesting workflow:
• Automated network scanning: I frequently process the output of Masscan, a fast TCP scanner, 
and feed it to Nmap for in-depth service detection and script scanning.
• Password cracking: I use a Bash script for a complex series of password cracking functions 
related to cracking Microsoft LM and NTLM hashes and formatting the output of Hashcat for 
input into a reporting tool.
• Searching text: Searching for IP addresses or other details in text.
• Scoping automation : I use subdomain enumeration tools with a Bash script to ensure the 
discovered subdomains are in the scope of the pentest rules of engagement.
• Formatting data: I use Bash to parse and reformat the output of Nuclei scans to enumerate 
subdomains and web applications from TLS certificates and reformat the data for use in 
bypassing content delivery networks  (CDNs ) to bypass a web application firewall  (WA F ) 
and scan the target directly.
• Searching and sorting Nmap reports: After scanning hundreds or even thousands of IP 
addresses, I use Bash to parse the gnmap files to create text files containing targets organized 
by TCP or UDP ports for use in more targeted scans. For example, all SMB servers or HTTP 
servers’ IP addresses are carved out and placed into files named smb.txt and http.txt.
• Sorting data and deduplication: Sort the unique IP addresses into a file for deduplication.
• Data conversion: Convert first and last names into various formats for password spraying. 
If I can get a list of employee names through Open Source Intelligence  (OSINT ), I’ll look 
at anything that may tip me off to how their Active Directory names are formatted, such as 
f.last or first.last, and use Bash to format the names appropriately.
• Data filtering: Occasionally, I have to remove Terminal color codes from tool output log files 
for use in reporting because I forgot to include a command-line flag for no color, or the tool 
may not have this option. I don’t want to screenshot data for my customer’s report with it 
containing color codes that make the data confusing to read.
• Iterating over data: I use Bash for and while loops to loop through a file and run a command 
on each line. A good example of this is when you need to use a tool that scans one host at a 
time with no option to process multiple targets.
Lab setup
 7
I’m confident that learning Bash scripting will make you more efficient with your time and more 
effective in your job. When you can automate time-intensive, boring tasks using Bash, it frees up your 
time to take on more important things. Wouldn’t it be great to have more time for learning or research 
instead of wasting it on manual tasks that can be automated with little effort?
Now that we have a basic understanding of Bash and why it’s useful in our pentesting endeavors, let’s 
explore how to set up a lab environment where you can safely learn and follow along with the exercises. 
In the next section, we’ll explore setting up your lab environment so that you can follow along with me.
Lab setup
Bash isn’t the only shell interpreter for Linux and Unix systems, but it is the most common. Other 
shells were influenced by Bash. Y ou may also encounter Zsh on macOS and Kali Linux.
Y ou might be wondering why this book has chosen to focus on Bash, despite some operating systems 
switching to Zsh. While macOS and Kali have switched to Zsh for new user accounts, they still have 
Bash installed. Most code written for Bash will also work on Zsh with a few minor changes. Y ou 
can include a shebang  line in your shell scripts to ensure that the Bash interpreter runs your script 
on systems where multiple shells are installed. While performing security assessments, you’re very 
likely to encounter Linux servers where Bash is the default shell. It will be essential for a pentester to 
understand how to interact with Bash to exploit applications, escalate privileges, and move laterally.
Fortunately, there are many ways you can access a Bash shell for free. This section will explore a variety 
of ways you can access a Bash shell in an ideal setting so that you can follow along and learn how 
to use Bash for pentesting. We will also explore vulnerable lab environments where you can safely 
practice using Bash and pentesting tools.
Virtual machines are the preferred way to follow along with this book’s activities, as well as when 
performing pentesting. Y ou may be tempted to install your pentesting tools and exploit code on the 
same system you use for business or personal activities. It’s easy to damage your system by installing 
software prerequisites for various tools. There’s always a risk of hacking tools containing malware and 
infecting the same system that you use from day to day to send emails or access the web. A virtual 
machine provides a convenient sandbox environment with everything you need to quickly refresh or 
replace a testing environment. I have chosen to use Kali Linux in all demonstrations. We want to avoid 
installing pentesting tools and exploit code in the same system we use daily for business or personal 
use. It’s best to use a clean testing environment to avoid creating software dependency issues for us. 
Kali makes it easy to install the needed software packages related to pentesting.
Virtual machines
Using a virtual machine is the preferred method. During a pentest, you’ll likely install a multitude 
of tools and exploit proof of concept code. At some point, you’ll also save sensitive data about your 
customer or target. A virtual machine provides a convenient container that you can snapshot and 
restore, or  delete and replace easily after an assessment.
Bash Command-Line and Its Hacking Environment 8
There are numerous free and paid virtualization solutions to fit any need:
• Oracle VirtualBox is a free x86 virtualization hypervisor. It’s available for Windows, macOS 
(Intel chipset), and Linux. VirtualBox is user-friendly, making it a popular choice for beginners 
and professionals alike. It supports a wide range of guest operating systems and offers features 
such as snapshots, seamless mode, and shared folders.
• VMware offers a free version of their virtualization software called VMware Workstation Player 
for non-commercial use. It’s compatible with Windows and Linux hosts. Workstation Player 
is easy to use and supports VMware’s VMDK virtual disk format, and it’s also compatible with 
virtual machines created by other VMware products.
• Microsoft Hyper-V is free and available on Windows 10 Pro, Enterprise, and Education editions. 
While it’s more commonly used in server environments, Hyper-V can also be a good option 
for desktop virtualization on Microsoft Windows hosts.
Tip
For those on macOS with the Apple CPU, your virtualization options are UTM, Parallels, and 
VMWare Fusion. UTM is the only free option.
Docker containers
Docker containers offer a lightweight option over virtual machines. Docker offers a runtime for 
Windows, Linux, and macOS. Containers are more lightweight and efficient on lower-end hardware 
than virtual machines because they use the host’s kernel, so they don’t have to virtualize hardware as 
traditional hypervisors do.
Because Docker uses the host’s kernel, you’re limited to running containers while utilizing the same 
operating system as the host. Docker Desktop is an alternative that uses a virtual machine to run 
containers with a different operating system from the host.
Based on my experience, there are some positive and negative points to consider about using Docker.
Docker is more lightweight and is a good alternative to traditional hypervisors when your hardware 
is less robust. The minimum hardware resources I would assign to a virtual machine running Kali 
Linux is 4 GB of RAM and 40 GB of disk space. Y ou’re not always going to be using that 4 GB/40 GB. 
At the same time, you’re limited to those values unless you shut down the virtual machine, adjust the 
RAM, and extend the disk. A Docker container runs in a native process (excluding Docker Desktop), 
so it uses only as much memory and disk space as needed to run the container.
Lab setup
 9
On a Linux host, you can attach a container directly to the host network and open and close ports as 
needed, provided you include specific command-line arguments. This allows you to dynamically open 
listening server ports on the host’s network adapter without stopping and starting the container. Y ou 
can also attach a container to a USB or serial port to interface with hardware devices. I sometimes 
use this option when I need to run an old Python2 pentesting application that interfaces with a USB 
or serial device for radio frequency and hardware hacking.
When using Docker Desktop, NAT is used to connect container network ports to the host’s network, 
so the container must be stopped and restarted if you need to close or open additional ports. With 
Docker Desktop, it isn’t possible to attach a container to hardware devices. This can be aggravating 
when you’ve configured an application and its dependencies on a container and then lose your work 
and have to start over when you destroy the container and start a new instance, just to open another 
TCP port for a reverse listener or server application.
In summary, my preference is to use Docker only on a Linux host, and I use it for three specific 
pentesting use cases:
• It provides an easy way to isolate old Python 2 applications and avoid dependency hell. There 
are official Docker containers for all Python 2 and 3 versions.
• I use it to create and run applications that aren’t available through my package manager, and 
I want to avoid wasting time solving dependency issues. For example, a particular hacking 
tool is available through the Kali software repository, but not in Ubuntu. I can create a thin 
Kali container that uses only enough resources to run the contained application and use an 
alias in my ~/.bashrc file to reduce a long docker run command to a single word I can 
enter in my Terminal. This is a much faster and more lightweight option than a heavy virtual 
machine when I just want to run a single application that can’t be run or would be difficult to 
run on my host system.
• When I want to practice exploiting or creating an exploit tool for a recently announced vulnerable 
web application, I can frequently find a Docker container that allows me to immediately start 
the vulnerable application without spending precious time installing and configuring it.
Docker containers are perfect for specific use cases. However, they’re less preferred than virtual machines. 
Next, we’ll explore using live USB systems as an alternative to virtual machines and containers.
Live USB
A live USB is an operating system image written to a USB disk in a way that makes it bootable. Live 
USB is a good choice to use when your computer doesn’t have the hardware resources to run a virtual 
machine. Y ou can use imaging software to burn Linux ISO disks to USB and boot a Linux operating 
system. After you finish your work on Linux, you simply restart the computer and remove the USB drive 
to revert to the installed operating system. Some Linux distributions enable you to create persistent 
storage on the USB drive so that you don’t lose your changes when you reboot.
Bash Command-Line and Its Hacking Environment 10
The following are some general steps for running a Linux distribution from live USB:
