# Security Chapter Extract
Book: Michael Kofler - Scripting_ Automation with Bash, PowerShell, and Python (2024, Rheinwerk Publishing) - libgen.li
Chapter: 4 - 7) and then pass this information to the cmdlet. The keys in the hash table must match the option names of the command. The following example reuses the above Get-ChildItem statement and clarifies the syntax:
$opts = @{ Path = "C:\Users"; Recurse = $true; Filter = "*.png" }Get-ChildItem @opts 
Other splatting variants are documented at https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_splatting.
4.3.6    Functions
In script programming, you can easily combine multiple PowerShell commands into one function (Section 4.11). To pass functions, save the code as a module (file identifier *.psm1) in one of the designated directories ($env:PSModulePath).
If modules are installed correctly, the functions defined in them cannot be distinguished from “real” cmdlets. Microsoft also makes intensive use of this option: Of the approximately 1,900 commands available for selection in a standard installation of PowerShell on Windows 11, more than half are functions.
> (Get-Command -CommandType Function | Measure-Object).Count  1028> (Get-Command -CommandType cmdlet | Measure-Object).Count  843 
This concatenation of the Get-Command and Measure-Object commands is an example of using the pipe operator, which I will introduce in more detail in Section 4.4.
4.3.7    Running Conventional Commands
Finally, you can also run traditional commands in PowerShell. An example of such a command is ping (usually C:\Windows\System32\PING.EXE) for testing network connections. However, traditional commands have the disadvantage that they do not behave like cmdlets; for instance, they return text instead of objects.
Syntactically things get complicated with commands that are located at directories where PowerShell does not search (i.e., which are not known to the $Path environment variable). The attempt to simply specify the entire path then often fails due to the use of spaces:
> C:\Program Files\Git\usr\bin\nano.exe myfile.txt  'C:\Program' is not recognized as a name of a cmdlet ... 
The program must then be started using the & call operator, which is passed a string with the entire path in the first parameter. This operator can be followed by separate parameters and options.
> & "C:\Program Files\Git\usr\bin\nano.exe"  "myfile.txt" 
4.3.8    Online Help
This book lacks the space for a comprehensive description of all cmdlets (but look at Chapter 7). For this reason, I will keep introducing you to new cmdlets through my examples.
Fortunately, PowerShell is equipped with excellent help features. Get-Help <command> (extended by the -Examples, -Detailed, or -Full options as required) returns comprehensive help texts for any command. If you additionally pass the -Online option, the help text will be displayed in the web browser.
The first time Get-Help is called, PowerShell may indicate that the local help files are incomplete. The solution to this problem is to run Update-Help -UICulture en-US once. The -UICulture option is necessary because most help texts are only available in English. However, download errors often occur despite this option because, for some (often smaller) modules, no help texts are available at all.
If you’re looking for a command, Get-Command will always help. Without further options, it simply provides a list of all commands. Using Select-String, you can then filter the almost endless output. The following command generates a sorted list of all commands that contain the search term VM, which obviously control virtual machines:
> Get-Command | Select-String VM | Sort-Object  Add-NetEventVmNetworkAdapter  Add-NetEventVmSwitch  ... 
Get-Command offers a lot more search options. Check out Get-Help Get-Command -Examples!
Security Relevance Score: 2
Word Count: 583
Extracted: 2025-06-13 23:41:06

---

7) and then pass this information to the cmdlet. The keys in the hash table must match the option names of the command. The following example reuses the above Get-ChildItem statement and clarifies the syntax:
$opts = @{ Path = "C:\Users"; Recurse = $true; Filter = "*.png" }Get-ChildItem @opts 
Other splatting variants are documented at https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_splatting.
4.3.6    Functions
In script programming, you can easily combine multiple PowerShell commands into one function (Section 4.11). To pass functions, save the code as a module (file identifier *.psm1) in one of the designated directories ($env:PSModulePath).
If modules are installed correctly, the functions defined in them cannot be distinguished from “real” cmdlets. Microsoft also makes intensive use of this option: Of the approximately 1,900 commands available for selection in a standard installation of PowerShell on Windows 11, more than half are functions.
> (Get-Command -CommandType Function | Measure-Object).Count  1028> (Get-Command -CommandType cmdlet | Measure-Object).Count  843 
This concatenation of the Get-Command and Measure-Object commands is an example of using the pipe operator, which I will introduce in more detail in Section 4.4.
4.3.7    Running Conventional Commands
Finally, you can also run traditional commands in PowerShell. An example of such a command is ping (usually C:\Windows\System32\PING.EXE) for testing network connections. However, traditional commands have the disadvantage that they do not behave like cmdlets; for instance, they return text instead of objects.
Syntactically things get complicated with commands that are located at directories where PowerShell does not search (i.e., which are not known to the $Path environment variable). The attempt to simply specify the entire path then often fails due to the use of spaces:
> C:\Program Files\Git\usr\bin\nano.exe myfile.txt  'C:\Program' is not recognized as a name of a cmdlet ... 
The program must then be started using the & call operator, which is passed a string with the entire path in the first parameter. This operator can be followed by separate parameters and options.
> & "C:\Program Files\Git\usr\bin\nano.exe"  "myfile.txt" 
4.3.8    Online Help
This book lacks the space for a comprehensive description of all cmdlets (but look at Chapter 7). For this reason, I will keep introducing you to new cmdlets through my examples.
Fortunately, PowerShell is equipped with excellent help features. Get-Help <command> (extended by the -Examples, -Detailed, or -Full options as required) returns comprehensive help texts for any command. If you additionally pass the -Online option, the help text will be displayed in the web browser.
The first time Get-Help is called, PowerShell may indicate that the local help files are incomplete. The solution to this problem is to run Update-Help -UICulture en-US once. The -UICulture option is necessary because most help texts are only available in English. However, download errors often occur despite this option because, for some (often smaller) modules, no help texts are available at all.
If you’re looking for a command, Get-Command will always help. Without further options, it simply provides a list of all commands. Using Select-String, you can then filter the almost endless output. The following command generates a sorted list of all commands that contain the search term VM, which obviously control virtual machines:
> Get-Command | Select-String VM | Sort-Object  Add-NetEventVmNetworkAdapter  Add-NetEventVmSwitch  ... 
Get-Command offers a lot more search options. Check out Get-Help Get-Command -Examples!

Searching for Uninstalled Commands
Get-Command only considers cmdlets and functions that are already installed. However, countless PowerShell extension modules can be installed. The fastest way to discover a command hidden in an extension is to use Find-Command. More tips on using add-on modules are provided in
