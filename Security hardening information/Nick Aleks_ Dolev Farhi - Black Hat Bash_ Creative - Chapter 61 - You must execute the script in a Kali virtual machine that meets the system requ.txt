# Security Chapter Extract
Book: Nick Aleks_ Dolev Farhi - Black Hat Bash_ Creative Scripting for Hackers and Pentesters (2024, NO STARCH PRESS, INC) - libgen.li (1)
Chapter: 61 - You must execute the script in a Kali virtual machine that meets the system requirements described in the introduction to this chapter.
Security Relevance Score: 4
Word Count: 1442
Extracted: 2025-06-13 23:40:57

---

You must execute the script in a Kali virtual machine that meets the system requirements described in the introduction to this chapter.

Installing Docker and Docker Compose
We’ll build the lab environment by using Docker, a tool for deploying and managing containers. Containers package code and its dependencies so an application can run reliably in various environments. We’ll also use Docker Compose, a special Docker utility for building and managing multiple Docker containers through a single YAML file known as a Compose file.
Let’s first configure our sources to use Debian’s current stable version of Docker’s community edition, docker-ce, using the following commands. We use printf to add Docker’s Advanced Package Tool (APT) repository to the APT package-source database file. The tee command reads from the standard input stream and writes to a file:
$ printf '%s\n' "deb https://download.docker.com/linux/debian bullseye stable" |
sudo tee /etc/apt/sources.list.d/docker-ce.list

Next, download and import Docker’s keyring to ensure that the repository is validated and all packages installed from that repository are cryptographically verified. Use curl to download the key and pipe it to the gpg command, which will then store it in the required folder:
$ curl -fsSL https://download.docker.com/linux/debian/gpg | sudo gpg --dearmor -o
/etc/apt/trusted.gpg.d/docker-ce-archive-keyring.gpg

Finally, run another update to refresh the repository database and install the Docker components:
$ sudo apt update -y
$ sudo apt install docker-ce docker-ce-cli containerd.io -y

To verify that you have Docker Compose running correctly, use the following:
$ sudo docker compose --help
Next, make sure the Docker process will automatically start upon system reboot by running this command:
$ sudo systemctl enable docker --now
Docker requires the use of sudo, which can get a little inconvenient. If you want to avoid having to enter sudo before executing Docker-related commands, add the kali user to the docker Linux group:
$ sudo usermod -aG docker $USER
Once you’ve done this, you shouldn’t need sudo to run Docker commands. For these changes to take effect, you must log out of and back in to Kali.


Cloning the Book’s Repository
You can find the lab’s files in the book’s GitHub repository at https://github.com/dolevf/Black-Hat-Bash. This repository contains the Docker configurations needed to build the lab, as well as all the bash scripts mentioned in the later chapters of this book.
Kali comes preloaded with Git, which you can use to clone and download the repository. To do so, run the following:
$ cd ~
$ git clone https://github.com/dolevf/Black-Hat-Bash.git

Next, move into the repository’s root directory and take a quick look at its contents:
$ cd Black-Hat-Bash && ls -l
--snip--
drwxr-xr-x 2 kali kali 4096 Jul 22 23:07 ch01
drwxr-xr-x 2 kali kali 4096 Jul 22 23:07 ch02
drwxr-xr-x 2 kali kali 4096 Jul 22 23:07 ch03
drwxr-xr-x 2 kali kali 4096 Jul 22 23:07 ch04
drwxr-xr-x 2 kali kali 4096 Jul 22 23:07 ch05
--snip--

As you can see in the output, the repository’s contents are organized into directories for each of the book’s chapters. The repository also includes a lab directory, which we’ll use to set up the lab in the next section.


Deploying Docker Containers
The contents of the lab directory in the book’s repository control all networking infrastructure, machines, and applications used within the lab. This directory includes a Makefile file. By running this script with the help argument, you can see that it is used to deploy, tear down, rebuild, clean, and check the status of our environment:
$ cd lab
$ make help

Usage: make deploy | teardown | cleanup | rebuild | status | init | help

deploy   | build images and start containers
teardown | stop containers (shut down lab)
rebuild  | rebuild the lab from scratch (clean up and deploy)
cleanup  | stop and delete containers and images
status   | check the status of the lab
init     | build everything (containers and hacking tools)
help     | show this help message

Let’s start by using the deploy argument to create the lab. Note that you will need sudo permissions to execute the deployment, so you’ll be prompted for your kali user password:
$ sudo make deploy
The initial deployment of the lab environment will take a few minutes to complete. To monitor the progress of the installation, you’ll need to open a new terminal session and tail the logfile located under /var/log/lab-install.log, like so:
$ tail -f /var/log/lab-install.log
When the tail -f (follow) command is used against a file, it provides a live view of any new lines added to the end of the file. This is useful for keeping an eye on logfiles, which frequently have new information written to them.


NOTE

Because the lab setup downloads software such as operating system images and other applications, this deployment could take some time, depending on your network connection and the computer’s resources allocated to the host running the lab.


Testing and Verifying the Containers
Once the logfile indicates the process is complete, it should tell you whether the lab was set up correctly. We can also run a few commands to verify this. First, let’s execute a status check by using the make command, this time with the test argument. If all the checks pass, you should get the following output:
$ sudo make test
Lab is up.

We can also list all our lab’s running Docker containers with the docker ps command:
$ sudo docker ps -–format "{{.Names}}"
p-web-01
p-web-02
p-ftp-01
c-jumpbox-01
c-db-01
c-db-02
c-backup-01
c-redis-01

You should get a similar output, though the containers won’t necessarily be in the same order.

NOTE

For convenience, you can also use the make status command, which is identical to make test, to check whether the lab is up and running.



The Network Architecture
The lab consists of eight machines running in Docker containers, as well as two networks. Most of the machines are assigned to one of the two networks, and we’ll use them to facilitate various hacking scenarios in later chapters.
The networks within the lab are connected to Kali via Docker’s bridged networking mode. Figure 3-2 shows the details of this network architecture.


Figure 3-2: The lab’s network architecture

You can also find this diagram in the book’s repository at https://github.com/dolevf/Black-Hat-Bash/blob/master/lab/lab-network-diagram.png.

The Public Network
The network on the left side of Figure 3-2 is the public network, where our fake internet hosting company, ACME Infinity Servers, hosts its customers’ websites and resources. The two company websites you’ll find in this network belong to ACME Impact Alliance and ACME Hyper Branding.
The public network has an IP address Classless Inter-Domain Routing (CIDR) range of 172.16.10.0/24 and contains four machines (whose names are prefixed with p-). It is also public facing, meaning we’ll likely test the machines with access to this network before any other, as they constitute possible entry points into the network.


The Corporate Network
The second network is the corporate network. ACME Infinity Servers uses this private network to host its supporting infrastructure on the backend. As you can see, the corporate network has an IP address CIDR range of 10.1.0.0/24 and contains four machines (whose names are prefixed with c-).
This network is not public facing, meaning the machines in this network don’t have internet connectivity. Therefore, we won’t test them until we’re able to take over one or more of the machines on the public network, which will serve as our launchpad to the corporate network.


Kali Network Interfaces
Kali has two network interfaces used to facilitate connections to both lab networks. We can use the br_public network interface to access the public network and the br_corporate network interface to access the corporate network. You can validate that both interfaces are online and configured to use the correct network address by running the following command:
$ ip addr | grep "br_"

--snip--
4: br_public: <NO-CARRIER,BROADCAST,MULTICAST,UP> mtu 1500 qdisc noqueue state DOWN group de...
    link/ether 02:42:ea:5f:96:9b brd ff:ff:ff:ff:ff:ff
    inet ❶ 172.16.10.1/24 brd 172.16.10.255 scope global br_public
5: br_corporate: <NO-CARRIER,BROADCAST,MULTICAST,UP> mtu 1500 qdisc noqueue state DOWN group...
    link/ether 02:42:67:90:5a:95 brd ff:ff:ff:ff:ff:ff
    inet ❷ 10.1.0.1/24 brd 10.1.0.255 scope global br_corporate

Verify that the IP addresses match those shown at ❶ and ❷ before moving on.


The Machines
The eight machines that make up the lab environment follow a simple naming convention. The first character of the name indicates the network that the machine belongs to. For example, if the machine name starts with a p, it belongs to the public network; likewise, if it starts with a c, it belongs to the corporate network. The next word describes the machine’s functions or main technology stack, such as web, ftp, jumpbox, or redis. Finally, a number is used to distinguish similar machines, such as p-web-01 and p-web-
