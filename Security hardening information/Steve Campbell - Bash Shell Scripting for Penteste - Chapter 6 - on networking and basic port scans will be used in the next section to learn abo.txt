# Security Chapter Extract
Book: Steve Campbell - Bash Shell Scripting for Pentesters (2024, Packt Publishing Pvt Ltd) - libgen.li
Chapter: 6 - on networking and basic port scans, will be used in the next section to learn about more advanced
Security Relevance Score: 20
Word Count: 3919
Extracted: 2025-06-13 23:41:12

---

on networking and basic port scans, will be used in the next section to learn about more advanced
    


      scanning techniques.
     






     Advanced network scanning techniques in Bash
    



     This section will go more
    



     in depth, demonstrating some of the most common advanced options of Nmap.
    

     Then, we’ll follow up with a primer on parsing the
    


      report output.
     




     This is the Nmap scan command I use most of
    





     ten for
    


      network pentesting:
     



$ sudo nmap -sS -sV -sC -p 21,22,23,25,53,80,81,88,110,111,123,137-139,161,389,443,445,500,512,513,548,623-624,1099,1241,1433-1434,1521,2049,2483-2484,3268,3269,3306,3389,4333,4786,4848,5432,5800,5900,5901,5985,5986,6000,6001,7001,8000,8080,8181,8443,10000,16992-16993,27017,32764 --open -oA [output file] -iL [input file] --exclude-file [exclude file]


     Here is
    


      the explanation:
     






       -sS
      


      :
     


       SYN
      


      scan, or half-open scan.
     

      This sends only the first part of the TCP handshake and scans much faster than the default connect (
     


       -sT
      


      ) scan, which completes the TCP
     


       three-way handshake.
      





       -sV
      


      : A version scan fingerprints the service name and version instead of the default, which only prints the default service name associated with the
     


       port number.
      





       -sC
      


      : Runs Nmap scripts against all open ports.
     

      The output of these scripts frequently reveals important or even
     


       exploitable information.
      





       -p [port list]
      


      : The list of ports to scan.
     

      These are port numbers that I have found to be the most common exploitable ports in my experience.
     

      If you’re scanning a single host or small number of hosts, or you absolutely must find every open port, use
     


       -p-
      


      instead, which is shorthand for
     


       all ports.
      





       --open
      


      : Only record open ports; don’t show closed or filtered ports in
     


       the output.
      





       -oA [output file]
      


      : The
     


       A
      


      option equates to all formats.
     

      If you named the output file
     


       nmapquick
      


      , you would find the following three output files in the current directory once the scan completes:
     


       nmapquick.nmap
      


      ,
     


       nmapquick.gnmap
      


      ,
     


       and
      




        nmapquick.xml
       




       .
      





       -iL [input file]
      


      : The file containing the list of IP addresses, network addresses, or hostnames
     


       to scan.
      





       --exclude-file [exclude file]
      


      : The file containing a list of IP addresses, network addresses, or hostnames to exclude from your scan.
     

      See the
     


       Rules of Engagement
      


      document for your pentest to find a list of any hosts to
     


       be excluded.
      





     In the scan output, we
    



     examine one of the hosts in the
    


      following figure:
     











     Figure 10.10 – The output of our scan on one host
    



     The Nmap script output can be seen by the dashed lines and the output they contain in the figure.
    

     This reveals the hostname and service versions.
    

     Additionally, we can guess that this is an Active Directory domain controller because it’s running Microsoft Windows, and ports
    


      53
     


     ,
    


      88
     


     ,
    


      3268
     


     , and
    


      3269
     



      are open.
     




     Scanning can be a trade-off between fast and thorough.
    

     For example, in the scan that we ran last, which specified a limited number of common ports, the output for host
    


      10.2.10.1
     


     shows one
    



     open port, as seen in the
    


      following figure:
     











     Figure 10.11 – Nmap scan output using a limited number of common ports
    



     If we rescan this host using the
    


      -p-
     


     (all ports) option, we find that the host actually has seven open ports, some running vulnerable applications.
    

     This example illustrates the difference between fast and thorough scanning.
    

     What I normally do when testing small networks is scan all ports.
    

     If I’m testing a large network, I run one fast scan specifying a limited number of ports, and while I’m working through that scan result, I start a second scan running targeting all ports, which I expect to take a day or more
    


      to complete.
     




     Now that you have a firm grasp of different port scanning techniques, let’s move on to the next section and explore various exploitable
    


      network protocols.
     






     Enumerating network services and protocols using Bash
    



     I perform a network packet
    



     capture on every internal network pentest.
    

     I’m looking for the default
    


      Hot Standby Router Protocol
     


     (
    


      HSRP
     


     ) default
    



     password of
    


      'cisco'
     


     , DHCPv6 discovering broadcasts without a corresponding offer, and broadcast or multicast protocols such as LLMNR, NBT-NS, and MDNS, which can yield
    



     password hashes or be relayed to crack into
    


      other systems.
     




     The following code can be found on this chapter’s GitHub page
    


      as
     




       packetcap.sh
      




      :
     



#!/usr/bin/env bash
if [ "$#" -ne 1 ]; then
  echo "You must specify a network adapter as an argument."
  echo "Usage: $0 [network adapter]"
  exit 1
fi


     The first block of code is
    



     the familiar shebang, followed by an
    


      if
     


     statement
    



     that prints usage information and exits if exactly one argument is
    


      not provided.
     



echo "[+] Please wait; capturing network traffic on $1 for 2.5 minutes."
sudo timeout 150 tcpdump -i "$1" -s0 -w packetcapture.pcap


     This block of code lets the user know what’s happening before running tcpdump for two and a half minutes.
    

     After
    


      sudo
     


     , the
    


      timeout 150
     


     command preceding
    


      tcpdump
     


     runs
    


      tcpdump
     


     for 150 seconds
    


      and quits.
     



echo "[+] Testing for default HSRP password 'cisco'..."
tcpdump -XX -r packetcapture.pcap 'udp port 1985 or udp port 2029' | grep -B4 cisco


     This block of code detects plaintext HSRP broadcasts using the default
    


      'cisco'
     


     password.
    

     If you have this password, you
    



     can poison the HSRP election process and take over as the default router, and execute a
    


      Man-in-the-Middle
     


     (
    


      MITM
     


     ) attack on
    


      all traffic.
     




     Tip
    



     If you detect the default HSRP password in use on a network, I caution you to not attempt to execute an MITM attack on it.
    

     If you’re not on-site with the system running the attack and you lose your network connection, you may cause a denial of service to the network and you won’t be there to stop it.
    

     This is very risky to exploit.
    

     It’s best to report it and
    


      move on.
     




     In the next code block, we start
    



     testing for
    


      IP version 6
     


     (
    


      IPv6
     


     )
    


      network traffic:
     



echo "[+] Testing for DHCPv6."
echo "[+] If detected, try mitm6!"
tcpdump -r packetcapture.pcap '(udp port 546 or 547) or icmp6'
sudo rm packetcapture.pcap


     This block of code tests for
    



     DHCPv6 traffic.
    

     If you see DHCPv6 discover
    



     broadcasts without a responding offer, the network is likely to be vulnerable to an attack where you can run the mitm6 tool and capture
    


      password hashes.
     



echo "[+] Please wait; running Responder for 5 minutes."
echo "[+] If hashes are captured, crack them or run Responder again with impacket-ntlmrelayx to relay."
responder=$(sudo timeout 300 responder -I "$1")
cat /usr/share/responder/logs/Responder-Session.log


     This block of code runs the
    


      Responder
     


     tool in a subshell so that you won’t see the output.
    

     Then, it prints anything in the
    


      Responder-Session
     


     log.
    

     You may see password hashes or plaintext passwords in
    


      the output.
     




     The following figures show the script in action.
    

     This shows the start of the
    


      script output:
     











     Figure 10.12 – Starting the network sniffer script
    



     Further down in the output, you see password hashes printed to the screen.
    

     This is an NTLMv2 password hash, which you should attempt to crack using
    


      hashcat
     


     .
    

     You can also reconfigure
    


      Responder
     


     and run it again along with
    


      impacket-ntlmrelayx
     


     to relay to other systems to run commands or
    


      dump credentials.
     











     Figure 10.13 – Responder captures a password hash
    



     Next, let’s attempt to crack them
    



     using
    


      hashcat
     


     .
    

     Before running the following command, copy and save
    



     those hashes to a file.
    

     Next, run
    


      hashcat
     


     as shown in the
    


      following command:
     



$ sudo hashcat -m 5700 hashes.txt /usr/share/wordlists/rockyou.txt.gz


     The following figure shows that we cracked one of the
    


      password hashes!
     











     Figure 10.14 – Hashcat is used to crack an NTLMv2 password hash
    



     Tip
    



     You aren’t limited to only cracking password hashes from these protocols; you can also relay them.
    

     Search the internet for
    


      relay LLMNR
     


     to find out more about
    


      the subject.
     




     Don’t overlook these protocols on your network.
    

     While they aren’t listening services that you can point an exploit at and get a shell, they are
    


      dangerous default
     


     protocols that you’re likely to find broadcast on any Windows domain, and they are usually the fastest way to
    


      exploit
     







      systems.
     




     In the next
    



     section, we’ll explore using Bash with vulnerabi
    





     lity assessment and
    


      exploitation tools.
     






     Infrastructure vulnerability assessment with Bash
    



     Assessing infrastructure vulnerabilities is a critical step in maintaining network security.
    

     With Bash, we can leverage powerful tools to automate network host discovery and vulnerability scanning, streamlining the
    



     assessment process.
    

     This section covers two essential techniques: identifying network hosts with NetExec and automating vulnerability scans using Greenbone.
    

     Each technique offers a practical approach to improving your security posture by reducing manual effort while enhancing efficiency and accuracy in
    


      detecting vulnerabilities.
     






     Enumerating network hosts with NetExec
    



     Starting from an unauthenticated
    



     perspective, we will examine TCP port
    


      445
     


     since it’s historically had a lot of vulnerabilities
    



     and can yield a lot of information.
    

     We will use the NetExec tool to enumerate
    


      network hosts.
     




     First, let’s attempt to use
    



     an SMB null session to enumerate SMB shares.
    

     Run the following command, replacing the network address with the a
    







     ppropriate address for your
    


      lab instance:
     



$ netexec smb 10.2.10.0/24 -u a -p '' --shares


     Here is
    


      the explanation:
     






       netexec smb
      


      : Here, we specify the protocol for NetExec to use.
     

      The
     


       netexec
      


      command has multi-protocol support,
     


       including SMB.
      





       10.2.10.0/24
      


      : The target goes after
     


       netexec
      


      and the protocol.
     

      The target can be an IP address, hostname, network address, or a file containing targets (one
     


       per line).
      





       -u a -p ''
      


      : We specify a random username (
     


       a
      


      ), followed by a blank
     


       password (
      




        ''
       




       ).
      





       --shares
      


      : This is a
     


       netexec
      


      command to enumerate
     


       SMB shares.
      





     The following figure shows
    


      the
     







      output:
     











     Figure 10.15 – Performing SMB null session SMB share enumeration with NetExec.
    



     Note that this is a cropped
    



     screenshot and doesn’t show the hostname or IP address of each system.
    

     Without
    



     cropping the image, the text would be too small to read.
    

     Notice where we have read or write permissions in the preceding figure.
    

     In this case, I recommend taking the time to connect to these SMB shares and look for interesting information, such as passwords
    


      in files.
     




     Next, let’s attempt to use an SMB null session to enumerate users.
    

     Run the
    


      following command:
     



$ netexec smb 10.2.10.0/24 -u a -p '' --users


     The only difference between this and the previous command is we’ve changed shares (
    


      --shares
     


     ) to users (
    


      --users
     


     ).
    

     We check the output and see we had no luck enumerating users.
    

     Before giving up, let’s r
    





     evise the command as follows and
    


      try again:
     



$ netexec smb 10.2.10.0/24 -u '' -p '' --users


     Here, instead of specifying a username, we’ve used a
    


      blank username.
     











     Figure 10.16 – Using an SMB null session to list domain users
    



     So why did one method of specifying an invalid username fail and the other succeed?
    

     Without going too far off the
    



     track of our Bash topic, it’s due to how the libraries used in this tool authenticate to
    



     Microsoft Windows SMB shares.
    

     I’ll leave that as an exercise to you.
    

     I just want you to be aware of
    


      this quirk.
     




     Using these usernames, you
    



     can use NetExec to password spray common passwords and maybe you’ll get lucky.
    

     But do you really need to password spray?
    

     Go and take another look at
    



       Figure 10
      




      .16
     


     and check the
    


      Description
     


     column.
    

     Do you see the password for Samwell Tarly?
    

     You would be surprised how often this happens on the average corporate network!
    

     Many system administrators don’t realize that null sessions and unprivileged users can see this information.
    

     Let’s test this password, as seen in the
    


      next figure:
     











     Figure 10.17 – Testing credentials with NetExec
    



     In the preceding figure, we see that the credentials for Samwell Tarly are authenticated to three systems, but this account isn’t an administrator on any of them, otherwise, the output would show
    


      Pwn3d!
     


     .
    

     There’s a lot more we can do with these credentials.
    

     I’ll leave it as an exercise for you to
    



     run
    


      netexec
     


     with the
    


      --help
     


     and
    


      -L
     


     (list modules) options to explore the
    



     commands and modules available
    


      to you.
     




     Hint
    



     If you’re following along in your own GOAD lab, take a look at the
    


      petitpotam
     



      SMB module.
     




     Next, we’ll dive into
    



     vulnerability scanning from the
    


      Bash shell.
     






     Automating vulnerability scanning with Greenbone
    



     There are a number of top
    



     vulnerability scan products on the market.
    

     All have a web interface.
    

     However, you should learn how to automate these scans from the Bash shell to save yourself valuable time.
    

     When I
    



     was responsible for enterprise vulnerability scanning of a global corporation, I used Bash shell to interface
    



     with the scanner API to automate as much of my job as I could, including gathering statistics for
    


      custom reports.
     




     We will use the Greenbone Community Edition, formerly known as OpenVAS.
    

     If you want to follow along in your own lab, you should first review the
    


      Technical requirements
     


     section if you have not already
    


      installed Greenbone.
     




     Create a scan target as shown here, replac
    









     ing the password and network with your
    


      own values:
     



$ sudo -u _gvm gvm-cli --gmp-username admin --gmp-password [password] socket --xml "<create_target><name>My Target</name><hosts>10.2.10.0/24</hosts><port_range>1-65535</port_range></create_target>"


     The output of this command can be found in the
    


      following figure:
     











     Figure 10.18 – Creating a scan target in GVM
    



     Copy the target ID output
    



     from creating a target to cr
    





     eate a task for a full and fast scan, as
    


      shown here:
     



$ sudo -u _gvm gvm-cli --gmp-username admin --gmp-password [password] socket --xml "<create_task><name>My Task</name><comment>Scanning 10.2.10.0/24</comment><config id='daba56c8-73ec-11df-a475-002264764cea'/><target id=29590015-db97-4d3e-8aab-694abb3b1c4c/></create_task>"


     The output of this command
    



     can be found in the
    


      following figure:
     











     Figure 10.19 – A scan task is created in GVM for demonstration
    



     Start the task using the task I
    





     D
    



     found in the response from the
    


      previous command:
     



$ sudo -u _gvm gvm-cli --gmp-username admin --gmp-password [password] socket --xml "<start_task task_id=abc324d4-7464-4415-8a77-de8dfa13606b'/>"


     The output of this command can be found in the
    


      following figure:
     











     Figure 10.20 – Starting a task in GVM
    







     Check the task status
    



     using the command
    


      as shown:
     



$ sudo -u _gvm gvm-cli --gmp-username admin --gmp-password [password] socket --xml "<get_tasks task_id=7f6996b2-bdf5-49e8-8bb0-699cad0778ec'/>" | xmllint --format -


     The output of this command can be found in the
    


      following figure:
     











     Figure 10.21 – Demonstrating checking the scan task status
    



     Download the report using the
    



     report ID from the
    



     previous command output, as
    


      shown here:
     



$ sudo -u _gvm gvm-cli --gmp-username admin --gmp-password [password] socket --xml "<get_reports report_id='7c39338b-8c15-4e3a-93ff-bca125ff2ddf' format_id='c402cc3e-b531-11e1-9163-406186ea4fc5'/>" > scan_result.xml


     Next, let’s create a script to automate this process and parse the report.
    

     The following code can be found in this chapter’s GitHub repository
    


      as
     




       ch10_gvm_scan.sh
      




      :
     



#!/usr/bin/env bash
# User and argument validation
if [ "$(whoami)" != "_gvm" ]; then
  echo "This script must be run as user _gvm."
  exit 1
fi


     The preceding block of code begins
    



     with the familiar shebang line.
    

     It then checks to ensure the user running the
    



     script is the
    


      _gvm
     


     user, which is a user created during the
    


      gvm
     


     installation process.
    

     If not running as this user, the
    


      script exits.
     



if [ $# -lt 2 ]; then
  echo "Usage: $0 <password> <target_host>"
  exit 1
fi


     The script will exit if there are less than
    


      two arguments.
     



password="$1"
target_host="$2"


     In the preceding code, we
    



     assign the first argument to the
    


      password
     


     variable, and the second argument to the
    



       target_host
      




      variable.
     



# Generate target name
target_name=$(echo -n "$target_host" | sed 's/\//_/g')


     Here, we’re simply replacing any
    


      /
     


     character in the target with
    


      an underscore.
     



# Create target
echo "[+] Creating target"
target_id=$(gvm-cli --gmp-username admin --gmp-password "$password" socket --xml "<create_target><name>$target_name</name><hosts>$target_host</hosts><port_range>1-65535</port_range></create_target>" | grep -o 'id="[^"]*"' | sed -e 's/id="//' -e 's/"//')
if [ -z "$target_id" ]; then
  echo "[-] Failed to create target"
  exit 1
fi


     The preceding code block creates a target in the
    


      GVM system:
     





      It uses
     


       gvm-cli
      


      to send an XML request to create
     


       a target.
      




      The target is created with the specified name, host, and
     


       port range.
      




      It extracts the
     



      target ID from
     


       the response.
      




      If target
     



      creation fails (empty
     


       target_id
      


      ), the
     


       script exits.
      





     The following code
    



     will create a
    


      scan task:
     



# Create task
echo "[+] Creating task"
task_id=$(gvm-cli --gmp-username admin --gmp-password "$password" socket --xml "<create_task><name>Task_$target_name</name><comment>Scanning $target_host</comment><config id='daba56c8-73ec-11df-a475-002264764cea'/><target id='$target_id'/></create_task>" | grep -o 'id="[^"]*"' | sed -e 's/id="//' -e 's/"//')
if [ -z "$task_id" ]; then
  echo "[-] Failed to create task"
  exit 1
fi


     This section creates a task in the
    


      GVM system:
     





      It uses
     


       gvm-cli
      


      to send an XML request to create
     


       a task.
      




      The task is created with a name, comment, configuration, and the previously
     


       created target.
      




      It extracts the task ID from
     


       the response.
      




      The
     


       grep -o 'id="[^"]*"'
      


      command searches for all occurrences of
     


       pattern id="[^"]*"
      


      in the input text and outputs only the
     


       matching parts:
      





         id="
        


        matches the literal
       


         string,
        




          id="
         








       [^"]*
      


      matches zero
     



      or more characters that are not a double quote (
     


       "
      


      ).
     


       [^"]
      


      is a negated
     



      character class meaning any character
     


       except
      




        "
       




       :
      





         "
        


        matches the closing
       


         double quote
        






      If task creation fails (empty
     


       task_id
      


      ), the
     


       script exits.
      





     Next, we need to start
    



     the scan, as shown in this
    


      code block:
     



# Start task and wait for completion
echo "[+] Starting task"
report_id=$(gvm-cli --gmp-username admin --gmp-password "$password" socket --xml "<start_task task_id='$task_id'/>" | grep -oP '(?<=<report_id>).*?(?=</report_id>)')


     The preceding code starts the scan task using variables captured from previous commands and extracts
    


      report_id
     


     from
    


      the response:
     






       (?<=<report_id>).*?(?=</report_id>)
      


      : This is the regular expression that
     


       is used.
      





       (?<=<report_id>)
      


      : This is a positive
     


       look-behind assertion.
      





       (?<=...)
      


      : This syntax specifies a look behind, which ensures that what precedes the current position in the string is the specified
     


       pattern,
      




        <report_id>
       




       .
      





       <report_id>
      


      : This is the literal string that must precede
     


       the match.
      





       .*?
      


      : This is a non-greedy
     



      match for any
     


       character sequence.
      





       .
      


      : This matches any
     



      character except
     


       a newline.
      





       *?
      


      : This matches zero or more of the preceding elements (
     


       .
      


      in this case), but in a non-greedy (or lazy) manner, meaning it will match as few characters
     


       as possible.
      





       (?=</report_id>)
      


      : This is a positive
     


       look-ahead assertion.
      





       (?=...)
      


      : This syntax specifies a look-ahead, which ensures that what follows the current position in the string is the specified
     


       pattern,
      




        </report_id>
       




       .
      





       </report_id>
      


      : This is the literal string that must follow
     


       the match.
      





     The next code section
    



     continuously checks for task completion every
    


      60 seconds:
     



# Wait for task to complete
echo "[-] Waiting for scan result. This may take a while."
while true; do
    output=$(gvm-cli --gmp-username admin --gmp-password "$password" socket --xml "<get_tasks task_id='$task_id'/>" 2>/dev/null | xmllint --format -)
    if echo "$output" | grep -q '<status>Done</status>'; then
        break
    fi
    sleep 60
done
echo "[+] The scan is complete."


     The preceding code starts a
    


      while
     


     loop.
    

     The
    


      gvm-cli
     


     command output is printed in a line-by-line format by
    



     piping it to
    


      xmlstarlet
     


     , then saved to the
    


      output
     


     variable.
    

     If the output status confirms it’s completed, it breaks out of the loop.
    

     Otherwise, there is a one-minute pause before
    



     the
    


      loop repeats.
     



# Create report
echo "[+] Printing scan results..."
gvm-cli --gmp-username admin --gmp-password "$password" socket --xml "<get_results task_id=\"$task_id\" filter='notes=1 overrides=1'/>" |\
xmlstarlet sel -t -m "//result" \
  -v "host" -o "|" \
  -v "host/hostname" -o "|" \
  -v "port" -o "|" \
  -v "threat" -o "|" \
  -v "name" -o "|" \
  -v "severity" -n |
sort -t'|' -k6,6nr |
awk -F'|' '{printf "%s\t%s\t%s\t%s\t%s\n", $1, $2, $3, $4, $5}'


     The preceding code block requests the scan results (vulnerabilities) detected in the scan task.
    

     It pipes the output to
    


      xmlstarlet
     


     to parse the XML content and output the most interesting parts.
    

     Finally, it sorts based on the sixth column (
    


      severity
     


     ) and prints the data fields
    



     with a tab (
    


      \
     




       t
      




      ) separator:
     






       xmlstarlet
      


      is a command-line tool for parsing, querying, transforming, and editing XML files.
     

      It can be used to extract specific data from XML documents, modify XML structures, and perform various other
     


       XML-related tasks.
      





       sel -t
      


      : This is short for
     


       select
      


      .
     

      It indicates that we are using the selection sub-command to query XML data.
     

      The
     


       -t
      


      stands for
     


       template
      


      .
     

      It is used to define the
     


       output template.
      





       -m "//result"
      


      : This stands for
     


       match
      


      .
     

      It specifies an XPath expression to select nodes from the
     


       XML document.
      





       //result
      


      : This XPath expression selects all result elements in the XML document, regardless of their location
     



      in
     


       the hierarchy.
      





       sort -t'|' -k6,6nr
      


      : The
     


       -k
      


      option specifies the key (field) to sort by, and the
     


       nr
      


      suffix indicates the
     



      type of sorting (numerical and
     


       reverse order).
      





       -k6,6
      


      : This option tells
     


       sort
      


      to use the sixth field as the key for sorting.
     

      The
     


       6,6
      


      syntax means it should start and stop sorting on the
     


       sixth field.
      





       awk -F'|' '{printf "%s\t%s\t%s\t%s\t%s\n", $1, $2, $3, $4, $5}'
      


      : This code determines how the data
     


       is printed:
      





         -F
        


        : This option tells
       


         awk
        


        to use a specific character as the
       


         field separator.
        





         '|'
        


        : The pipe character is specified as the delimiter.
       

        This means
       


         awk
        


        will consider the text between pipe characters as
       


         separate fields.
        





         { ...
        

         }
        


        : Encloses the action to be performed on each
       


         input line.
        





         printf
        


        : A function in
       


         awk
        


        (and many programming languages) used for
       


         formatted output.
        





         "%s\t%s\t%s\t%s\t%s\n"
        


        : This format string tells
       


         printf
        


        to output five string fields (
       


         %s
        


        ), each followed by a tab character (
       


         \t
        


        ), and end the line with a newline
       


         character (
        




          \n
         




         ).
        





         $1, $2, $3, $4, $5
        


        : These are field variables in
       


         awk
        


        .
       


         $1
        


        refers to the first field,
       


         $2
        


        to the second field, and so on.
       

        Since the field separator is a pipe (
       


         |
        


        ), these variables correspond to the data between
       


         the pipes.
        







     The script must be run as
    



     the
    


      _gvm
     


     user.
    

     When we prefix each command with
    


      sudo
     


     inside the script, there’s enough time between some of the steps that it will prompt you for credentials while you’ve stepped away, unaware
    



     that it’s waiting for your input.
    

     Instead, we’ll run the script with
    


      sudo -u _gvm
     


     prefixed, so you’ll need to run the following comma
    





     nds to
    



     set up directory and file permissions before running
    


      the script:
     



$ mkdir ~/shared_scripts
$ cp ch10_gvm_scan.sh ~/shared_scripts
$ sudo chmod 775 /home/kali/shared_scripts
$ sudo chown -R kali:_gvm /home/kali/shared_scripts


     Let’s look at
    


      the explanation:
     





      We created a new directory using the
     



        mkdir
       




       command.
      




      The script is copied to the
     


       new directory.
      




      The directory permissions are changed to set user and group permissions to
     


       7
      


      .
     

      The number
     


       7
      


      for the user and group equates to read (4), write (2), and execute (1) (
     


       4 + 2 + 1 = 7
      


      ), and the other permissions to read (4) and execute (1) (
     


       4 + 1 =
      




        5
       




       ).
      




      Finally, the owner is changed recursively to the
     


       kali
      


      user and
     


       _gvm
      


      group on the new directory and everything inside
     


       the directory.
      





     The following figure
    



     demonstrates how to run the script and shows the
    


      script output:
     











     Figure 10.22 – The Greenbone scan script is demonstrated and shows the scan results
    



     You can learn more about
    


      gvm-cli
     


     usage
    


      at
     



      https://docs.greenbone.net/GSM-Manual/gos-22.04/en/gmp.html#starting-a-scan-using-the-command-gvm-cli
     



      .
     




     This concludes the section where
    



     we focused on
    



     vulnerability scanning automation.
    

     Our attention and focus abilities are finite.
    

     Always automate the mundane, repeatable tasks so you have more time and the ability to focus on carefully reviewing scan results for the smallest details to uncover
    


      exploitable vulnerabilities.
     






     Summary
    



     This chapter explored the topic of using Bash scripting for network pentesting and automation.
    

     Port scanning was thoroughly explored, from basic command-line options through advanced techniques necessary to tune for speed and depth of results.
    

     We went through the discovery of common network protocols that are frequently exploited.
    

     Finally, we dived into the automation of network vulnerability
    


      scanning tools.
     




     The next chapter will focus on post-exploitation privilege escalation techniques in a Bash environment.
    

     When remote network services are exploited, they commonly result in a non-root shell.
    

     In
