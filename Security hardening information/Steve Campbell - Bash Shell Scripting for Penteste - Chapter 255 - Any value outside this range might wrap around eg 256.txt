# Security Chapter Extract
Book: Steve Campbell - Bash Shell Scripting for Pentesters (2024, Packt Publishing Pvt Ltd) - libgen.li
Chapter: 255 - Any value outside this range might wrap around (e.g., 256
Security Relevance Score: 7
Word Count: 1780
Extracted: 2025-06-13 23:41:12

---

Any value outside this range might wrap around (e.g., 256
     


       becomes 0).
      





       Using output
      


      : Functions can output data to
     


       stdout
      


      , which can be captured with
     


       command substitution.
      





       Return early
      


      : You can use multiple return statements in a function to exit the function under different
     


       conditions early.
      





     Having gained a thorough knowledge of using functions in Bash code, let’s take a brief look at how to use them recursively in
    


      your code.
     






     Recursive functions
    



     Bash supports
    


      recursive functions
     


     , which are functions that call themselves.
    

     Recursive functions are useful for
    



     solving problems that can be divided into smaller subproblems.
    

     Here’s an example that calculates the factorial of a number using recursion (this code is provided in the bo
    





     ok’s GitHub repository
    


      as
     




       ch05_recursive_function.sh
      




      ):
     



factorial() {
  if [ "$1" -eq 0 ]; then
    echo 1
  else
    local prev=$(factorial $(($1 - 1)))
    echo $(($1 * prev))
  fi
}
result=$(factorial 5)
echo "The factorial of 5 is $result"


     The following is
    


      the output:
     



The factorial of 5 is 120


     The following provides
    


      an explanation:
     





      In this example, we
     



      define a function called
     


       factorial
      


      that takes one argument, the number for which we want to calculate the factorial.
     

      The function uses an
     


       if
      


      statement to check whether the argument is equal to
     


       0
      


      .
     

      If it is, the function returns
     


       1
      


      , which is the base case of
     


       the recursion.
      




      If the argument is not
     


       0
      


      , the function calls itself with the argument decremented by
     


       1
      


      .
     

      This recursive call continues until the base case is reached.
     

      The result of each recursive call is stored in a local variable called
     


       prev
      


      .
     

      Finally, the function multiplies the current argument by the result of the previous recursive call and returns the product
     


       using
      




        echo
       




       .
      




      To use the
     


       factorial
      


      function, we call it with an argument of
     


       5
      


      and capture the result using command substitution.
     

      We assign the result to a variable called
     


       result
      


      and print a message that includes the factorial of
     


       5
      


      , which
     


       is
      




        120
       




       .
      





     One example of a good use case for a recursive function is when performing file and directory enumeration in a web application.
    

     You would want to create an array of discovered directories and begin anew inside each directory to
    


      discover files.
     




     Recursive functions can be powerful, but they can also be difficult to understand and debug.
    

     It’s important to ensure that the recursive function has a well-defined base case to prevent infinite recursion and to carefully consider the
    


      termination condition.
     




     In the next section, we’ll continue
    



     building on everything you’ve learned in this chapter by learning how to import functions to reduce the amount of code you write and
    


      reuse code.
     






     Importing functions
    



     I previously stated that one of the nice features of Bash functions is code reuse.
    

     You can solve a problem once by
    



     writing a function and calling that function repeatedly.
    

     In programmer lingo, that’s
    



     referred to as
    


      don’t repeat yourself
     


     , or
    


      DRY
     


     .
    

     Now, let’s take that a
    


      step further.
     




     Let’s imagine for a moment that you previously solved a problem by implementing a function that you can call as many times as you need.
    

     What happens when you find the need to use that function in a new Bash script?
    

     Do you go searching through your scripts to find that function and copy and paste it into your new script?
    

     This is really
    


      not necessary.
     




     Make it a habit to start putting your functions into one script, such as a library or module.
    

     When you need to use a function that you’ve previously defined, simply
    


      source
     


     it before you call that function in your
    


      new script.
     




     The following example code can be found in this chapter’s folder in
    







     the book’s GitHub repository
    


      as
     




       ch05_importing_funcs_1.sh
      




      :
     



function greet() {
  echo "Hello, $1!"
}


     Next, source the script from another script
    





     before you call the
    


      function (
     




       ch05_importing_funcs_2.sh
      




      ):
     



source script1.sh
greet "John"


     You should be aware that sourcing a file may add a very small amount of time to the startup of the script that sources another script since it has to load the sourced script into memory.
    

     It has to do this one time only.
    

     If you use more than one function from a function library file, you source it only one time since the whole script is loaded into memory when
    


      it’s sourced.
     




     Having learned how to use functions, from basics through to advanced usage, I want to briefly discuss the differences
    



     and use cases to help you choose between functions and aliases, in the
    


      next section.
     






     Functions versus aliases
    



     Functions are essential building blocks in programming that allow developers to encapsulate a set of instructions into a reusable block of code.
    

     By defining functions, programmers can streamline their code, improve readability, and promote code reusability.
    

     Functions are designed to
    



     perform specific tasks when called upon, making it easier to manage and maintain code bases.
    

     They are a fundamental concept in programming languages such as Python, JavaScript, and Java, enabling developers to break
    



     down complex problems into smaller, more
    


      manageable components.
     





      Aliases
     


     , on the other hand, serve a different purpose in programming.
    

     An alias is a symbolic name given to an entity, such as a variable, function, or command.
    

     Aliases provide a way to create shortcuts or alternative names for existing elements in a program.
    

     They can help simplify the syntax of commands or make code more concise and easier to understand.
    

     In Unix-based systems, aliases are commonly used to define custom commands or shorten lengthy commands
    


      for convenience.
     




     While functions and aliases both play important roles in programming, they serve distinct purposes and have different applications.
    

     Functions are primarily used to encapsulate a set of instructions into a reusable block of code, promoting modularity and code organization.
    

     On the other hand, aliases are used to create symbolic names for entities, providing shortcuts or alternative names for convenience.
    

     Understanding the differences between functions and aliases can help you leverage these programming concepts to improve code quality
    


      and efficiency.
     




     Now that we’ve explored functions in depth, I want to introduce you to how you can use functions outside of scripts to simplify your pentesting workflow.
    

     Aliases are great for simplifying a workflow because they allow you to create a named command you can enter to replace more
    


      complicated commands.
     




     For example, I have an alias in my
    


      ~/.bashrc
     


     file that simplifies a very long, complex command to run a Docker container that provides information about a web application.
    

     I run this command at the beginning of every web application pentest to give me information related to the frameworks in use by
    


      the application:
     



zapit='docker run -it --rm softwaresecurityproject/zap-stable zap.sh -cmd -addonupdate -addoninstall wappalyzer -addoninstall pscanrulesBeta -zapit'


     That’s a lot to remember, isn’t it?!
    

     Thankfully, we have aliases for
    


      this purpose.
     




     While aliases are very handy, they lack
    



     one crucial feature that we need; they don’t accept parameters such as
    


      $1 $2 $3
     


     .
    

     In the preceding alias, when we enter the alias in our terminal, anything appended after the alias name is included with the command when Bash expands the
    



     alias to the full command and executes it in
    


      the shell.
     




     Essentially, Bash expands the
    


      zapit www.example.com
     


     command to the
    


      Docker
     



      run
     


     command shown previously with
    


      www.example.com
     


     appended to it.
    

     What if we wanted to run a command that requires multiple parameters in a particular order, so we can’t simply append them after the alias name?
    

     This is where functions
    


      are helpful.
     




     Let’s use generating shellcode with
    


      msfvenom
     


     as an example.
    


      msfvenom
     


     is a command that’s included with the
    


      Metasploit Framework
     


     to generate shellcode in various formats.
    

     This
    





     tool is
    



     used frequently in pentesting and
    


      exploit development:
     



gen_shellcode() {
  if [[ $# -eq 0 ]]; then
    echo "Usage: gen_shellcode [payload] [LPORT] [output format]"
    return 1
  fi
  msfvenom -p $1 LHOST=$(ip -o -4 a show tun0 | awk '{print $4}' | cut -d/ -f1) LPORT=$2 -f $3;
 }


     This code is provided in the book’s GitHub repository as
    


      ch05_gen_shellcode.sh
     


     .
    

     We can explain it
    


      as follows:
     





      We declare a function
     


       named
      




        gen_shellcode
       




       .
      




      If the number of arguments equals
     


       0
      


      , print the usage
     


       and exit.
      




      In the
     


       msfvenom
      


      command, the first argument,
     


       $1
      


      , is inserted as the payload,
     


       after
      




        -p
       




       .
      




      The
     


       LHOST=$(ip -o -4 a show tun0 | awk '{print $4}'
      


      code gets your IP address for the
     


       tun0
      


      network interface and inserts it in place
     


       of
      




        $()
       




       .
      




      The second argument,
     


       $2
      


      , is assigned to the
     



        LPORT
       




       variable.
      




      The third argument,
     


       $3
      


      , is for the output format
     


       -
      




        f
       




       argument.
      





     Finally, add this code at the end of your
    


      ~/.bashrc
     


     file and you will be able to use this function any time you need to generate shellcode with
    


      msfvenom
     


     .
    

     If you forget which options are required, simply enter
    


      gen_shellcode
     


     without arguments and press the Enter key and it will print the
    



     usage example
    


      for you.
     




     In summary, aliases are
    



     expanded to represent the command inside the quotes, but you’re limited to appending extra arguments after the alias name.
    

     With functions, there are no limitations.
    

     In addition to the great value you get from using functions in your scripts, any valid Bash function code can be placed in your
    


      .bashrc
     


     file to call on the command line with arguments that are interpolated in the function code on execution.
    

     Imagine the possibilities for creating automation for your pentesting workflow!
    

     We’ll be diving into that topic in
    


      later chapters.
     






     Summary
    



     In this chapter, we dove deep into the world of Bash functions and how they can revolutionize your scripting game.
    

     By mastering functions, you’ll write cleaner, more organized, and more efficient scripts that save you time
    


      and headaches.
     




     We started with the basics, understanding what functions are and why they’re so helpful.
    

     Then we got into the nitty-gritty of passing arguments to functions, making them flexible and reusable.
    

     We explored the scope and lifetime of variables inside functions, so you know exactly what’s happening under
    


      the hood.
     




     Things got really exciting when we hit the advanced techniques.
    

     You learned how to use recursion to elegantly solve complex problems and how to use callbacks to make your functions even more powerful.
    

     Finally, we compared functions to aliases and showed how functions are the clear winner for
    


      pentesting workflows.
     




     Now, you have some serious tools in your scripting toolbox.
    

     You can now write modular, organized scripts that are easy to read, debug, and maintain.
    

     And, most importantly, you can use functions to streamline your pentesting process, saving you valuable time and effort.
    

     So, go forth and script like
    


      a pro!
     




     In the next chapter, we’ll explore using Bash commands
    


      for networking.
     















     6
    





     Bash Networking
    



     In
