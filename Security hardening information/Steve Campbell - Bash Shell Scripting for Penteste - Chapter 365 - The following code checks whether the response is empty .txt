# Security Chapter Extract
Book: Steve Campbell - Bash Shell Scripting for Pentesters (2024, Packt Publishing Pvt Ltd) - libgen.li
Chapter: 365 - The following code checks whether the response is empty (
Security Relevance Score: 16
Word Count: 4235
Extracted: 2025-06-13 23:41:12

---

The following code checks whether the response is empty (
    


      -z
     


     , zero-length) and exits if true.
    

     An
    


      exit
     


     code that’s
    



     non-zero indicates that the process terminated with
    


      an error.
     



    if [[ -z "$response" ]]; then
        echo "[-] Unable to execute request. Wrong domain?"
        exit 1
    fi


     The following code parses the XML response to extract domain names using the
    


      xmllint
     


     application and stores the result in the
    



       domains
      




      variable:
     



    domains=$(echo "$response" | xmllint --xpath '//*[local-name()="Domain"]/text()' -)


     The following code exits if no domains are found in
    


      the response.
     



    if [[ -z "$domains" ]]; then
        echo "[-] No domains found."
        exit 1
    fi


     In the following code, we print the
    


      found domains:
     



    echo -e "\n[+] Domains found:"
    echo "$domains" | tr ' ' '\n'


     The
    


      tr
     


     command substitutes the first value with the second value; in this case, a space,
    


      ' '
     


     , is replaced with a
    


      newline,
     




       '\n'
      




      .
     




     The following code extracts the tenant name from the
    


      found domains.
     



    tenant=$(echo "$domains" | tr ' ' '\n' | grep "onmicrosoft.com" | head -n 1 | cut -d'.' -f1)


     The
    


      tenant
     


     variable is assigned the result of the
    


      domains
     


     variable with spaces substituted with a newline (
    


      tr ' ' '\n'
     


     ).
    

     Then, it finds (
    


      grep
     


     ) any line that contains
    


      onmicrosoft.com
     


     .
    

     That data is piped to
    


      head -n 1
     


     , which selects the first line of data, then pipes the result to the
    


      cut
     


     command, which essentially splits the data on the period character and selects the
    


      first field.
     




     The following
    



     code exits if no tenant
    


      is found:
     



    if [[ -z "$tenant" ]]; then
        echo "[-] No tenant found."
        exit 1
    fi


     The following code prints the found
    


      tenant name:
     



    echo -e "\n[+] Tenant found: \n${tenant}"


     The following code calls the
    


      check_mdi
     


     function with the tenant name.
    

     The closing brace ends the
    



       get_domains
      




      function.
     



    check_mdi "$tenant"
}


     In the following code, I declare the
    


      check_mdi
     


     function to identify
    


      MDI usage:
     



check_mdi() {


     The following code appends the MDI domain suffix to the
    


      tenant name:
     



    tenant="$1.atp.azure.com"


     The following code runs
    


      dig
     


     to check whether the MDI instance exists for the
    


      tenant domain:
     



    if dig "$tenant" +short; then
        echo -e "\n[+] An MDI instance was found for ${tenant}!\n"
    else
        echo -e "\n[-] No MDI instance was found for ${tenant}\n"
    fi
}


     It prints a positive message if the MDI instance is found.
    

     Otherwise, it prints a negative message if no MDI instance is found.
    

     The closing brace ends the
    



       check_mdi
      




      function.
     




     The following code checks whether the correct number of arguments is provided and whether the first
    



     argument is
    


      -d
     


     .
    

     The logical
    


      or
     


     (
    


      ||
     


     ) operation means if the number of command-line arguments is not equal to two, or the first argument is not equal to
    


      -d
     


     , then print the usage banner
    


      and exit.
     



if [[ $# -ne 2 || $1 != "-d" ]]; then
    # Print the usage information if the arguments are incorrect
    echo "Usage: $0 -d <domain>"
    exit 1
fi


     The following code declares the
    


      domain
     


     argument from
    


      user input.
     



domain=$2


     The following code calls the
    


      get_domains
     


     function with the
    


      provided domain.
     



get_domains "$domain"


     If you run this script with a well-known domain, you will find a lesser-known domain in the output.
    

     Essentially, this script helps you cross-reference domains owned by the
    


      same entity:
     











     Figure 8.6 – Running check_mdi on the cdw.com domain
    



     The script output shown in the preceding figure demonstrates how our Bash script discovered many
    



     subdomains related to the target domain, greatly expanding our
    


      target footprint.
     






     Automating subdomain enumeration with Bash
    



     Next, I’m going to share some
    



     of the Bash functions I keep in my
    


      .bashrc
     


     file.
    

     I use these functions on external pentests to allow me to quickly perform common reconnaissance tasks that I run before port and vulnerability scanning.
    

     First, I will list the code in small sections and explain them as I go.
    

     Finally, I’ll show you how I use these functions together to enumerate DNS and
    


      the output.
     




     The first function is named
    


      mdi
     


     and you’ve already seen it in the
    


      ch08_check_mdi.sh
     


     script shown earlier in this chapter.
    

     I’m going to include only the part that has changed from
    


      ch08_check_mdi.sh
     


     .
    

     The example code can be found in the
    


      ch08_mdi_function.sh
     


     file in this chapter’s folder in the
    


      GitHub repository:
     



mdi() {
    # This function takes a domain as input and checks MDI and returns domains using the same tenant.
    while IFS= read -r line; do
        body="<?xml version=\"1.0\" encoding=\"utf-8\"?>


     In the preceding code, I start by declaring a function named
    


      mdi
     


     .
    

     I nested all of the earlier code inside a
    


      while
     


     loop, which reads from standard input (
    


      stdin
     


     ).
    

     This is required to read piped input, allowing us to pipe data between our functions.
    

     The
    


      IFS=
     


     code preserves newlines, which is necessary when your input contains multiple lines.
    

     You can pipe a single domain name or a line-separated list of domain names to
    


      this function.
     




     The next function is
    


      rootdomain
     


     .
    

     This function takes a subdomain as input and returns the root domain.
    

     For example, if you provide an input of
    


      www.example.com
     


     , the output will be
    


      example.com
     


     .
    

     This function is used to take a root domain from a subdomain, which I can then send to other functions to find more subdomains.
    

     The example code can be found in the
    


      ch08_rootdomain_function.sh
     


     file in this chapter’s folder in the
    


      GitHub repository:
     



rootdomain() {
    # This function takes a subdomain as input and returns the root domain.


     In the preceding code, I first declare the function name, followed by a comment explaining the purpose, input, and output of
    


      the script.
     



    while IFS= read -r line; do


     This line starts a
    


      while
     


     loop that reads input line by line.
    


      IFS=
     


     sets the
    


      internal field separator
     


     to nothing, which prevents leading/trailing
    



     whitespace from being trimmed.
    


      read -r
     


     reads a line from standard input into the
    


      variable line.
     



            echo "$line" | awk -F. '


     This line echoes the current line (subdomain) and pipes it to
    


      awk
     


     .
    

     The
    


      -F.
     


     option tells
    


      awk
     


     to use the
    



     period (
    


      .
     


     ) as the
    


      field separator.
     



            {


     This opens the block of the
    



       awk
      




      script.
     



                n = split($0, parts, ".");


     This line splits the current line (
    


      $0
     


     ) into an array named
    


      parts
     


     using the period (
    


      .
     


     ) as the delimiter.
    

     The
    


      n
     


     variable stores the number of elements in
    


      the array.
     



                if (n >= 3 && (parts[n-1] ~ /^(com|net|org|co|gov|edu|mil|int)$/ && parts[n] ~ /^[a-z]{2}$/)) {


     This condition checks whether the domain has at least three parts and whether the second-to-last part matches a common second-level domain (e.g.,
    


      com
     


     ,
    


      net
     


     ,
    


      org
     


     ,
    


      co
     


     ,
    


      gov
     


     ,
    


      edu
     


     ,
    


      mil
     


     , or
    


      int
     


     ) followed by a two-letter country code (e.g.,
    


      uk
     


     ,
    


      us
     


     ,
    


      or
     




       de
      




      ).
     



                    print parts[n-2] "." parts[n-1] "." parts[n];


     If the condition is true, this line prints the root domain, which consists of the third-to-last, second-to-last, and last parts of
    


      the array.
     



                } else if (n >= 2) {


     This condition checks whether the domain has at least two parts (
    


      e.g.,
     




       example.com
      




      ).
     



                    print parts[n-1] "." parts[n];


     If the condition is true, this line prints the root domain, which consists of the second-to-last and last parts of
    


      the array.
     



                } else {
                    print $0;


     If none of the preceding conditions are met (e.g., the input is a single-label domain), this line prints the
    


      original input.
     



                }
            }'


     The preceding code closes the
    


      if
     


     block, then closes the
    


      awk
     


     block.
    

     Notice that when the curly bracket
    



     closes the
    


      if
     


     block, there is no
    


      fi
     


     keyword like a Bash
    


      if
     


     statement.
    


      awk
     


     has a slightly different syntax for
    



       if
      




      blocks.
     



    done


     This closes the
    



       while
      




      loop.
     



}


     This bracket closes
    


      the function.
     




     The
    


      resolve
     


     function takes a domain name as input and returns an IP address.
    

     The example code can be found in the
    


      ch08_resolve_function.sh
     


     file in this chapter’s folder in the
    


      GitHub repository.
     



resolve() {
    # This function takes a domain as input and returns the IP address.


     This code is the start of the function and a comment that describes what the function does: it takes a domain as input and returns its corresponding
    


      IP address.
     



    while IFS= read -r line; do


     This line starts a
    


      while
     


     loop that reads input line by line.
    


      IFS=
     


     sets the internal field separator to nothing, which prevents leading/trailing whitespace from being trimmed.
    


      read -r
     


     reads a line from standard input into the
    


      variable line.
     



            dig +short "$line" | grep -E '^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$' | head -n 1



      dig
     


     is a DNS lookup utility.
    

     The
    


      +short
     


     option makes the output concise by only printing the IP addresses or
    



     CNAME records.
    


      $line
     


     is the domain name read
    


      from input.
     



    done
    return 0
}



      done
     


     closes the
    


      while
     


     loop’s
    


      do
     


     block.
    


      return 0
     


     signifies to a calling script or function that the script
    


      completed successfully.
     




     The
    


      org
     


     function takes
    



     an IP address as input and returns the
    


      OrgName
     


     value found in the Whois output.
    

     This information tells us who owns the network.
    

     The example code can be found in the
    


      ch08_org_function.sh
     


     file in this chapter’s folder in the
    


      GitHub repository:
     



org() {
    # This function takes an IP address as input and returns the organization name that owns the IP block.
    while IFS= read -r line; do
        whois "$line" | grep OrgName | tr -s ' ' | cut -d ' ' -f 2-
    done
}


     The start of the function through to the start of the
    


      while
     


     loop is virtually the same as in previous scripts.
    

     The line beginning with
    


      whois
     


     runs the
    


      whois
     


     command using the IP address sent as input to the function, runs
    


      grep
     


     to find the line containing
    


      OrgName
     


     , runs the
    


      tr -s ' '
     


     command to squeeze multiple spaces into a single space, and then pipes the output to the
    


      cut
     


     command, which specifies a space as a delimiter and selects the second field through the end of input.
    

     The
    


      tr
     


     program is very handy for squeezing
    



     multiple spaces into a single space, but you can also use it to replace one character with another.
    

     The
    


      cut
     


     program specifies a delimiter (
    


      -d
     


     ) followed by the field
    


      to cut.
     




     The last function ties the other functions together.
    

     It performs domain and subdomain enumeration and prints subdomains, the IP address, and
    


      OrgName
     


     .
    

     It will also find any related root domains and enumerate their subdomains if the input domain is part of a Microsoft 365 tenant with MDI.
    

     This will significantly enhance subdomain discovery.
    

     I tested the Chaos API alone with a particular domain and it returned 553 live subdomains.
    

     When I ran this function and used MDI results to expand the scope to related domains hosted by the same company, it returned 3,682
    


      live subdomains.
     




     The example code can be found in the
    


      ch08_dnsrecon_function.sh
     


     file in this chapter’s folder in the GitHub repository.
    

     The script requires a ProjectDiscovery Chaos API key (
    


      https://chaos.projectdiscovery.io/
     


     ), which
    



     can be obtained for free at the time of writing.
    

     Chaos is the most complete source of DNS data that
    


      I’ve found:
     



dnsrecon() {
    # Check if the correct number of arguments is provided
    if [[ $# -ne 1 ]]; then
        echo "You didn't provide a domain as input."
        echo "Usage: $0 [domain]"
        exit 1
    fi


     Print the usage information and exit if one command-line argument is
    


      not included.
     



    if [[ -z "$CHAOS_KEY" ]]; then
        echo "No chaos API key found. Set env CHAOS_KEY."
        exit 1
    fi


     Check whether the Chaos API key is set in an environment variable.
    

     You should have a line in your
    


      .bashrc
     


     file
    



     that looks like
    


      CHAOS_KEY=[key value]
     


     .
    

     After you edit your
    


      .bashrc
     


     file to add the API key, you’ll need to make it recognized using the
    


      source ~/.
     




       bashrc
      




      command.
     



    local domain=$1
    local domains=''
    local roots=''


     Here, I have declared local variables.
    

     It’s not strictly necessary to declare the variable ahead of its use, I did so based on personal preference.
    

     Declaring variables as
    


      local
     


     ensures that their scope is limited to the function in which they are defined, which helps to avoid potential conflicts with global variables or variables in other functions.
    

     This is critical when the variable is in a function in your
    


      .bashrc
     


     file to prevent collisions with other variables since these functions are available to everything in your
    


      Bash shell.
     



    local mdi_result=$(mdi <<< "$domain")


     Here, I passed the
    


      domain
     


     variable to the
    


      mdi
     


     function to get the list of related domains.
    

     Because the
    


      mdi
     


     function is designed to accept input from
    


      stdin
     


     (
    


      echo example.com | mdi
     


     ) instead of being passed as a function argument (
    


      mdi example.com
     


     ), it must be called as shown with three
    


      <
     


     characters.
    

     In Bash,
    


      <<<
     


     is known as the
    


      here-string
     


     operator.
    

     It is used to pass a string directly as input to a command, rather than reading from a file
    



     or standard input.
    

     This operator essentially provides a quick way to feed a single line of text to
    


      a command.
     



    if [[ -z "$mdi_result" ]]; then
        domains=$(chaos -silent -d "$domain")


     If no domains are returned from the
    


      mdi
     


     function, pass the input domain directly to the Chaos API and assign
    



     the output to the
    



       domains
      




      variable.
     



    else
        echo "$mdi_result" | while IFS= read -r line; do
            root=$(rootdomain <<< "$line")
            chaos_domains=$(chaos -silent -d "$root")
            domains=$(echo -e "$domains\n$chaos_domains")
        done


     This part pipes the content of the
    


      mdi_result
     


     variable line by line to the code inside the
    


      do
     


     /
    


      done
     


     block.
    

     The line of data (a domain) is passed to the
    


      rootdomain
     


     function.
    

     If the line of data is
    


      www.example.com
     


     , this function would return
    


      example.com
     


     .
    

     It then passes this root domain to the Chaos API call and assigns the result to the
    


      chaos_domains
     


     variable.
    

     Finally, the list of subdomains returned from the API call is appended to the list of domains in the
    



       domains
      




      variable.
     



        domains=$(echo "$domains" | grep . | grep -v \* | sort -u)
    fi


     This section of code ensures that blank lines are removed (
    


      grep .
     


     returns non-blank lines), removes any wildcard domains (
    


      grep -v \*
     


     ), and then removes duplicates (
    



       sort -u
      




      ).
     



    echo "$domains" | while IFS= read -r line; do


     This code passes each line of data in the
    


      domains
     


     variable to the
    


      do
     


     /
    


      done
     


     code block.
    

     The
    


      IFS=
     


     part ensures that line endings
    


      remain intact.
     



        ip=$(resolve <<< "$line")
        if [[ -z "$ip" ]]; then
            continue
        fi


     This code passes each domain in the
    


      domains
     


     variable to the
    


      resolve
     


     function, which returns an IP address and stores it in the
    


      ip
     


     variable.
    

     If the
    


      ip
     


     variable is zero-length,
    


      -z
     


     (the domain name could not be resolved to an IP address), it returns
    


      true
     


     and the
    


      continue
     


     keyword
    



     short-circuits the current iteration of the loop and skips to
    


      the next.
     



        orgname=$(org <<< "$ip")
        echo "$line;$ip;$orgname"
    done
}


     If the domain name has successfully resolved to an IP address, the data is printed as
    


      Domain;IP;Org
     


     .
    

     I chose semicolons for the field separator because the
    


      org
     


     value may contain spaces
    


      and commas.
     




     The
    


      dnsrecon
     


     function is called on the command line as
    


      dnsrecon example.com
     


     .
    

     The following is an example of
    


      the output:
     











     Figure 8.7 – The dnsrecon function output
    



     The output in the preceding figure shows that our Bash script has provided us with more targets, and contains information that we can use to determine whether the discovered domains are in scope
    



     by
    


      IP address.
     




     Next, we need to discuss how web applications use domain names to determine which application to serve to a website visitor.
    

     This is critical to
    


      your success.
     






     Using Bash to identify web applications
    



     As a consultant pentester who is
    



     provided a list of IP or network addresses by an external customer, you may fall into a bad habit of just testing defined IP or network addresses and not performing enough OSINT to discover all domain names.
    

     I did this myself when I was a junior pentester and have also witnessed this from people I have mentored.
    

     The reason why this is not ideal is because of how web applications behave when requesting a website using an IP address versus a
    


      domain name.
     




     A web server hosting multiple applications, load balancer, or reverse proxy will return the default site when an IP address is in the URL or HTTP
    


      HOST
     


     header.
    

     Unbeknown to you, there may be additional websites hosted on that IP address and you absolutely will miss out on finding vulnerable applications if you don’t perform DNS enumeration and test applicable domain names.
    

     You can read more about the HTTP
    


      HOST
     


     header
    


      at
     




       https://portswigger.net/web-security/host-header
      




      .
     




     Here’s a relevant example.
    

     OWASP Juice Shop is an intentionally vulnerable website.
    

     You can find an example hosted at
    


      https://demo.owasp-juice.shop/#/
     


     .
    

     If you ping that hostname, you see
    


      the
     







      following:
     











     Figure 8.8 – Pinging OWASP Juice Shop demo
    



     If you were provided with the IP address
    


      81.169.145.156
     


     in scope and scanned that IP and didn’t perform subdomain enumeration, you would visit that site in your browser and see
    



       Not Found
      




      :
     











     Figure 8.9 – Visiting a website via the IP address
    



     In the preceding figure, I have highlighted the relevant parts for you.
    

     I requested a web page via the IP address.
    

     You may see this response and think that this IP address and port aren’t interesting and move on.
    

     However, if you visit the domain name, you see the following website, which
    



     contains
    


      many vulnerabilities:
     











     Figure 8.10 – OWASP Juice Shop, a vulnerable web application
    



     Before you start scanning your scoped IP addresses or network addresses, take the time to fully enumerate DNS first using the tools and techniques shown next.
    

     Then, append the discovered domain names that resolve to the scoped IP addresses to the end of your scope file.
    

     I can’t stress enough how important this is.
    

     It could very well be the difference between a zero-finding pentest report (not to mention the risk of the customer getting breached due to your oversight) and finding high-impact vulnerabilities.
    

     If you simply paste the list of network or IP addresses into a vulnerability scanner and then think there’s nothing to exploit based on the scan results, you will overlook
    


      exploitable findings.
     




     Now that you have a better understanding of how web applications use the
    


      HOST
     


     header, in the next section, we’ll examine how to discover the application root or subdomains served by a web server on any particular IP address.
    

     Having this information will be critical to our success when scanning IP or
    


      network addresses.
     






     Using Bash for certificate enumeration
    



     I performed this one external network pentest that had many thousands of live IP addresses in scope.
    

     One of the problems I ran into was that I was given large network blocks and needed to take the live IP addresses and discover hostnames before I could properly scan the web servers.
    

     Remember
    



     earlier in this chapter where I demonstrated how the web page you see may be different when you request the website via IP address
    


      versus hostname?
     




     Many thousands of those IP addresses were resolved to random subdomains in DNS, and they were usually proxy servers placed in front of a server pool.
    

     We also knew that the customer was
    



     using a
    


      content delivery network
     


     (
    


      CDN
     


     ) in front of their websites, and traffic was filtered by a
    


      web application firewall
     


     (
    


      WAF
     


     ), which blocked attempts to
    



     scan the sites.
    

     Furthermore, if we requested a website via domain name, the domain names resolved to an IP address residing on the CDN and the CDN IP addresses were not in scope so we couldn’t
    


      attack them.
     




     Fortunately for me, the customer wasn’t filtering incoming traffic to allow only source IP addresses of the CDN provider.
    

     At that point, what I needed to do was discover which website was being hosted on each IP address and then override DNS so that I could manually map domain names to IP addresses.
    

     This would allow me to access the web applications directly.
    

     I came up with a crafty way to discover which websites were hosted on those IP addresses and bypass the CDN WAFs at the same time.
    

     I found that the Nuclei (
    


      https://github.com/projectdiscovery/nuclei
     


     ) vulnerability scanner has a template for discovering DNS names
    



     associated with
    


      Transport Layer Security
     


     (
    



       TLS
      




      ) certificates.
     




     TLS certificates are digital certificates that authenticate the identity of a website and enable an encrypted connection.
    

     They contain information about the certificate holder, the certificate’s public key, and the
    



     digital signature of the issuing
    


      certificate authority
     


     (
    


      CA
     


     ).
    

     The TLS
    


      Subject Alternative Name
     


     (
    


      SAN
     


     ) is an extension to the X.509 specification that
    



     allows users to specify additional hostnames for a single SSL/TLS certificate.
    

     This means a single certificate can secure multiple domains and subdomains, simplifying certificate management and
    


      reducing costs.
     




     The Nuclei vulnerability scanner has a scan template that extracts TLS SANs from the digital certificate.
    

     First, I scanned the list of live IP addresses with Nuclei.
    

     Here’s an example of using the Nuclei
    


      ssl-dns-names
     


     template to scan a network address that was in scope for the
    



     Hyatt Hotels bug bounty program (
    


      https://hackerone.com/hyatt/policy_scopes
     


     ) at the time
    


      of writing:
     











     Figure 8.11 – Scanning a network for TLS certificate SANs
    



     Make sure you add the
    


      -o [filename]
     


     option to the Nuclei scan command seen in
    



       Figure 8
      




      .11
     


     to save the output to
    


      a file.
     




     Now that we have this output, the next step is to clean it up and reformat it for our
    


      hosts
     


     file.
    

     The
    


      hosts
     


     file is a simple text file that maps hostnames to IP addresses.
    

     It’s an essential part of the networking stack in any operating system, including Linux.
    

     You can view the contents of your
    


      hosts
     


     file by entering the
    


      cat /
     




       etc/hosts
      




      command.
     




     Before moving on, it’s important to understand how DNS works in regard to the
    


      hosts
     


     file.
    

     On a Linux system, when you use a domain name for network communications, your computer must resolve the domain name to an IP address.
    

     At a very basic level, when you use a domain name to communicate with other hosts over the network, the first step is for your computer to check its own hostname for a match.
    

     Next, it checks for an entry in the
    


      hosts
     


     file.
    

     If that doesn’t resolve the hostname, it communicates with the DNS server in your network interface configuration.
    

     Essentially, hardcoding a domain name to an IP address in your
    


      hosts
     


     file overrides DNS.
    

     Microsoft Windows also uses a
    


      hosts
     


     file for the same purpose, although it’s in a
    


      different location.
     




     The following screenshot shows the contents of my
    


      hosts
     


     file before making
    


      any modifications:
     











     Figure 8.12 – The content of my /etc/hosts file
    



     The
    


      hosts
     


     file entries start on a new line with an IP address, followed by either tabs or spaces, followed by one or more domain names.
    

     You can use tabs or spaces, just be consistent.
    

     Now that you
    



     understand the
    


      hosts
     


     files, let’s move on and learn how to reformat the data from the Nuclei scan for insertion into our
    



       hosts
      




      file.
     




     The following code will take a filename as the only command-line argument and output lines you can copy and paste into your
    


      hosts
     


     file.
    

     The code is thoroughly commented to explain what each part does.
    

     The example code can be found in the
    


      ch08_nuclei.sh
     


     file in this chapter’s folder in the GitHub repository.
    

     I’m going to split up the code into smaller chunks to explain each part as we go.
    

     It will be helpful to have the script in GitHub open on your screen to compare to the following
    


      code narrative:
     



if [ "$#" -ne 1 ]; then
    echo "Converts Nuclei ssl-dns-names scan output to hosts file format"
    echo "Usage: $0 /path/to/file"
    exit 1
fi


     If a file path isn’t passed on the command line, print usage and abort.
    

     It first checks whether the number of arguments (
    


      $#
     


     ) is not equal (
    


      -ne
     


     ) to
    


      1
     


     .
    

     If the statement in square brackets is true, then echo the description of th
    





     e script and usage example
    


      and exit.
     




     In the following code, I pipe the file content to the
    


      cut command:
     



cat "$1" | cut -d ' ' -f 4- | \


     The
    


      cut
     


     command uses a space as delimiter from the 4th field to the end of line.
    

     The output is piped to the next command.
    

     A backslash (
    


      \
     


     ) at the end of a line continues the command on to the
    




      next line.
     




     In the following code, multi-part (6) sed commands are separated
    


      by semi-colon:
     



sed 's/:443//;s/\[//g;s/\]//g;s/"//g;s/,/ /g;s/ \*\.[^ ]*//g' | \



      Only the beginning and end of the series of sed commands are enclosed in
     


       single quotes.
      





       s/:443//
      


      : Removes the string
     


       :443
      


      from
     


       the input.
      





       s/\[//g
      


      : Removes all occurrences of the [ character from the input.
     

      The
     


       g
      


      at the end means
     


       global
      


      , so it applies the substitution to all matches in
     


       each line.
      





       s/\]//g
      


      : Removes all occurrences of the
     


       ]
      


      character from the input (global).
     

      The
     


       ]
      


      character must be
     


       escaped (
      




        \
       




       ).
      





       s/"//g
      


      : Removes all occurrences of the double quote (
     


       "
      


      ) character from the
     


       input (global).
      





       s/,/ /g
      


      : Replaces all occurrences of the comma (
     


       ,
      


      ) character with a
     


       space (global).
      





       s/ \*\.[^ ]*//g
      


      : This expression typically removes wildcard subdomain entries like
     


       *.example.com
      


      (global).
     

      It removes any space followed by
     


       *.
      


      (escaped) and any sequence of non-space characters.
     

      Remember from
