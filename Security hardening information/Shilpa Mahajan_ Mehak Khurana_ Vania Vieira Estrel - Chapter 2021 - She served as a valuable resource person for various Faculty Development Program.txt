# Security Chapter Extract
Book: Shilpa Mahajan_ Mehak Khurana_ Vania Vieira Estrela - Applying Artificial Intelligence in Cybersecurity Analytics and Cyber Threat Detection (2024, WILEY) - libgen.li
Chapter: 2021 - She served as a valuable resource person for various Faculty Development Programs (FDPs), workshops, guest lectures, invited talks, panelists, etc. Her active involvement in chairing sessions at various conferences underscores her expertise and prominence in the academic community. She edited books for esteemed publishers such as Springer, CRC Press, Wiley, and edited many more. Furthermore, her role as a reviewer for reputable journals and a Technical Program Committee (TPC) member for various international conferences highlights her commitment to fostering excellence. Her contributions have earned her recognition as the Emerging Women Leader in Cybersecurity Sector in 2023 by StarDiVvaz Women Awards, presented by Dr. Rajshri Singh, IPS, IGP Haryana State Crime. Likewise, her selection as one of the top three finalists for the Cyberjutsu award by Womencyberjutsu in Virginia, US, underscores her standing as a prominent Cyber Educator.
Security Relevance Score: 23
Word Count: 7485
Extracted: 2025-06-13 23:40:31

---

She served as a valuable resource person for various Faculty Development Programs (FDPs), workshops, guest lectures, invited talks, panelists, etc. Her active involvement in chairing sessions at various conferences underscores her expertise and prominence in the academic community. She edited books for esteemed publishers such as Springer, CRC Press, Wiley, and edited many more. Furthermore, her role as a reviewer for reputable journals and a Technical Program Committee (TPC) member for various international conferences highlights her commitment to fostering excellence. Her contributions have earned her recognition as the Emerging Women Leader in Cybersecurity Sector in 2023 by StarDiVvaz Women Awards, presented by Dr. Rajshri Singh, IPS, IGP Haryana State Crime. Likewise, her selection as one of the top three finalists for the Cyberjutsu award by Womencyberjutsu in Virginia, US, underscores her standing as a prominent Cyber Educator.


Dr. Vania Vieira Estrela has ample experience teaching postgraduate and undergraduate courses. She holds a B.Sc. degree from the Federal University of Rio de Janeiro (UFRJ) in Electrical and Computer Engineering (ECE), an M.Sc. from the Technological Institute of Aeronautics (ITA), Brazil, and M.Sc. in ECE at Northwestern University, USA, and a Ph.D. in ECE from the Illinois Institute of Technology (IIT), Chicago, IL, USA. She has taught at DePaul University, USA, and Universidade Estadual do Norte Fluminense (UENF), Brazil. She was a visiting professor at the Polytechnic Institute of Rio de Janeiro (IPRJ)/State University of Rio de Janeiro (UERJ) in Brazil. She works at Universidade Federal Fluminense’s (UFF) Department of Telecommunications. She has proposed and participated in various pedagogical projects for the specialities of “Computer Engineering” at UENF, “Computer Technology” at Universidade Estadual da Zona Oeste (UEZO)/UERJ, and “Material Science and Engineering with Emphasis on Polymers” also at UEZO/UERJ. Research interests include Cyber‐Physical Systems, Signal/Image/Video Processing, Multimedia, Biomedical Engineering, Neuroscience, Electronic Instrumentation, Computer Architecture, Unmanned Aerial Systems, Modeling/Simulation, Sustainable Projects, Smart Designs, Inverse Problems, Communications, Motion Estimation and Understanding, Artificial Intelligence, and Geoprocessing. She edits and reviews for several prestigious publishers. She is engaged in Humanitarian Engineering, Technology Transfer, STEAM Education, Environmental Issues, Digital Inclusion, and all UN Sustainable Development Goals (SDGs). She has served as editor of more than 15 books and special issues. She has served on a plethora of technical and organizational committees and is a member of IEEE.











List of Contributors


 
Nikolaos AndreopoulosComputer Science DepartmentTechnological Institute of IcelandReykjavíkIceland
Joaquim T. de AssisInstituto Politecnico do Rio de JaneiroNova FriburgoRJBrazil
Avi ChakravartiAmity School of Engineering and TechnologyAmity UniversityNoidaUttar PradeshIndia
Suman DasInformation SecurityZensar TechnologiesKolkataIndia
Anand DeshpandeElectronics and Communication EngineeringAngadi Institute of Technology and ManagementBelagaviIndia
Chingakham Nirma DeviDepartment of Computer ScienceVels Institute of ScienceTechnology and Advanced Studies (VISTAS)ChennaiIndia
Edwiges G.H. GrataDepartment of TelecommunicationsFederal Fluminense University (UFF)NiteróiRJBrazil
JahnaviDepartment of Computer ScienceDr. B.R. Ambedkar National Institute of TechnologyJalandharIndia
R. Jenice AromaDepartment of CSEKarunya Institute of Technology and SciencesKarunya UniversityCoimbatoreIndia
Maria A. de JesusDepartment of TelecommunicationsFederal Fluminense University (UFF)NiteróiRJBrazil
Ashish JoshiInformation SecurityZensar TechnologiesPuneIndia
Awais Khan JumaniDepartment of Computer ScienceSindh Madressa‐tul‐Islam UniversityKarachiSindhPakistan
Keshav KaushikSchool of Computer ScienceUniversity of Petroleum and Energy StudiesDehradunUttarakhandIndia
Abdullah A. KhanResearch Lab of Artificial Intelligence and Information SecurityFaculty of ComputingScience and Information TechnologyBenazir Bhutto Shaheed UniversityKarachiSindhPakistan
Asiya KhanSchool of EngineeringComputing and Mathematics (Faculty of Science and Engineering)University of PlymouthPlymouthUK
Mehak KhuranaThe NorthCap UniversityGurugramIndia
Dhanashree KulkarniDepartment of Computer Science and EngineeringAngadi Institute of Technology and ManagementBelagaviIndia
Asif A. LaghariSindh Madresstul Islam UniversityKarachiSindhPakistan
Ricardo T. LopesFederal University of Rio de Janeiro (COPPE/UFRJ)Nuclear Engineering Laboratory (LIN)Rio de JaneiroRJBrazil
Shilpa MahajanDepartment of Computer ScienceThe NorthCap UniversityGurgaonIndia
Geetika MunjalAmity School of Engineering and TechnologyAmity UniversityNoidaUttar PradeshIndia
Paridhi PasrijaThe NorthCap UniversityGurugramIndia
Vishwas PitreInformation SecurityZensar TechnologiesPuneIndia
Tushar PuriAmity School of Engineering and TechnologyAmity UniversityNoidaUttar PradeshIndia
Supriya RahejaAmity UniversityNoidaIndia
Kumudha RaimondDepartment of Computer Science and EngineeringKarunya Institute of Technology and SciencesCoimbatoreIndia
R. Renuga DeviDepartment of Computer Science and Applications (MCA)SRM Institute of Science and TechnologyRamapuramChennaiIndia
Satya SaladiInformation SecurityZensar TechnologiesHyderabadIndia
Mohammad ShabazChitkara University Institute of Engineering and TechnologyChitkara UniversityRajpuraPunjabIndia
BhawnaDepartment of Computer ScienceThe NorthCap UniversityGurgaonIndia
Utkarsh SharmaAmity School of Engineering and TechnologyAmity UniversityNoidaUttar PradeshIndia
Laishram Kirtibas SinghDepartment of Computer ScienceVels Institute of ScienceTechnology and Advanced Studies (VISTAS)ChennaiIndia
Utkarsh SinghThe NorthCap UniversityGurugramIndia
Dalmo StutzCentro Federal de Educação Tecnológica Celso Suckow da Fonseca (CEFET) at Nova FriburgoNova FriburgoRJBrazil
Lin TengSoftware CollegeShenyang Normal UniversityShenyangChina
Andrey TerzievTerziASofiaBulgaria
Diego M.R. TudescoDepartment of TelecommunicationsFederal Fluminense University (UFF)NiteróiRJBrazil
UrvashiDepartment of Computer Science and EngineeringDr. B.R. Ambedkar National Institute of TechnologyJalandharIndia
Shoulin YinShenyang Normal UniversityShenyangLiaoning ProvinceChina











Preface


In the ever‐evolving digital landscape, the fusion of artificial intelligence (AI) with the realm of cybersecurity has introduced a formidable ally. AI’s unique capabilities in processing vast data volumes, recognizing intricate patterns, and swiftly adapting to emerging threats have marked the dawn of a new era in cyber defense. As AI continues to seamlessly integrate into our cybersecurity strategies, it plays a pivotal role in our ongoing battle against the ever‐shifting landscape of cyber threats.
The digital landscape is rapidly evolving, and with it, the nature of cyber threats. This book addresses a pressing need – to bridge the knowledge gap between the potent capabilities of AI and its practical applications in fortifying cybersecurity. Our aim is to provide readers with a comprehensive guide to understand, implement, and harness the power of AI in safeguarding digital ecosystems. Collecting insights from seasoned cybersecurity professionals and AI experts, this book seeks to demystify the world of AI in cybersecurity. It aims to serve as a valuable resource for cybersecurity professionals looking to enhance their defenses, students eager to explore the exciting intersection of AI and cybersecurity, and individuals concerned about their online security. Another aim of this book is to empower our readers with knowledge and tools to shield against evolving cyber threats and inspire innovation in the field.
This book offers a comprehensive exploration of the synergy between AI and cybersecurity. It delves into the realm of AI‐powered tools, techniques, and practices that empower organizations and individuals to stay ahead of malicious actors. The scope of the book encompasses AI applications in intrusion detection, threat identification, and risk assessment, among others. It provides practical guidance, real‐world case studies, and a holistic view of the evolving landscape of cyber threats and the innovative solutions AI offers to mitigate them. While we strive to cover a wide spectrum of AI techniques tailored for cyber defense, it is important to recognize that the field of AI and cybersecurity is dynamic and ever‐evolving. This book does not claim to be an exhaustive encyclopedia; rather, it serves as a snapshot of the state of the field at the time of its writing. As technology progresses, new challenges and solutions will arise, and our understanding of the subject will continue to evolve.
This book builds upon the existing body of literature that explores the integration of AI and cybersecurity, acknowledging the pioneering work of researchers and professionals in this field. It provides a comprehensive overview of the current landscape while offering fresh perspectives and insights.
In closing, this collaborative effort reflects the dedication of experts passionate about securing our digital world. The fusion of AI and cybersecurity has the potential to reshape the future of digital security. We hope this book empowers the readers to harness this potential and become a guardian of the digital realm.



    
Shilpa MahajanThe NorthCap University, India


    
Mehak KhuranaThe NorthCap University, India


    
Vania Vieira EstrelaFluminense Federal University, Brazil














Acknowledgment


Heartfelt gratitude to the contributors and experts whose unwavering dedication has shaped this book. Their invaluable insights and expertise have played an instrumental role in bringing this collaborative effort to fruition.











Disclaimer


The publisher and the author make no representations or warranties with respect to the accuracy or completeness of the contents of this work and specifically disclaim all warranties, including without limitation warranties of fitness for a particular purpose. No warranty may be created or extended by sales or promotional materials. The advice and strategies contained herein may not be suitable for every situation. This work is sold with the understanding that the publisher is not engaged in rendering legal, accounting, or other professional services. If professional assistance is required, the services of a competent professional person should be sought. Neither the publisher nor the author shall be liable for damages arising here from. The fact that an organization or Website is referred to in this work as a citation and/or a potential source of further information does not mean that the author or the publisher endorses the information the organization or Website may provide or recommendations it may make. Further, readers should be aware that Internet Websites listed in this work may have changed or disappeared between when this work was written and when it is read.











Note for Readers


Dear Readers,
This book is a collaborative effort aimed at providing you with a comprehensive understanding of the intricate world of cybersecurity analytics. The intention of the authors/editors is to equip you with insights, strategies, and practical knowledge that will empower you in navigating the complexities of cyberthreats. Throughout these chapters, you’ll find a blend of theoretical concepts and hands‐on approaches, all crafted to enhance your understanding and proficiency in addressing contemporary cybersecurity challenges. Whether you are a seasoned cybersecurity professional, a student entering the field, or simply someone passionate about the evolving digital landscape, we hope you find this book both informative and inspiring.











Introduction


In the realm of cybersecurity, where digital landscapes are in constant flux, the unceasing evolution of cyber threats poses an ever‐growing challenge. Navigating this intricate web of potential risks requires a comprehensive understanding of the various facets of cybersecurity and the implementation of effective detection and mitigation strategies. This book, “Applying Artificial Intelligence in Cybersecurity Analytics and Cyber Threat Detection,” takes a deep dive into the dynamic world of cybersecurity analytics, emphasizing the pressing need for innovative approaches to counteract a diverse array of cyber threats. The chapters within this book are carefully curated to offer a nuanced exploration of techniques, methodologies, and practical applications designed to fortify our defenses against malicious activities in the digital space.
As we embark on this exploration, the aim is to equip readers with a profound understanding of the multifaceted landscape of cybersecurity, encompassing not only the traditional forms of threats but also the more contemporary and sophisticated challenges that emerge with technological advancements. Each chapter is crafted to provide insights, analyses, and actionable strategies, offering a holistic view of cyberthreat detection and mitigation. The dynamic nature of the cybersecurity landscape necessitates an adaptive and informed approach. Therefore, this book serves as a compendium of knowledge, drawing on the collective expertise of contributors who bring real‐world experience and practical insights to the forefront. It is intended for cybersecurity professionals seeking to enhance their skills, students entering the field, and anyone intrigued by the ever‐evolving landscape of digital security.
As we traverse through the following pages, the goal is to shed light on effective strategies, methodologies, and practices that go beyond mere detection. The emphasis lies in understanding the intricacies of cyberthreats, enhancing the analytical capabilities of security practitioners, and fostering a proactive stance against potential risks. In closing, the collective wisdom encapsulated in these chapters aims to empower readers with the knowledge and tools needed to navigate the complexities of cybersecurity analytics. By fostering a deeper understanding of cyber threats and effective detection mechanisms, we can collectively contribute to fortifying the digital realms we inhabit.











Part IArtificial Intelligence (AI) in Cybersecurity Analytics: Fundamental and Challenges


 











1Analysis of Malicious Executables and Detection Techniques
Geetika Munjal and Tushar Puri
Amity School of Engineering and Technology, Amity University, Noida, Uttar Pradesh, India


1.1 Introduction
An instruction set created to harm a system is known as malware, which is short for malicious software [1]. The production of malware is increasing, making it more challenging for security firms to identify it. Traditionally, security firms and antivirus vendors employed antivirus software to distinguish between dangerous and clean data. Most of these tools compare the malicious programs to a database of well‐known malware signatures using a signature‐based method to identify them [2, 3]. The signature of an executable file serves as its distinctive identifier, and signatures can be generated using static, dynamic, and hybrid methodologies. However, this technique’s drawback is that it is ineffective at detecting new malware samples. Due to the continuous increase in the quantity of new malware samples, these signatures must be continually updated [3].
Static analysis, the method that extracts features from a program’s binary code by examining it and building models that illustrate the features, was developed to counter these tactics. These techniques are used to distinguish between hazardous and useful files. However, static analysis is easily evaded since malware authors utilize numerous code obfuscation techniques, like metamorphic and polymorphic approaches. Despite providing valuable insight into the behavior of programs, functions, and parameters, static analysis can still be unreliable [1].
Dynamic analysis, on the other hand, implements the software inside a secure environment to observe its behavior. This method exposes the code obfuscation strategies used by malware authors and works well with compressed files. However, dynamic analysis needs to be carried out within a secure environment to prevent system damage and can be time‐consuming. Additionally, malware may behave differently in a virtual (secure) environment compared to an actual environment, leading to an incorrect log of behavior [4].
Combining static and dynamic analysis techniques can result in a more effective and reliable malware detection strategy. The main categories of executable malicious code (MC) are (i) MC that has been injected, such as worms that use buffer overflow exploits to inject their code into active software processes, (ii) dynamically generated malware (MC), and (iii) obfuscated malware (MC), which includes, viruses, Trojan horses, and worms that cloak their code via data manipulations and obscure computations to avoid detection and analysis. Polymorphic viruses or Trojans are an example of obfuscated malware [1]. Static feature‐based analysis seems to be effective and efficient, as it enables network detection when the algorithm is loaded into memory [5, 6]. However, when the malicious file or code is compressed or encrypted, it becomes more challenging to detect. As a result, dynamic feature analysis must first unpack or decrypt the CPU instructions before being executed. Dynamic analysis for detecting network malware may not be practical due to the rapidity of network traffic [1].
Malicious executables are classified into three types based on how malware is transmitted: viruses, Trojan horses, and worms [7]. They infect already‐running programs, causing them to become “infected” and spread to other programs when they are run. Worms, on the other hand, are standalone programs that propagate throughout a network, usually by taking advantage of bugs in the software that is operating on networked machines. Trojan horses disguise themselves as legitimate applications while carrying out harmful tasks. Malicious executables aren’t really usually easily categorized and can behave in a variety of ways. Virus detection tools, including McAfee Virus Scan are extensively used, and Dell suggests Norton Antivirus for any and all new computers [7]. Although the titles of these programs include the term “virus,” some also detect worms and Trojan horses. This approach of looking for recognized patterns of MC, called signature‐based detection, is effective in detecting previously known threats [8]. However, it is not always effective against new and unknown threats [9]. In response to these limitations, a new approach to virus detection called behavior‐based detection has emerged. Based on their behavior, this strategy employs artificial intelligence (AI) and deep learning (DL) algorithms to discover and categorize new and unknown risks [10].
Behavior‐based detection relies on monitoring the actions of a piece of software, looking for signs of malicious behavior [8]. If a piece of software is behaving in a way that is deemed suspicious, it can be classified as a potential threat and further analyzed. This approach is more proactive and effective against new and unknown threats than traditional signature‐based detection [11]. In recent years, AI and machine learning (ML) algorithms have become more sophisticated, making it possible to automatically detect malware in real‐time and without human intervention [12].


1.2 Malicious Code Classification System
A static analysis approach is proposed to automate the discovery and categorization of the type of file without executing it, using a MC classification model. The classification system takes all files, including MC, normal files, and source files, as input data. During the pre‐processing step, the portable executable (PE) information extraction module and the picture production module are used to produce input data that is used in the classification stage. In the subsequent classification step, a variety of algorithms, including convolutional neural network (CNN), random forest, gradient boosting, and decision tree algorithms, are used to decide if the input is malicious. The final classification of MC is achieved by integrating the results from each model. The classification outcomes are stored in a database that includes information about the data along with a single value indicating whether or not the data is harmful. The system uses a learning model that has been developed using different algorithms as a preparation step. The input file is processed and converted into input data for the model by extracting hash values, PE data, and performing image conversion.
Hash Extraction: The input data is first transformed into an eigenvalue from its hash value to determine if the input data is duplicated. In the database update step, the classification outcome of newly entered data is incorporated into the database, and duplicate data is updated using the extracted hash value as a primary key.
Data extraction from PE: The header and sections of the PE structure contain the necessary data for PE files to function correctly in Windows. The capability to identify installed dynamic link libraries (DLLs) as well as the functions they perform using the import address table (IAT) inside the PE Header enables the extraction of malignancy‐related data from PE structures without the need to execute MC. If the file contains a PE structure, the header and section portions may be used to extract 55 characteristics, including entropy and packers. The binary file’s packing information is located using the Yet Another Reverse Engineering Framework (YARA) rule configuration, using signatures to recognize and categorize MC types. The image creation module visualizes and converts the input file for CNN by transforming the input data into a one‐dimensional vector [13].


1.3 Literature Review
In the field of malware detection, two major techniques have been employed: static analysis and dynamic analysis. The application of ML methods has been proposed to improve the performance of malware detection. Schultz et al. [1] introduced a method of using ML to detect new malicious executables by using three distinct byte sequences, readable texts, and PE as static features. The method was tested on 4266 different files and achieved an accuracy of 97.11% using the Bayes algorithm for classification. Usukhbayar et al. [2] presented a framework that utilized three static features, including data from the PE Header, application programming interface (API) function calls made by DLLs, and DLLs. They chose the subset of characteristics using data mining techniques like information gain and tested three different classification methodologies: Svms, Naive Bayes (NB), and J48 where maximum accuracy was obtained by J48 at 98%. Tzu‐Yen Wang et al. [3] used data contained in the PE Headers to detect malware. Their dataset consisted of 9771 different programs, including backdoors, email worms, Trojan horses, and viruses. The accuracy rates for viruses, email worms, Trojan horses, and backdoors were 97.19%, 93.96%, 84.11%, and 89.54%, respectively, demonstrating high detection rates for email worms and viruses. With the advancement of dynamic malware analysis, researchers have shifted from static feature extraction to dynamic analysis. Tian et al’s use of Weka classifiers to extract dynamic characterestics (API call sequences) out of an executable file operating in a virtual environment to separate malware from trustworthy software and identify the malware family. The dataset included 1824 executables, and the accuracy was 97%. Wang et al. [5] also proposed the use of dynamic analysis for malware detection, using similarity matrices of dynamic extraction technologies on a dataset of 104 files. They achieved an accuracy of 93%. Santos et al. [14] proposed a hybrid strategy that combined the static and dynamic features of an executable file. By using a semi‐supervised learning method, in which only 50% of the training data was labeled, they achieved an accuracy of 88%. PE‐Miner was suggested by Shafiq et al. [13] as a technique for finding PE malware. They collected 189 characteristics first from PE file segments and used feature selection/reduction methods like principal component analysis (PCA) to choose the most pertinent features. The technique was evaluated using five supervised algorithms Ibk, J48, NB, RIPPER, and SMO on seven distinct types of dangerous executables. The identification of viruses produced the highest results (99% true positive rate and 0.5% false positive rate).
Lo, Pablo, and Carlos [8] investigated the bare minimum requirements for PE malware detection and concluded that by using an assembly classification schema, they could detect malware with 99% accuracy using nine features. However, their base feature pool was created using third‐party software, VirusTotal, and the system was not evaluated against various malware detection techniques. PE files are executable files that typically run on the Windows platform and have the .exe or .dll extension. The executable code text part, the data sections (.bss, .rdata, and.data), the resource section (.rsrc), the export section (.edata), and the import section are all portions that make up a PE file (.idata), among others. The PE file format is defined by Microsoft and is documented in the PE and common object file format (COFF) specifications, which can be found in the microsoft developer network (MSDN) library. The point of entry (the starting location of the script to be run), the number of sections, the size of the additional header, and other crucial details about the file are all contained in the PE file header. Information about each portion of the file is provided in the section table, including the name, virtual size, virtual address, and raw data size. The text section contains the executable code of the file, which is machine code that the computer can execute directly. The data sections contain initialized and uninitialized data used by the program. The resource section contains information about the resources used by the program, such as icons, bitmaps, and dialog boxes. The export section contains information about the functions and variables that are exported from the file, allowing other files to call them. Information on the variables and functions loaded from other files is provided in the import section, which is needed by the program. Overall, the PE file format provides a way for Windows to efficiently load and execute programs, making it an important component of the Windows operating system.


Table 1.1 Comparison of existing malware detection approaches.




Features
Kirin
STREAM
SmartDroid
AMDetector  


Method used
BNF notation specifications Action strings and static permission labels are equivalent
Emulation of machine learning input using monkey
GUI‐based trigger circumstances Activity call graphs and function call graphs
Analysis of an attack tree hybrid 

Advantages
Decent performance and ease of implementation
Suited for extensive research. Platform for distributed experimentation
While dynamic analysis looks at sensitive behaviors, static analysis pinpoints activity switch connections. There is a substantial amount of coding for the detection
Rules are arranged through the use of an attack tree to get precise and programmable outcomes. While dynamic analysis verifies the smaller rule set, static analysis looks for possible assaults. triggers depending on components 

Drawbacks
Nine rules are not enough. The real behavior of an application cannot be adequately modeled by static authorization features
User interaction is not faithfully simulated by the Monkey tool. The classifiers produce a lot of false positive results
Other than activity, there is no trigger for components such as service and broadcast
Manually developed rules A detailed dynamic analysis takes a long time 

Detection result
Ten of the 311 apps did not pass the rules. Five of them are considered dangerous, the other five are seen to be reasonable
Bayes net Logistic TPR: 81.25% 68.75% FPR: 31.03% 15.86%
A UI‐based trigger situation that triggers a behavior may be seen on SmartDroid. It is unable to expose trigger circumstances that are logic‐based or indirect, though
TPR: 88.14% FPR: 1.80% Accuracy: 96.57%   

Table 1.1 compares four existing malware detection approaches, namely Kirin, STREAM, SmartDroid, and AMDetector. It includes information on the methods used, advantages, drawbacks, and detection results of each approach. The data shows varying levels of performance and limitations in the different approaches.


1.4 Malware Behavior Analysis
The categorization of malicious executable files can be based on a wide range of factors, including execution time, network activity, registry access frequency, number of accessed files, and more. However, the most promising approach is to categorize executable files based on an examination of their behavior. Such a classification will allow for the identification of classes linked to the fundamental concepts driving the functionality and intent of malicious software. To differentiate between these classes, clustering algorithms should feed data that accurately describes the behavior of executable files. It is recommended that this information be obtained by sequencing the calls to WinAPI functions. To analyze the behavior of each file, executables are run in a virtual environment, and the API call logs of each file are saved. These features are then combined after static and dynamic features have been extracted. ML classifiers use the integrated feature set as input to identify files as malicious or benign. The header and sections of the PE structure contain the data necessary for PE files to operate on Windows. The DLL that was loaded and the function being utilized may both be identified using the IAT within PE Header. Thus, information about malignancy may be obtained from PE components without the need to execute the MC [5]. If the information has a PE structure, the header and section parts of a file have been utilized to extract a total of 55 features, including entropy and packers. By using YARA rule setting, the file’s packing information can now be found within the binary file. The YARA rule comprises tools that categorize different kinds of malicious programs depending on their signatures and can identify them. The maliciousness of code can be categorized using conventional techniques if the patterns are compared and found to be malicious.
There have been various techniques proposed and implemented to prevent malicious program executions at the client side and on cloud hosts. In this section, we will review some of the most notable techniques and their limitations. Forest et al. [6] introduced a process‐level anomaly detection method for buffer overflow and symbolic link attacks. The authors differentiated typical and unusual features using brief System Call sequences produced by an active privileged process. Researchers examined the execution of procedure System Call sequences and identified typical behavior. Lee et al. [15] distinguished between typical and abnormal patterns in UNIX processes. Using a ML approach, they discovered abuses and intrusions in UNIX processes and demonstrated RIPPER, a rule‐based training technique, was used by them to analyze information obtained from UNIX sendmail software.
A technique for identifying intrusions based on invasive System Calls was put out by Warrender et al. [16] They captured the kernel’s System Call patterns and gained knowledge of over four distinct techniques for locating intrusions based on the System Call sequences, identifying privileged processes, and studying their normal behavior. An artificial neural system was utilized by Ghosh et al. [17] to learn the normal System Call pattern of UNIX program execution. They used the Defense Advanced Research Projects Agency (DARP) dataset to establish profiles for over 150 different programs and trained a neural network for each program to recognize unusual behavior. Liao et al. [18] developed a novel method for identifying typical program behavior by using the frequencies of System Calls and classifying it as ordinary or intrusive behavior using a K‐nearest neighbor (KNN) classifier. Qing et al. [10] based their method on rough set theory. They took the System Call sequences produced during a process’s regular executions and extracted rules with the smallest possible size to build a model of the process’s typical behavior. Then, based on the normal behavioral model of the constructed process, they employed a crude set concept algorithm to detect intrusions. Sun et al. [18] recommended Collabra, which provides a filtration layer within the cloud to protect the cloud and the hosts from illegal access. A technique for automated intrusion assessment in the cloud was put out by Arshad et al. [11]. They categorized all attacks based on three security attributes: availability, confidentiality, and integrity. They used supervised and unsupervised learning techniques to create training datasets and mapped System Calls to these three attributes based on the type of attack. However, a demonstration of the approach is missing.
Using frequent System Call sequences, Hai et al. [12] presented an automated method for cloud‐based intrusion detection. They used a Hidden Markov model (HMM) to detect potential threats and an automated mining algorithm to extract frequently occurring System Call sequences. This approach, however, demands continual learning and detection resources, and the rule extraction process is computationally challenging. Sebastian et al. [19] proposed a method of introspection for detecting kernel rootkits. Based on alterations to the system state, they were able to locate rootkits. The system state was examined using a bottom‐up methodology, starting from a binary representation down to the kernel object level. The authors were successful in identifying kernel rootkits using their method. However, the analysis and reporting are complex, and the method is not architecturally independent because it is based on the kernel level. Intrusion detection in cloud environments is a crucial aspect of ensuring the security of cloud‐based systems. The traditional approach to intrusion detection involves the use of System Calls and process states to gauge the similarity of the system to itself. However, this approach has several limitations and can be ineffective in detecting slow‐moving threats. In this context, measures for self‐similarity are used to identify abnormalities in Kwon et al.’s [20] proposed self‐similarity‐based strategy for intrusion detection within the cloud.
The self‐similarity measure is computed using cosine similarity, making it a system‐wide strategy. However, this approach is not always accurate enough to identify attacks that occur gradually. Kong et al. [21] proposed an alternative approach, Ad‐joint, which uses an Ad‐joint to monitor the kernel state of the protected system. This approach provides two layers of security but also increases the demand for additional resources. Despite the efforts made to date, several research gaps still exist in the field of intrusion detection in the cloud. For instance, previous techniques have not been effectively applied to newer systems such as the cloud, which requires a distributed architecture with synchronization, log collection, alerts, and response mechanisms. Additionally, the cost–benefit analysis of using the self‐similarity‐based approach in cloud infrastructure does not support the solution’s effectiveness in identifying anomalous programs.
When it comes to identifying malicious System Calls inside the host operating system, the conventional system call pattern method is difficult and inefficient. It permits the identification of suspect system call patterns without having to look at particular applications or processes. Its efficacy is however constrained by the fact that system call patterns that were recognized as unusual once the training could occasionally occur as part of a typical execution scenario.
By saving processing and data gathering resources, methods that use the rate in System Calls for unexpected behavior detection can achieve respectable efficiency. These techniques might not always catch assaults nevertheless, especially if the attacker uses the same frequency in system call sequences but in a different order to trick the detection system. Additionally, the research on such systems [22] indicated that virtual machine monitor (VMM) layer detection is hypervisor‐dependent, rendering distributed solutions susceptible to client‐side IDS instance failure [14]. Additionally, system‐wide intrusion detection systems are less effective than program‐wide intrusion detection systems and cannot detect slow‐moving threats, where the probability of unusual system call sequence behavior indicating an intrusion is low. Despite the advances in intrusion detection in the cloud, there is still a need for effective and efficient solutions that can address the limitations of the existing approaches. Further research is necessary to address the research gaps and improve the efficacy of intrusion detection in cloud environments.


1.5 Conventional Detection Systems
Malware scanners [23] are tools that attempt to identify malicious executable files by comparing them to a known set of patterns. They typically search through each line of code in the file, looking for a unique signature represented as a hash code or string. Extracting these signatures is a challenging and time‐consuming process, and modern malware can evade scanners by changing their patterns dynamically. To overcome this, scanners are developing more sophisticated algorithms that use ML, such as analyzing machine instructions or API calls [7, 22]. For instance, systems that use machine instructions train classifiers using features derived from op‐codes. These systems may use op‐code sequences to extract features such as frequency, histogram, and others. By examining op‐codes, they typically label any potentially malicious behavior in a cloud application as benign. This may not accurately reflect reality, as the behavior could be legitimate malicious access to databases, root filesystems, or networks in a certain situation. To confirm whether the file is safe, the suspect file is temporarily monitored and isolated in a simulated environment, and marked as safe if its behavior appears reasonable based on established metrics.
Intrusion detection systems are used to prevent external attacks on an organization’s computer networks. They categorize malicious communications by monitoring incoming packets for irregularities at the entrance to a local area network [24]. However, these systems often presume that the trusted perimeter is secure and may not detect malicious activity from insiders [23]. They operate similarly to malware scanners by detecting known rules or patterns, with sophisticated systems using ML to detect more advanced network attacks. They rely on inspecting packet headers and, in some cases, packet contents.
From a ML perspective, signature‐based mechanisms classify malicious feature vectors by comparing the current feature vector with a labeled set that has already been recorded [25]. As a result, they are ineffective against 0‐day attacks. Also, behavior‐based mechanisms can be adapted, as they estimate the most recent feature vectors and learn from a provided dataset. There have been many studies in the literature that use ML methods in malicious behavior recognition systems, with most of them focusing on network communications intrusion detection systems [22, 26]. Feature vectors are extracted from various sources, for instance, user command patterns, log entries, information about lower‐layer systems, and CPU and memory use [24]. ML‐based detection systems often employ attributes such as API calls and machine commands [10]. These systems classify malware into categories such as viruses, worms, backdoors, and Trojan horses.
In the domain of malware analysis, techniques are divided into two types: signature‐based and behavior‐based [27]. Signature‐based techniques search for unique patterns in malicious files, such as distinct raw byte patterns or regular expressions. In contrast, during code execution, behavior‐based techniques get particular feature values through runtime actions and logs.


1.6 Classifying Executables by Payload Function
In this research, the focus is on the classification of malicious executables based on their payload functions, rather than on their detection. The goal is to determine if classification techniques can determine the type of malicious executable, such as whether it opens a backdoor, is sent in bulk, or is an executable virus. This aspect of the research is particularly beneficial for computer forensics experts. The first step in the process is the identification and cataloging of the characteristics of malicious executable payloads. A challenge encountered in this process is that many executables fit into multiple categories, making them multi‐class examples, which is a common problem in document classification and bioinformatics. For instance, an executable may both log keystrokes and open a backdoor, making it fall into both the keylogger and backdoor categories.
One solution to this issue is to combine compound classes with simple classes, such as backdoor + keylogger. This can be achieved by using one‐versus‐all classification, where all executables are categorized into groups based on their capabilities. For example, all backdoor‐capable executables regardless of any additional features, including keylogging, would be put inside the backdoor class, whereas every other executable would be put inside a non‐backdoor class.
The following stage is to develop a detector for something like the backdoor category, and thereafter carry out the same procedure for the other classes. The total prediction of the program may be determined by applying every detector and reporting every classifier’s prediction. For instance, if the backdoor or keylogger detectors both identify hits, the executable’s overall forecast would’ve been backdoor + keylogger.


1.7 Result and Discussion
It has been observed that the detection methods used may have simply developed the ability to recognize some obfuscation techniques, such as runtime compression, but as long as these techniques are linked to malicious executables, this does not provide a serious problem. Alternative data extraction techniques were also investigated. One concept was to create an audit of machine instructions and execute the malicious exe files in a “sandbox.” However, this strategy was abandoned owing to a number of drawbacks, including a lack of auditing tools, challenges managing a large number of interactive programs, and an inability to identify malicious activity at the conclusion of lengthy programs. Additionally, some dangerous programs have the ability to recognize when they are running inside a virtual machine (VM) and then either stop running or avoid running destructive code.
Our research has practical implications in two areas of commercial applications. The first is the development of a system for detecting malicious executables, similar to the MECS system. This system would require storage of a large set of both known malicious executables and benign executables in server software. The computation‐intensive task of creating classifiers from such algorithms for measuring information gain and assessing categorization techniques would need to be used, and the data would need to be processed sequentially, in parallel, or both. To create a prediction, the client program would just need to collect the top n‐grams out of an executable and utilize the classifier. Through the internet, the classifier might be remotely updated. It is vital for the server to test several techniques as well as for the client to handle any viable classifiers since the best‐performing technique may change with new training data. These methods, when combined with signature‐based methods, could provide a more effective way of detecting malicious executables than what is currently possible.
The second system is focused on serving computer forensic experts. Although it is uncertain if the statistical properties of an executable are predictive of its function, there is evidence that high detection rates can be achieved when predicting its function.
In today’s digital world, where files and information are exchanged over networks and the internet, network malware detection is of utmost importance. Using the network analysis program BroIDS [16], PE files may be extracted from incoming packets that are routed through the router and into the internal network. Then, the pertinent characteristics are extracted using the feature extraction module. Following the extraction of the features and representation of the file, the file may be passed toward the malware analysis engine, which already has the training learning algorithm stored in memory. If malware is found, a warning will be created and forwarded to the operator.


Table 1.2 Displaying malware families with the specific malware.




Malware family
Spyware
Adware
Cookies
Trapdoor
Trojan Horse
Sniffers
Spam
Botnet
Logic bomb
Worm
Virus  


Pattern
✓
✓
✓
✓
✓
✓
✓
✓
✓
✓
✓ 

Obfuscated
✓
✓
✓
✓
✓
✓
✓
✓
✓
✓
✓ 

Polymorphic
✓
✓
✓
✓
✓
✓
✓
✓
✓
✓
✓ 

Toolkit
✓
✓
✓
✓
✓
✓
✓
✓
✓
✓
✓ 

Network
✓
✓
✓
✓
✗
✓
✓
✓
✓
✗
✗ 

Remote execution through we
✓
✓
✓
✓
✓
✓
✓
✓
✗
✗
✗ 

PC
✗
✗
✗
✗
✗
✗
✗
✗
✓
✓
✓ 

Network
✓
✓
✓
✓
✓
✓
✓
✓
✓
✓
✓ 

Removable disks
✓
✓
✓
✓
✓
✓
✓
✓
✓
✓
✓ 

Internet downloads
✓
✓
✓
✓
✓
✓
✓
✓
✓
✓
✓ 

Breaching confidentiality
✓
✗
✓
✗
✓
✓
✗
✗
✗
✗
✗ 

Inconveniencing users
✗
✓
✗
✗
✗
✗
✓
✗
✗
✗
✗ 

Denying services
✗
✗
✗
✓
✗
✗
✓
✓
✓
✓
✓ 

Data corruption
✗
✗
✗
✓
✗
✗
✓
✓
✓
✗
✓   

MC detection techniques may be broadly categorized into two groups: abuse detection and anomaly detection. Misuse detection strategies concentrate on “maliciousness” and seek to recognize the traits and/or runtime behaviors of MC. Anomaly detection strategies, on the other hand, focus on “normalcy” and attempt to spot code traits and/or runtime behaviors that depart from what is thought to be normal, i.e., non‐malicious.
Table 1.2 displays a list of malware families and their specific types. This table provides an overview of different types of malware and the families they belong to. It helps to categorize and understand the different types of malware that exist and the potential threats they pose.


1.8 Conclusion
The rising threat of MC has led to an increasing demand for efficient and effective ways to detect and respond to it. In this research, we introduced a system that examines code statically and automatically to assess its maliciousness. This system, called the malicious executable classification system (MECS), extracts various features of code using ML methods, the packer information, the PE metadata, and the hash value to classify it. MECS is different from traditional signature‐based classification tools in that it relies on considerations instead of patterns to identify MC. The system also visualizes the code using a visualization method and inputs it into a CNN model, which allows for the classification of both PE and shell‐like files.
MECS can find undiscovered harmful executables in the wild by employing retrieval of information and text classification algorithms. After detection, computer forensics experts can further analyze the program’s functional characteristics, such as its ability to send mass emails, modify system files, or grant access. This may involve removing obfuscation, such as compression. However, this task can be challenging due to the fact that most malicious executables perform multiple functions, requiring multiple class labels for each training example. Despite its potential, MECS is only one stage of a more comprehensive system for identifying and categorizing malware. Integrating it with other techniques that search for well‐known signs can further enhance the security of computers. However, some existing anomaly detection techniques may have limitations, as they only take into account the behavior that was seen when the program is still learning, which is probably only a small part of all of its behaviors. This can lead to false positives and missed detections. Additionally, some antivirus techniques can be bypassed by malicious actors who change the PE Header attributes or add inconsequential strings to the printable strings feature.
In conclusion, the development and implementation of the MECS system offer a promising solution to the challenge of detecting and responding to MC. By automating the analysis process and incorporating various ML techniques, MECS can enhance the efficiency and accuracy of malware detection and classification. It provides a useful tool for computer forensics professionals in their ongoing efforts to protect computer systems from malicious actors. However, it is just one piece of the puzzle. While the MECS system can detect malicious executables, it still requires computer forensic experts to determine the program’s functional characteristics and remove any obfuscation such as compression. Additionally, MECS only considers a small portion of all the software’s possible behaviors, meaning that false positives can still occur. Moreover, the traditional antivirus techniques have limitations as well. For example, some malware writers can avoid detection by changing the PE Header attributes or adding inconsequential strings. Thus, a more comprehensive approach to detecting and classifying malware is needed, one that combines the strengths of various methods and takes into account the evolving nature of MC. To that end, a strategic approach that employs a combination of methods, such as signature‐based detection, runtime monitoring, and behavior‐based analysis, would likely be more effective in detecting and classifying malicious executables. By combining these methods, computer forensic professionals can have a better understanding of the program’s behavior and can determine the true nature of the code, even if it is obfuscated.
In conclusion, while the MECS system is a valuable tool for computer forensic professionals, it should be seen as just one component of a larger, comprehensive approach to detecting and classifying MC. By combining the strengths of various methods, computer forensic professionals can better protect computer systems and stay ahead of the ever‐evolving threat of malicious actors.


References

1 Schultz, M., Eskin, E., Zadok, F., and Stolfo, S. (2001). Data mining methods for detection of new malicious executables. In: Proceedings of the 2001 IEEE Symposium on Security and Privacy, Oakland, CA, USA, 38–
