# Security Chapter Extract
Book: Rufus Stewart - Bash Scripting_ Everything you need to know about Bash , 2nd Edition (2020, Independently published) - libgen.li
Chapter: 64 - bash can also handle most sh text scripts without modification.
Security Relevance Score: 6
Word Count: 6532
Extracted: 2025-06-13 23:40:44

---

bash can also handle most sh text scripts without modification. 
   
 The Bash Initiative, like the rest of GNU's projects, was originally launched to preserve the freedom to use, study, copy, modify, and republish programs, and to promote and disseminate those rights, as these are the catalysts for creativity. In any other coincidence. 
   
   
 The advantages are found only in bash 
   
 Invocation 
   
 There are many multi-character options that you can use, as well as single-character options that can be set using the set command that is located by default in the shell. In this documentation we will show some other popular options, and you can find the complete list in the info guide, in Bash features and then Invoking Bash. 
 Startup files in Bash 
   
 Startup files are scripts that Bash reads and executes at startup. The following explanation describes the different ways to start shells, and the startup files that are read accordingly. 
 Invoke as an interactive login shell, or with login-- 
   
 Interactivity here means that you can enter commands, and shell does not work because of the activation of the text code. "Login shell" means that you enter the shell only after authenticating with the system, often by entering your username and password. 
   
 Read files: 
   
     etc / profile / 
     bash_profile./~, bash_login./~, or profile./~: Reads the first readable file. 
     bash_logout./~ when you log out. 
   
 Error messages are printed if configuration files exist but cannot be read, and if a file does not exist, bash looks for the next file. 
 Call as an interactive shell without logging in 
   
 A non-login shell means that you don't have to authenticate with the system, as if you open Terminal by clicking an icon or item in a list, it's a non-login shell. 
   
 Read files: 
   
     bashrc./~ 
   
 This file is usually referenced in bash_profile / ~: 
   
 if [-f ~ / .bashrc]; then. ~ / .bashrc; fi 
   
 See conditional structures in Bash for more if structure 
 The call is interactive 
   
 All text codes use non-interactive shells, and are programmed to perform specific tasks and cannot be programmed to perform other tasks otherwise. 
   
 Read files: 
   
     Selected by BASH_ENV 
   
 PATH is not used in this file for searching. If you want to use it, please indicate the full path and file name. 
 Call by order from within sh 
   
 Bash tries to behave like the old sh software written by Steve Bourne, while trying to comply with POSIX standards. 
   
 Read files: 
   
     etc / profile / 
     profile./~ 
   
 The ENV variable can refer to additional startup information. 
 POSIX mode 
 This option is activated using the set command: 
   
 set -o posix 
   
 Or by invoking the bash program with the - posix option, bash will then try to comply with POSIX standards for shells. Also, initializing the POSIXLY_CORRECT variable produces the same result. 
   
 Read files: 
   
     Specified by the ENV variable. 
   
 Remote paging 
   
 Files read when bash starts with the rshd command: 
   
     bashrc /. ~ 
   
     Avoid using r-tools 
   
     Be aware of the dangers of using unsafe tools such as rlogin, telnet, rsh, and rcp, as they transmit sensitive data over the network without encryption. If you need tools to remotely administer the system, transfer files, etc., use a Secure SHell Protocol (ssh) protocol, which is available for free from http://www.openssh.org. You will also find different programs for non-Unix-like systems, see your local software mirror. 
   
 The call when the UID is not identical to the EUID 
   
 No files are read at startup in this case. 
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
 Interactive shells 
 What is interactive chance? 
   
 An interactive shell reads and writes at a user's terminal as follows: 
   
 Input and outputs are connected to the terminal, and interactive bash behavior starts when the bash command is called without adding any non-option arguments, except if the option is a string that is read, or when the shell is triggered to read a standard input, This allows the initialization of positional parameters, see Bash environment. 
 Is this coincidence interactive? 
 To find out if a shell is interactive, look at the content of the special parameter -, if it has an "i", the shell is interactive: 
   
 hsoub: ~> echo $ - 
   
 himBH 
   
 In the non-reactive shell, the PS1 inductor is not initialized, ie it goes back to zero. 
 Interactive shell behavior 
   
     Bash reads startup files. 
     Function control is enabled by default. 
     Inductors are configured, and the PS2 environment variable is activated for multi-line commands, usually set to <, which is also what you get when the shell assumes that you entered an incomplete command, such as forgetting quotes or one or more items that cannot be neglected in a command. etc. 
     By default, commands are read from the command line using readline. 
     Bash interprets the ignoreeof option when you receive End Of File (or EOF for short) instead of exiting directly. 
     Command history and log expansion are enabled by default, and the log is saved in a file referred to by HISTFILE when the shell closes. By default, HISTFILE refers to bash_history./~. 
     Alias ​​expansion is automatically activated. 
     The SIGTERM signal is ignored in the absence of traps. 
     In the absence of traps, SIGINT is captured and handled, so pressing Ctrl + C, for example, won't get you out of the interactive shell you're in. 
     SIGHUP signals can be set to be sent to all functions at exit, with the huponexit option. 
     The commands are executed as soon as they are read. 
     Periodically inspect mail bash. 
     Bash can be set to close when you encounter unreferenced variables. This behavior is disabled in interactive mode. 
     When shell commands encounter redirect errors, they will not cause the shell to close or exit. 
     Repeated errors for special built-in commands while using them in POSIX mode do not cause an accident. See the commands included in the shell for more on the included commands. 
     Failure to exec will not cause the exit of chance. 
     Syntactic errors of the Parser will not cause the shell to close. 
     Simple check of arguments cd is activated by default. 
     Auto-logoff after a period specified in the TMOUT variable has elapsed, is also enabled. 
   
 For more explanation, see Variables in Bash, More Bash options, Capture signals in Bash for more signals, and Bash expansions that discuss the different expansions that occur when you enter an order. 
 Conditional Expressions 
   
 Conditional expressions are used via the combined [] command, the included commands and test, and the built-in commands. Expressions can be mono or binary. 
   
 There are also text operators (string operators) and numeric comparison operators. These two types are binary operators, requiring two elements to perform the operation on. 
   
 If the FILE argument of an original is dev / fd / N /, the file descriptor N is selected, but if it is in one of those dev / stdin / or dev / stdout / or dev / stderr /, the file descriptor 0, 1 , Or 2 respectively. 
   
 See the detail description for conditional structures for more conditional expressions, and see redirection and file descriptions for more file descriptors. 
 Arithmetic expressions in shell Shell Arithmetic Expressions 
   
 Coincidence allows arithmetic expressions to be evaluated as one of the expansions of the shell, or by using the let command, and evaluated as fixed width integers without overflow, except that dividing by 0 is captured and notified as an error. The rules of the C programming language on factors, their precedence and their associativity apply to their counterparts here, see bash environment. 
 Alternative commands 
   
 Alternative commands allow a word to be replaced by a text of several words when used as the first word of a simple command. The shell keeps a list of alternative commands that can be created or canceled using alias and unalias. 
   
 Bash reads at least a full line of inputs before executing any commands on that line. Alternative commands are also expanded when the command is read and not executed, so if the characters of one of the alternate commands on a line match the letters of another command in the same line, the command that the alternate command holds is only executed when the next line of input is read. 
   
 Similarly, alternative commands are expanded when a function description is read, not when executed, because the function description itself is a compound command, so alternative commands in a function are only available after the function is executed. We will discuss alternative orders in detail in the alternative orders. 
   
   
   
   
   
   
   
   
   
   
   
   
   
 Chapter One 
 Create and run the Bash program 
   
 Writing and naming 
   
 If you have a series of commands that you execute frequently and want to shorten the execution time or execute them automatically, you can put them in an empty file written in a particular format and read by chance as a program that you execute when you call it by typing the name of the file it contains, and these programs are called shell programs Scripts). 
   
 These programs can be used to automate tasks using the cron tool or in boot and shutdown procedures in Unix systems, where daemons and services are defined in init scripts. 
   
 To create a shell program, open an empty file in your favorite text editor.It doesn't matter what type of editor you're using.Most of them are doing the job we want now, writing a Bash shell program.Use VIM if you like, emacs, gedit, dtpad, etc. 
 But what might make you use a sophisticated editor like VIM or emacs, is that you can configure them to recognize the texts you write and highlight them in different colors - including texts and shell commands that we will write - and that reduces the mistakes that beginners usually make, such as omitting closing parentheses () Or forget about semicolons; . 
   
     Highlight texts in VIM 
   
     Use one of the following three commands to highlight Text Highlighting in the VIM editor: 
   
     syntax enable: or sy enable: or syn enable: 
   
     It is useful to add that setting to a vimrc file. In order to install it by default. 
   
 Place the Unix commands in the file you created as if you were going to type those commands on the command line (see Execute Commands in Bash). These commands can be shell functions, embedded commands, Unix commands, etc. Now give that file a name that describes the tasks it executes and make sure that the name does not conflict with pre-existing commands.To ensure this, the names of shell programs often end in .sh, but this does not prevent the presence of other text codes in the system with the same name you choose, search in the system for files Or text codes with the same name using file and program search commands like which or whereis: 
   
 which -a script_name 
   
 whereis script_name 
   
 locate script_name 
   
 script1.sh 
   
 In this example, we will use the echo command to print on-screen notifications that tell the user what will happen before each task is executed. It is important to tell the user what is happening to avoid panic because the user feels that the program is "doing nothing". See detailed user notification in writing interactive Bash programs. 
 The script1.sh file 
   
 #! / bin / bash 
   
 clear 
   
 echo "The script starts now." 
   
 echo "Hi, $ USER!" 
 echo 
   
 echo "I will now fetch you a list of conntected users:" 
 echo 
 w 
 echo 
   
 echo "I'm setting two variables now." 
 COLOR = "black" 
 VALUE = "9" 
 echo "This is a string: $ COLOR" 
 echo "And this is a number: $ VALUE" 
 echo 
   
 echo "I'm giving you back your prompt now." 
 echo 
   
 You may have to train yourself to write shell programs by typing this example into the image yourself.It is also useful to create a / ~ scripts folder to save your text codes in, then add that folder to the contents of the PATH variable as follows: 
   
 export PATH = "$ PATH: ~ / scripts" 
   
 Use an editor that supports text highlighting for shell commands if you are a beginner.This feature is supported in editors such as VIM - gvim - (x) emacs- kwrite and other editors, so make sure your editor supports Text Highlighting by looking at the Document Highlighting feature. That editor. 
   
     Various inductors 
   
     The inductors used in this explanation may differ to simulate real-life situations rather than using the $ inductor, which is frequently used in explanations. However, the root user prompt will remain constant in the annotation, and will be #. 
   
 Program implementation 
 The program is executable for those entitled to it, that is, to whom the program owner grants permission to execute it, make sure that you get the permissions you want while adjusting the permissions of the program, and then you can run the program as you run any command in chance: 
   
 wiki @ hsoub: ~ / scripts $ chmod u + x script1.sh 
   
 wiki @ hsoub: ~ / scripts $ ls -l script1.sh 
 -rwxrwxr-x 1 wiki wiki 331 Jul 31 03:12 script1.sh 
   
 wiki @ hsoub: ~ / scripts $ script1.sh 
 The script starts now. 
 Hi, wiki! 
   
 I will now fetch you a list of connected users: 
   
  03:12:48 up 3:42, 1 user, load average: 1.33, 1.51, 1.67 
 USER TTY FROM LOGIN @ IDLE JCPU PCPU WHAT 
 wiki tty7: 0 23:30 3: 42m 12:51 0.63s / usr / lib / gnome-session / gnome 
   
 I'm setting two variables now. 
 This is a string: black 
 And this is a number: 9 
   
 I'm giving you back your prompt now. 
   
 wiki @ hsoub: ~ / scripts $ echo $ COLOR 
   
 wiki @ hsoub: ~ / scripts $ echo $ VALUE 
   
 wiki @ hsoub: ~ / scripts $ 
   
 This is the most common way to implement a shell script, preferably in a subshell. The variables, functions, and aliases that were created in that sub shell will be defined for this session from Bash for that sub shell only. As it was when that shell closed and control of the mother coincided again, everything is cleaned and all changes made by the program to chance are canceled. If you do not put the scripts folder in the PATH variable and it is not the current folder. You can also execute the program with this command - script_name indicates the name of your program -: 
   
 ./script_name.sh 
   
 The program may be implemented in a particular shell, although we do this if we want to obtain certain behavior, such as checking if the program is working in another shell or printing traces for debugging: 
   
 rbash script_name.sh 
   
 sh script_name.sh 
   
 bash -x script_name.sh 
   
 The shell specified in any of the above commands will act as a sub-shell of your current shell and execute the program. You may do this when you want the program to run with specific options or under circumstances not specified in it. If you want to execute the program within the same shell as you are, you must first use the source command: 
   
 source script_name.sh 
   
     source =. 
   
     The source command included in the Bash shell is synonymous with a command. In Bourne coincidence. 
   
 Shell does not need any execute permissions in that case, and commands are executed in the current context of the shell, so any changes that occur to your current environment will be visible and remaining after the program is finished executing: 
   
 wiki @ hsoub: ~ / scripts $ source script1.sh 
 wiki @ hsoub: ~ / scripts $ echo $ COLOR 
 black 
   
 wiki @ hsoub: ~ / scripts $ echo $ VALUE 
 9 
   
 wiki @ hsoub: ~ / scripts $ 
   
   
   
   
   
   
 In which coincidence will the program work? 
   
 You must specify the shell that will execute the program if you want to execute it in a sub-shell. The shell in which you wrote the program may not be the default shell of your system, so your program commands may produce errors when executed in the wrong shell. 
 The first line in the program specifies the type of shell, and the first two characters in that line must be # !, followed by the path of the shell that will execute the program. Also, do not start your program with a blank line as blank lines are read as lines as well, and all programs in this explanation will start with the following line: 
   
 #! / bin / bash 
   
 The preceding line indicates that the Bash is present in the bin /. 
   
   
 Add comments 
   
 Be aware that your software may be seen and read by others. 
   
 The comments make it easier for you to modify the program and go back to what you wrote again. What's new if you haven't recorded comments about what you did, how you did it, and why you chose those orders or modifications? 
 Copy the script1.sh file in the example of creating and running a Bash program named commented-script1.sh, and we will modify its content so that the comments describe what the commands do. Be aware that anything encountered by chance after the # sign in any line is ignored, and only appears when you open the source file. For the program: 
   
 #! / bin / bash 
 # This program scans peripheral content, greets the user and gives information about users 
 # Callers at program execution time. The two variables used as examples are formatted and presented 
   
 clear # Clear terminal contents immediately 
   
 echo "The script starts now." 
   
 echo "Hi, $ USER!" # The dollar sign is used to fetch the content of a variable 
 echo 
   
 echo "I will now fetch you a list of connected users:" 
 echo 
 w # Show who is signed in and what to do 
 echo 
   
 echo "I'm setting two variables now." 
 COLOR = "black" # Set a local variable to the shell 
 VALUE = "9" # Set a local variable to the shell 
 echo "This is a string: $ COLOR" # Display the variable content 
 echo "And this is a number: $ VALUE" # View the variable content 
 echo 
   
 echo "I'm giving you back your prompt now." 
 echo 
   
 The first lines in shell programs are usually comments that explain the nature of the tasks the program executes, and then each piece of code is accompanied by one or more comments to illustrate. You will find an example in the init.d folder of your system, as init codes are well documented because they are readable and modified by any Linux user. 
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
 Chapter II 
 Bash environment 
   
 The Bash environment can be set up at the system level as a whole or for each user individually, and various configuration files are used to control shell behavior. These files contain shell options, variable settings, function definitions, and other Bash shell builders that make it easier for us to create a comfortable and fulfilling work environment. . 
   
 You can choose names for variables as you like, with the exception of reserved names for Bourne, Bash, and special parameters. Bash uses a quoting system to exclude special meanings from one or more characters if no special processing is needed, since many characters have two or more meanings depending on the environment. 
   
 Bash also uses multiple methods to extend command-line entries in order to determine which commands to execute. 
   
   
   
   
   
   
   
   
   
   
 Shell initialization files 
   
 System-wide Configuration files 
 Etc / profile / 
   
 Bash reads the instructions in etc / profile / if invoked interactively via the login option - or if called as sh, these instructions usually set the PATH - USER - MAIL - HOSTNAME - HISTSIZE variables, which are shell variables. 
   
 The umask value in etc / profile / is also set on some systems; in others this file contains pointers to other configuration files such as: 
   
     / Etc / inputrc file, which is a system-wide configuration file for the readline command, where you can configure the bell style for the command line. 
     The / etc / profile.d / folder, which contains files that set the behavior of specific programs at the system level. 
   
 All settings you want to apply to all users in your system must be present in that -etc / profile / - file, and may look similar to the following: 
   
 # / etc / profile 
   
 # System wide environment and startup programs, for login setup 
   
 PATH = $ PATH: / usr / X11R6 / bin 
   
 # No core files by default 
 ulimit -S -c 0> / dev / null 2> & 1 
   
 USER = "` id -un` " 
 LOGNAME = $ USER 
 MAIL = "/ var / spool / mail / $ USER" 
   
 HOSTNAME = `/ bin / hostname` 
 HISTSIZE = 1000 
   
 # Keyboard, bell, display style: the readline config file: 
 if [-z "$ INPUTRC" -a! -f "$ HOME / .inputrc"]; then 
     INPUTRC = / etc / inputrc 
 fi 
   
 PS1 = "\ u @ \ h \ W" 
   
 export PATH USER LOGNAME MAIL HOSTNAME HISTSIZE INPUTRC PS1 
   
 # Source initialization files for specific programs (ls, vim, less, ...) 
 for i in /etc/profile.d/*.sh; do 
     if [-r "$ i"]; then 
         . $ i 
     fi 
 done 
   
 # Settings for program initialization 
 source /etc/java.conf 
 export NPX_PLUGIN_PATH = "$ JRE_HOME / plugin / ns4plugin /: / usr / lib / netscape / plugins" 
   
 PAGER = "/ usr / bin / less" 
   
 unset i 
   
 This configuration file sets some basic shell variables in addition to some variables required by any user running Java or any Java application in their browser. See variables in Bash. 
   
 See conditional structures in Bash for more if if conditionals used in the previous example, and repeating tasks in Bash that discuss iterative loops such as for. 
   
 The Bash source contains sample profile files for general or individual use, and those files - the file in the example above - undergo several changes before they are used in your environment. 
 File etc / bashrc / 
   
 It is probably best to put Bash configuration files in this file if you are working on systems with different types of shells, for example other shells - Bourne shell - read the etc / profile / file. 
   
 Errors generated by shells that do not understand the syntax of the Bash shell can be avoided by separating configuration files for the different types of shells. Initialize shell initialization at login. 
   
 You may find that the / etc / profile file in your system contains only the shell environment and program startup settings, while / etc / bashrc / contains system-wide definitions of shell functions and their alternative commands. The / etc / bashrc file may also be referenced within the / etc / profile file or in the user's shell configuration files. 
 The source contains samples of bashrc files, and you'll find a copy in usr / share / doc / bash-2.05b / startup-files /. Here's part of what is in the bashrc file that comes with the Bash documentation: 
   
 alias ll = 'ls -l' 
 alias dir = 'ls -ba' 
 alias c = 'clear' 
 alias ls = 'ls --color' 
   
 alias mroe = 'more' 
 alias pdw = 'pwd' 
 alias sl = 'ls --color' 
   
 pskill () 
 { 
     local pid 
   
     pid = $ (ps -ax | grep $ 1 | grep -v grep | gawk '{print $ 1}') 
     echo -n "killing $ 1 (process $ pid) ..." 
     kill -9 $ pid 
     echo "slaughtered." 
 } 
   
 It contains useful aliases as well as generic aliases, as they ensure that the command you enter is executed even if you misspell it, see Creating and Deleting Alternate Orders. This file also contains the pskill function, see functions in Bash for more explanation of functions. 
 User settings files 
   
     Can't find those files on my computer !? 
   
     You may not find these files in your home folder. 
   
 File bash_profile./~ 
 This file is best used if you set up individual user environments. Users here may add additional options or change the default settings: 
   
 wiki ~> cat .bash_profile 
 ######################################################### ############### 
 # # 
 # .bash_profile file # 
 # # 
 # Executed from the bash shell when you log in. # 
 # # 
 ######################################################### ############### 
   
 source ~ / .bashrc 
 source ~ / .bash_login 
 case "$ OS" in 
   IRIX) 
     stty sane dec 
     stty erase 
     ;; 
 # SunOS) 
 # stty erase 
 # ;; 
   *) 
     stty sane 
     ;; 
 Esac 
   
 This user, with the above settings, sets the backspace button to sign in on different operating systems, in addition to the bashrc files. And bash_login. User-specific information has been read. 
 File bash_login./~ 
 This file contains specific settings that are usually implemented only when you log on to the system. In the following example, we will use it to set the umask value and display a list of connected users upon logging in. This user will also see a calendar in the current month: 
   
 ######################################################### ##################### 
 # # 
 # Bash_login file # 
 # # 
 # commands to perform from the bash shell at login time # 
 # (sourced from .bash_profile) # 
 # # 
 ######################################################### ##################### 
 # file protection 
 umask 002 # all to me, read to group and others 
 # miscellaneous 
 w 
 cal `date +` `% m ''` `date + '% Y' '' 
   
 This file will be read in the absence of bash_profile./~. 
 Profile./~ 
   
 The profile./~ is read in the absence of bash_profile./~ and bash_login./~, which may contain the same settings that other shells can access. Note that these shells may not understand the linguistic structure of the Bash shell. 
 File bashrc./~ 
   
 It is now common to see a non-login shell because the user logs in from the graphical interfaces, and the user does not enter their data in that case - username and password - the authentication process does not take place, and Bash searches for the bashrc./~ file, so that file is Mechanism in the read files at logon, which means you don't need to enter the same settings in multiple files. 
 In the following example of a bashrc file. For a user, some alternative commands have been specified and variables set for specific programs, after reading the / etc / bashrc file: 
   
 wiki ~> cat .bashrc 
 # /home/franky/.bashrc 
   
 # Source global definitions 
 if [-f / etc / bashrc]; then 
        . / etc / bashrc 
   
 fi 
   
 # shell options 
   
 set -o noclobber 
   
 # my shell variables 
   
 export PS1 = "\ [\ 033 [1; 44m \] \ u \ w \ [\ 033 [0m \]" 
 export PATH = "$ PATH: ~ / bin: ~ / scripts" 
   
 # my aliases 
   
 alias cdrecord = 'cdrecord -dev 0,0,0 -speed = 8' 
 alias ss = 'ssh octarine' 
 alias ll = 'ls -la' 
   
 # mozilla fix 
   
 MOZILLA_FIVE_HOME = / usr / lib / mozilla 
 LD_LIBRARY_PATH = / usr / lib / mozilla: / usr / lib / mozilla / plugins 
 MOZ_DIST_BIN = / usr / lib / mozilla 
 MOZ_PROGRAM = / usr / lib / mozilla / mozilla-bin 
 export MOZILLA_FIVE_HOME LD_LIBRARY_PATH MOZ_DIST_BIN MOZ_PROGRAM 
   
 # font fix 
 alias xt = 'xterm -bg black -fg white &' 
   
 # BitchX settings 
 export IRCNAME = "frnk" 
   
 # THE END 
 wiki ~> 
   
 You'll find more examples in the Bash package, and remember that existing file templates may need modifications before you can use them in order to work in your environment. 
 File bash_logout./~ 
 This file contains specific instructions for logging off. In the following example, it is a single statement "clear" to leave the window empty after closing, and is useful in remote connections: 
   
 wiki ~> cat .bash_logout 
 ######################################################### ##################### 
 # # 
 # Bash_logout file # 
 # # 
 # commands to perform from the bash shell at logout time # 
 # # 
 ######################################################### ##################### 
 clear 
 wiki ~> 
   
 Changing shell settings files 
   
 The user must reconnect to the system when modifying any of the files mentioned above in order to activate these modifications, or as another method that uses the source command on the file he edited. Modifications are applied to the current shell session when interpreting Bash in this way: 
   
 Figure 3.1: Different inductors for each user. 
  
 Most Bash programs are implemented in special environments where sub-processes do not acquire variables unless the parent shell makes them a source (sourcing). Making a file with shell commands a source is one way to apply modifications to your environment and adjust variables in the current shell. 
   
 This example also explains the use of different inductors for each user, and in our case the # sign means that you are now in the root user stage, you should be wary of every command you enter as the device will not hesitate to execute it even if it means destroying files from the system core, Unlike the $ prompt of the average user who has limited authority to execute the commands he or she enters. 
   
 Note that the source resourcefile is the same as the resourcefile. . 
 If you suspect these many settings and see settings you don't know where they originate, use the echo command just as you do to refine Bash programs (see Refine parts of Bash programs). For example, you can add a line like this: 
   
 echo "Now executing .bash_profile .." 
   
 or 
   
 echo "Now setting PS1 in .bashrc:" 
 export PS1 = "[some value]" 
 echo "PS1 is now set to $ PS1" 
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
 Variables in Bash 
   
 Types of variables 
   
 Shell variables are capitalized, and Bash maintains a list of two variables: 
   
 Global Variables 
 You will find general variables or environment variables in all shells, and env or printenv commands can be used to display environment variables. These programs come in the sh-utils package. Here's an example of a printenv command output: 
   
 wiki ~> printenv 
 CC = gcc 
 CDPATH = .: ~: / usr / local: / usr: / 
 CFLAGS = -O2 -fomit-frame-pointer 
 COLORTERM = gnome-terminal 
 CXXFLAGS = -O2 -fomit-frame-pointer 
 DISPLAY =: 0 
 DOMAIN = hq.garrels.be 
 e = 
 TOR = vi 
 FCEDIT = vi 
 FIGNORE = .o: ~ 
 G_BROKEN_FILENAMES = 1 
 GDK_USE_XFT = 1 
 GDMSESSION = Default 
 GNOME_DESKTOP_SESSION_ID = Default 
 GTK_RC_FILES = / etc / gtk / gtkrc: /nethome/wiki/.gtkrc-1.2-gnome2 
 GWMCOLOR = darkgreen 
 GWMTERM = xterm 
 HISTFILESIZE = 5000 
 history_control = ignoredups 
 HISTSIZE = 2000 
 HOME = / nethome / wiki 
 HOSTNAME = hsoub.hq.garrels.be 
 INPUTRC = / etc / inputrc 
 IRCNAME = wiki 
 JAVA_HOME = / usr / java / j2sdk1.4.0 
 LANG = en_US 
 LDFLAGS = -s 
 LD_LIBRARY_PATH = / usr / lib / mozilla: / usr / lib / mozilla / plugins 
 LESSCHARSET = latin1 
 LESS = -edfMQ 
 LESSOPEN = | /usr/bin/lesspipe.sh% s 
 LEX = flex 
 LOCAL_MACHINE = hsoub 
 LOGNAME = wiki 
 LS_COLORS = no = 00: fi = 00: di = 01; 34: ln = 01; 36: pi = 40; 33: so = 01; 35: bd = 40; 33; 01: cd = 40; 33; 01: or = 01, 05,37,41: mi = 01, 05,37,41: ex = 01,32: *. cmd = 01,32: *. exe = 01,32: *. com = 01,32: * .btm = 01,32: *. bat = 01,32: *. sh = 01,32: *. csh = 01,32: *. tar = 01,31: *. tgz = 01; 31: *. arj = 01,31: *. taz = 01,31: *. lzh = 01,31: *. zip = 01,31: *. z = 01,31: *. Z = 01,31: *. gz = 01,31: *. Bz2 = 01; 31: *. Bz = 01,31: *. Tz = 01,31: *. Rpm = 01; 31: *. Cpio = 01; 31: *. Jpg = 01; 35: *. Gif = 01; 35: *. Bmp = 01; 35: *. Xbm = 01,35: *. Xpm = 01; 35: *. Png = 01; 35: *. Tif = 01; 35: 
 MACHINES = hsoub 
 MAILCHECK = 60 
 MAIL = / var / mail / wiki 
 MANPATH = / usr / man: / usr / share / man /: / usr / local / man: / usr / X11R6 / man 
 MEAN_MACHINES = hsoub 
 MOZ_DIST_BIN = / usr / lib / mozilla 
 MOZILLA_FIVE_HOME = / usr / lib / mozilla 
 MOZ_PROGRAM = / usr / lib / mozilla / mozilla-bin 
 MTOOLS_FAT_COMPATIBILITY = 1 
 MYMALLOC = 0 
 NNTPPORT = 119 
 NNTPSERVER = news 
 NPX_PLUGIN_PATH = / plugin / ns4plugin /: / usr / lib / netscape / plugins 
 OLDPWD = / nethome / wiki 
 OS = Linux 
 PAGER = less 
 PATH = / nethome / wiki / bin.Linux: / nethome / wiki / bin: / usr / local / bin: / usr / local / sbin: / usr / X11R6 / bin: / usr / bin: / usr / sbin: / bin: / sbin :. 
 PS1 = \ [\ 033 [1; 44m \] wiki is in \ w \ [\ 033 [0m \] 
 PS2 = More input> 
 PWD = / nethome / wiki 
 SESSION_MANAGER = local / hsoub.hq.garrels.be: /tmp/.ICE-unix/22106 
 SHELL = / bin / bash 
 SHELL_LOGIN = - login 
 SHLVL = 2 
 SSH_AGENT_PID = 22161 
 SSH_ASKPASS = / usr / libexec / openssh / gnome-ssh-askpass 
 SSH_AUTH_SOCK = / tmp / ssh-XXmhQ4fC / agent.22106 
 START_WM = twm 
 TERM = xterm 
 TYPE = type 
 USERNAME = wiki 
 USER = wiki 
 _ = / usr / bin / printenv 
 VISUAL = vi 
 WINDOWID = 20971661 
 XAPPLRESDIR = / nethome / wiki / app-defaults 
 XAUTHORITY = / nethome / wiki / .Xauthority 
 XENVIRONMENT = / nethome / wiki / .Xdefaults 
 XFILESEARCHPATH = / usr / X11R6 / lib / X11 /% L /% T /% N% C% S: / usr / X11R6 / lib / X11 /% l /% T /% N% C% S: / usr / X11R6 / lib / X11 /% T /% N% C% S: / usr / X11R6 / lib / X11 /% L /% T /% N% S: / usr / X11R6 / lib / X11 /% l /% T / % N% S: / usr / X11R6 / lib / X11 /% T /% N% S 
 XKEYSYMDB = / usr / X11R6 / lib / X11 / XKeysymDB 
 XMODIFIERS = @ im = none 
 XTERMID = 
 XWINHOME = / usr / X11R6 
 X = X11R6 
 YACC = bison -y 
   
 Local Variables 
   
 Local variables will only be found in the current shell, and the set command - without options - can be used to display a list of all functions and variables, including environment variables, and output is categorized according to the current position and is also presented in a reusable format. 
 Here's an example of a diff file created from comparing the outputs of the printenv and set commands, excluding functions that can also be displayed using the set command: 
   
 wiki ~> diff set.sorted printenv.sorted | grep "<" | awk '{print $ 2}' 
 BASE = / nethome / wiki / .Shell / hq.garrels.be / hsoub.aliases 
 BASH = / bin / bash 
 BASH_VERSINFO = ([0] = "2" 
 BASH_VERSION = '2.05b.0 (1) -release' 
 COLUMNS = 80 
 DIRSTACK = () 
 DO_FORTUNE = 
 EUID = 504 
 GROUPS = () 
 HERE = / home / wiki 
 HISTFILE = / nethome / wiki / .bash_history 
 HOSTTYPE = i686 
 IFS = $ ' 
 LINES = 24 
 MACHTYPE = i686-pc-linux-gnu 
 OPTERR = 1 
 OPTIND = 1 
 OSTYPE = linux-gnu 
 PIPESTATUS = ([0] = "0") 
 PPID = 10099 
 PS4 = '+ 
 PWD_REAL = 'pwd 
 SHELLOPTS = braceexpand: emacs: hashall: histexpand: history: interactive-comments: monitor 
 THERE = / home / wiki 
 UID = 504 
   
   
 Classify variables based on their content 
   
 Variables can be categorized according to the type of content the variable holds, and accordingly the variables are divided into four types: 
   
     Text variables. 
     Numerical variables. 
     Static variables. 
     Matrix Variables. 
   
 You'll find more explanation about these types in more about variables in Bash, but now we'll work with numerical and textual values ​​for our variables. 
   
 Create variables 
 Variable names are case-sensitive, and the variable is capitalized by default, but local variables can be given lowercase names.In any case, you have the freedom to use the names you want or put small and large letters within the name of a single variable. Variables can also contain numbers provided that the variable name does not begin with a number: 
   
 prompt> export 1number = 1 
 bash: export: `1number = 1 ': not a valid identifier 
   
 Use the following code to set the value of a variable in the shell: 
   
 VARNAME = "value" 
   
 Be careful, however, do not put spaces around the quotation marks as this will cause errors, so it's a good idea to usually acquire text content quotes when you assign values ​​to variables, as this will reduce the likelihood of an error. Here are some examples of using case, numbers, and spaces: 
   
 wiki ~> MYVAR1 = "2" 
   
 wiki ~> echo $ MYVAR1 
 2 
   
 wiki ~> first_name = "Wiki" 
   
 wiki ~> echo $ first_name 
 Wiki 
   
 wiki ~> full_name = "Wiki Hsoub" 
   
 wiki ~> echo $ full_name 
 Wiki Hsoub 
   
 wiki ~> MYVAR-2 = "2" 
 bash: MYVAR-2 = 2: command not found 
   
 wiki ~> MYVAR1 = "2" 
 bash: MYVAR1: command not found 
   
 wiki ~> MYVAR1 = "2" 
 bash: 2: command not found 
   
 wiki ~> unset MYVAR1 first_name full_name 
   
 wiki ~> echo $ MYVAR1 $ first_name $ full_name 
 <- no output -> 
   
 wiki ~> 
   
 Export variables 
   
 The variable that is generated as seen in the example above is only available in the current shell, it is a local variable, and the sub-processes of the current shell will not recognize this variable. 
 In order to pass the variables to the sub-shell, we must export them using the export command first. The variables that are exported are referred to as environment variables. 
   
 export VARNAME = "value" 
   
 The sub-shell can modify the variables you have gained from the parent shell, but these changes will not affect the parent shell. Here's an example that explains: 
   
 wiki ~> full_name = "Wiki Hsoub" 
   
 wiki ~> bash 
   
 wiki ~> echo $ full_name 
 wiki ~> exit 
   
 wiki ~> export full_name 
   
 wiki ~> bash 
   
 wiki ~> echo $ full_name 
 Wiki Hsoub 
   
 wiki ~> export full_name = "Osama H. ​​Damarany" 
   
 wiki ~> echo $ full_name 
 Osama H. ​​Damarany 
   
 wiki ~> exit 
   
 wiki ~> echo $ full_name 
 Wiki Hsoub 
   
 wiki ~> 
   
 In the example above, we have the full_name variable with a value of Wiki Hsoub, and when we try to read that value in a sub-shell, we get a null answer (the echo command shows a -null string- value). 
   
 Now we get out of the sub shell and export the full_name variable in the parent shell, then open a new sub shell and ask for the value of the full_name variable again, this time we get its value (Wiki Hsoub), because the variable is visible to the sub shell after it is exported. 
   
 We can change the value of the variable inside the sub-shell as you see in the example to (Osama H. ​​Damarany), but when we get out of that shell and go back to the mother shell to ask for the value of the variable itself, we get the first value (Wiki Hsoub), did not affect its value in the mother shell By changing it inside a sub-shell. 
   
   
   
   
   
   
 The difference between * $ and @ $ 
   
     Using * $ can cause bugs or vulnerabilities in your programs, and almost every time a programmer uses * $, it means @ $. 
   
 Topical operators are words that follow the name of the shell program. These parameters are placed in the variables $ 1, $ 2, $ 3, and so on. The variables are added to an internal array as long as needed. 
   
 #! / bin / bash 
   
 # positional.sh 
 # This script reads 3 positional parameters and prints them out. 
   
 POSPAR1 = "$ 1" 
 POSPAR2 = "$ 2" 
 POSPAR3 = "$ 3" 
   
 echo "$ 1 is the first positional parameter, \ $ 1." 
 echo "$ 2 is the second positional parameter, \ $ 2." 
 echo "$ 3 is the third positional parameter, \ $ 3." 
 echo 
 echo "The total number of positional parameters is $ #." 
   
 After execution you can add any number of arguments: 
   
 wiki ~> positional.sh one two three four five 
 one is the first positional parameter, $
