{
  "safe_unwraps": [
    {
      "file": "src/infrastructure.rs",
      "line": 522,
      "code": "let results = scanner.scan_services(py, targets).unwrap();",
      "context": [
        "        Python::with_gil(|py| {",
        "            let targets = vec![",
        "                (\"127.0.0.1\".to_string(), 80),",
        "                (\"localhost\".to_string(), 443),",
        "            ];",
        "            let results = scanner.scan_services(py, targets).unwrap();",
        "            assert_eq!(results.len(), 2);",
        "        });",
        "    }",
        "",
        "    #[test]"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/infrastructure.rs",
      "line": 543,
      "code": "let result = parser.parse_yaml(yaml).unwrap();",
      "context": [
        "    environment:",
        "      ENV: production",
        "global_settings:",
        "  region: us-east-1",
        "\"#;",
        "        let result = parser.parse_yaml(yaml).unwrap();",
        "        assert!(result.contains(\"web-service\"));",
        "    }",
        "",
        "    #[test]",
        "    fn test_log_analyzer() {"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/async_helpers.rs",
      "line": 118,
      "code": "}).unwrap();",
      "context": [
        "    #[test]",
        "    fn test_py_run_async() {",
        "        Python::with_gil(|py| {",
        "            let result = py_run_async(py, async {",
        "                Ok::<i32, PyErr>(42)",
        "            }).unwrap();",
        "            assert_eq!(result, 42);",
        "        });",
        "    }",
        "}"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/security_enhanced.rs",
      "line": 1198,
      "code": "assert!(!validator.validate_command(\"rm -rf /; echo hacked\", &context).unwrap());",
      "context": [
        "",
        "        // Test safe command",
        "        assert!(validator.validate_command(\"ls -la\", &context).unwrap());",
        "",
        "        // Test dangerous command",
        "        assert!(!validator.validate_command(\"rm -rf /; echo hacked\", &context).unwrap());",
        "    }",
        "",
        "    #[test]",
        "    fn test_path_validation() {",
        "        let validator = CommandValidator::new();"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/security_enhanced.rs",
      "line": 1206,
      "code": "assert!(validator.validate_path(\"/home/user/file.txt\", Some(\"/home/user\")).unwrap());",
      "context": [
        "    #[test]",
        "    fn test_path_validation() {",
        "        let validator = CommandValidator::new();",
        "",
        "        // Test safe paths",
        "        assert!(validator.validate_path(\"/home/user/file.txt\", Some(\"/home/user\")).unwrap());",
        "",
        "        // Test path traversal",
        "        assert!(!validator.validate_path(\"../../../etc/passwd\", Some(\"/home/user\")).unwrap());",
        "    }",
        ""
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/security_enhanced.rs",
      "line": 1209,
      "code": "assert!(!validator.validate_path(\"../../../etc/passwd\", Some(\"/home/user\")).unwrap());",
      "context": [
        "",
        "        // Test safe paths",
        "        assert!(validator.validate_path(\"/home/user/file.txt\", Some(\"/home/user\")).unwrap());",
        "",
        "        // Test path traversal",
        "        assert!(!validator.validate_path(\"../../../etc/passwd\", Some(\"/home/user\")).unwrap());",
        "    }",
        "",
        "    #[test]",
        "    fn test_encryption() {",
        "        let manager = EncryptionManager::new().unwrap();"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/security_enhanced.rs",
      "line": 1214,
      "code": "let manager = EncryptionManager::new().unwrap();",
      "context": [
        "        assert!(!validator.validate_path(\"../../../etc/passwd\", Some(\"/home/user\")).unwrap());",
        "    }",
        "",
        "    #[test]",
        "    fn test_encryption() {",
        "        let manager = EncryptionManager::new().unwrap();",
        "",
        "        // Generate key",
        "        let key_id = manager.generate_key(\"test-key\", \"aes256\").unwrap();",
        "",
        "        // Encrypt data"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/security_enhanced.rs",
      "line": 1217,
      "code": "let key_id = manager.generate_key(\"test-key\", \"aes256\").unwrap();",
      "context": [
        "    #[test]",
        "    fn test_encryption() {",
        "        let manager = EncryptionManager::new().unwrap();",
        "",
        "        // Generate key",
        "        let key_id = manager.generate_key(\"test-key\", \"aes256\").unwrap();",
        "",
        "        // Encrypt data",
        "        let plaintext = b\"Secret data\";",
        "        let encrypted = manager.encrypt_data(plaintext, &key_id).unwrap();",
        ""
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/security_enhanced.rs",
      "line": 1224,
      "code": "let decrypted = manager.decrypt_data(&encrypted, &key_id).unwrap();",
      "context": [
        "        // Encrypt data",
        "        let plaintext = b\"Secret data\";",
        "        let encrypted = manager.encrypt_data(plaintext, &key_id).unwrap();",
        "",
        "        // Decrypt data",
        "        let decrypted = manager.decrypt_data(&encrypted, &key_id).unwrap();",
        "",
        "        assert_eq!(plaintext, &decrypted[..]);",
        "    }",
        "",
        "    #[test]"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/memory_mapped.rs",
      "line": 428,
      "code": "fs::write(test_file, test_content).unwrap();",
      "context": [
        "    #[test]",
        "    fn test_memory_mapped_file() {",
        "        // Create a test file",
        "        let test_content = b\"Hello World\\nThis is a test\\nAnother line\\n\";",
        "        let test_file = \"/tmp/test_mmap.txt\";",
        "        fs::write(test_file, test_content).unwrap();",
        "",
        "        Python::with_gil(|py| {",
        "            let mmap_file = MemoryMappedFile::new(test_file.to_string(), None).unwrap();",
        "",
        "            assert_eq!(mmap_file.size(), test_content.len());"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/memory_mapped.rs",
      "line": 460,
      "code": "let stats = cache.get_stats().unwrap();",
      "context": [
        "    #[test]",
        "    fn test_memory_mapped_cache() {",
        "        Python::with_gil(|py| {",
        "            let cache = MemoryMappedCache::new(10); // 10MB max",
        "",
        "            let stats = cache.get_stats().unwrap();",
        "            assert_eq!(stats[\"cached_files\"], 0);",
        "            assert_eq!(stats[\"total_size_bytes\"], 0);",
        "        });",
        "    }",
        "}"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/lockfree_collections.rs",
      "line": 719,
      "code": "assert!(stack.push(\"item1\".to_string()).unwrap());",
      "context": [
        "    #[test]",
        "    fn test_concurrent_stack() {",
        "        Python::with_gil(|_py| {",
        "            let stack = ConcurrentStack::new(Some(10));",
        "",
        "            assert!(stack.push(\"item1\".to_string()).unwrap());",
        "            assert!(stack.push(\"item2\".to_string()).unwrap());",
        "            assert_eq!(stack.size(), 2);",
        "",
        "            assert_eq!(stack.pop().unwrap(), Some(\"item2\".to_string()));",
        "            assert_eq!(stack.pop().unwrap(), Some(\"item1\".to_string()));"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/lockfree_collections.rs",
      "line": 724,
      "code": "assert_eq!(stack.pop().unwrap(), Some(\"item1\".to_string()));",
      "context": [
        "            assert!(stack.push(\"item1\".to_string()).unwrap());",
        "            assert!(stack.push(\"item2\".to_string()).unwrap());",
        "            assert_eq!(stack.size(), 2);",
        "",
        "            assert_eq!(stack.pop().unwrap(), Some(\"item2\".to_string()));",
        "            assert_eq!(stack.pop().unwrap(), Some(\"item1\".to_string()));",
        "            assert!(stack.is_empty());",
        "        });",
        "    }",
        "",
        "    #[test]"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/lockfree_collections.rs",
      "line": 734,
      "code": "assert!(queue.enqueue(\"item1\".to_string()).unwrap());",
      "context": [
        "    #[test]",
        "    fn test_concurrent_queue() {",
        "        Python::with_gil(|_py| {",
        "            let queue = ConcurrentQueue::new(Some(5));",
        "",
        "            assert!(queue.enqueue(\"item1\".to_string()).unwrap());",
        "            assert!(queue.enqueue(\"item2\".to_string()).unwrap());",
        "            assert_eq!(queue.size(), 2);",
        "",
        "            assert_eq!(queue.dequeue().unwrap(), Some(\"item1\".to_string()));",
        "            assert_eq!(queue.dequeue().unwrap(), Some(\"item2\".to_string()));"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/lockfree_collections.rs",
      "line": 739,
      "code": "assert_eq!(queue.dequeue().unwrap(), Some(\"item2\".to_string()));",
      "context": [
        "            assert!(queue.enqueue(\"item1\".to_string()).unwrap());",
        "            assert!(queue.enqueue(\"item2\".to_string()).unwrap());",
        "            assert_eq!(queue.size(), 2);",
        "",
        "            assert_eq!(queue.dequeue().unwrap(), Some(\"item1\".to_string()));",
        "            assert_eq!(queue.dequeue().unwrap(), Some(\"item2\".to_string()));",
        "            assert!(queue.is_empty());",
        "        });",
        "    }",
        "",
        "    #[test]"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/lockfree_collections.rs",
      "line": 749,
      "code": "assert!(map.insert(\"key1\".to_string(), \"value1\".to_string()).unwrap());",
      "context": [
        "    #[test]",
        "    fn test_concurrent_hashmap() {",
        "        Python::with_gil(|_py| {",
        "            let map = ConcurrentHashMap::new();",
        "",
        "            assert!(map.insert(\"key1\".to_string(), \"value1\".to_string()).unwrap());",
        "            assert_eq!(map.get(\"key1\".to_string()).unwrap(), Some(\"value1\".to_string()));",
        "            assert_eq!(map.size(), 1);",
        "",
        "            assert_eq!(map.remove(\"key1\".to_string()).unwrap(), Some(\"value1\".to_string()));",
        "            assert_eq!(map.size(), 0);"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/lockfree_collections.rs",
      "line": 753,
      "code": "assert_eq!(map.remove(\"key1\".to_string()).unwrap(), Some(\"value1\".to_string()));",
      "context": [
        "",
        "            assert!(map.insert(\"key1\".to_string(), \"value1\".to_string()).unwrap());",
        "            assert_eq!(map.get(\"key1\".to_string()).unwrap(), Some(\"value1\".to_string()));",
        "            assert_eq!(map.size(), 1);",
        "",
        "            assert_eq!(map.remove(\"key1\".to_string()).unwrap(), Some(\"value1\".to_string()));",
        "            assert_eq!(map.size(), 0);",
        "        });",
        "    }",
        "",
        "    #[test]"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/lockfree_collections.rs",
      "line": 763,
      "code": "collector.increment_counter(\"requests\".to_string()).unwrap();",
      "context": [
        "    #[test]",
        "    fn test_metrics_collector() {",
        "        Python::with_gil(|_py| {",
        "            let collector = MetricsCollector::new();",
        "",
        "            collector.increment_counter(\"requests\".to_string()).unwrap();",
        "            collector.add_to_counter(\"requests\".to_string(), 5).unwrap();",
        "            assert_eq!(collector.get_counter(\"requests\".to_string()).unwrap(), 6);",
        "",
        "            collector.set_gauge(\"memory_usage\".to_string(), 1024).unwrap();",
        "            assert_eq!(collector.get_gauge(\"memory_usage\".to_string()).unwrap(), 1024);"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/simd_ops.rs",
      "line": 493,
      "code": "let result = simd_sum_f32(&values).unwrap();",
      "context": [
        "    use super::*;",
        "",
        "    #[test]",
        "    fn test_simd_sum() {",
        "        let values = vec![1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0];",
        "        let result = simd_sum_f32(&values).unwrap();",
        "        assert_eq!(result, 55.0);",
        "    }",
        "",
        "    #[test]",
        "    fn test_simd_dot_product() {"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/simd_ops.rs",
      "line": 501,
      "code": "let result = simd_dot_product(&a, &b).unwrap();",
      "context": [
        "",
        "    #[test]",
        "    fn test_simd_dot_product() {",
        "        let a = vec![1.0, 2.0, 3.0, 4.0];",
        "        let b = vec![2.0, 3.0, 4.0, 5.0];",
        "        let result = simd_dot_product(&a, &b).unwrap();",
        "        assert_eq!(result, 40.0); // 1*2 + 2*3 + 3*4 + 4*5 = 2 + 6 + 12 + 20 = 40",
        "    }",
        "",
        "    #[test]",
        "    fn test_simd_element_wise_add() {"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/simd_ops.rs",
      "line": 509,
      "code": "let result = simd_element_wise_add(&a, &b).unwrap();",
      "context": [
        "",
        "    #[test]",
        "    fn test_simd_element_wise_add() {",
        "        let a = vec![1.0, 2.0, 3.0, 4.0];",
        "        let b = vec![2.0, 3.0, 4.0, 5.0];",
        "        let result = simd_element_wise_add(&a, &b).unwrap();",
        "        assert_eq!(result, vec![3.0, 5.0, 7.0, 9.0]);",
        "    }",
        "",
        "    #[test]",
        "    fn test_simd_matrix_multiply() {"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/simd_ops.rs",
      "line": 517,
      "code": "let result = simd_matrix_multiply(&a, &b).unwrap();",
      "context": [
        "",
        "    #[test]",
        "    fn test_simd_matrix_multiply() {",
        "        let a = vec![vec![1.0, 2.0], vec![3.0, 4.0]];",
        "        let b = vec![vec![2.0, 0.0], vec![1.0, 2.0]];",
        "        let result = simd_matrix_multiply(&a, &b).unwrap();",
        "        let expected = vec![vec![4.0, 4.0], vec![10.0, 8.0]];",
        "        assert_eq!(result, expected);",
        "    }",
        "",
        "    #[test]"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/simd_ops.rs",
      "line": 525,
      "code": "let result = simd_filter_values(&values, \"gt\", 3.0).unwrap();",
      "context": [
        "    }",
        "",
        "    #[test]",
        "    fn test_simd_filter_values() {",
        "        let values = vec![1.0, 2.0, 3.0, 4.0, 5.0];",
        "        let result = simd_filter_values(&values, \"gt\", 3.0).unwrap();",
        "        assert_eq!(result, vec![4.0, 5.0]);",
        "    }",
        "}"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/zero_copy_net.rs",
      "line": 615,
      "code": "let write_result = buffer.write_data(vec![1, 2, 3, 4, 5]).unwrap();",
      "context": [
        "",
        "    #[test]",
        "    fn test_network_buffer() {",
        "        let mut buffer = NetworkBuffer::new(1024);",
        "",
        "        let write_result = buffer.write_data(vec![1, 2, 3, 4, 5]).unwrap();",
        "        assert_eq!(write_result, 5);",
        "",
        "        let read_result = buffer.read_data(3).unwrap();",
        "        assert_eq!(read_result, vec![1, 2, 3]);",
        ""
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/zero_copy_net.rs",
      "line": 621,
      "code": "let stats = buffer.get_stats().unwrap();",
      "context": [
        "        assert_eq!(write_result, 5);",
        "",
        "        let read_result = buffer.read_data(3).unwrap();",
        "        assert_eq!(read_result, vec![1, 2, 3]);",
        "",
        "        let stats = buffer.get_stats().unwrap();",
        "        assert_eq!(stats[\"used\"], 2); // 5 written, 3 read",
        "    }",
        "",
        "    #[test]",
        "    fn test_zero_copy_client() {"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/zero_copy_net.rs",
      "line": 646,
      "code": "let stats = pool.get_pool_stats().unwrap();",
      "context": [
        "    #[test]",
        "    fn test_connection_pool() {",
        "        Python::with_gil(|py| {",
        "            let pool = ConnectionPool::new(Some(5), Some(30));",
        "",
        "            let stats = pool.get_pool_stats().unwrap();",
        "            assert_eq!(stats[\"total_connections\"], 0);",
        "            assert_eq!(stats[\"max_per_host\"], 5);",
        "        });",
        "    }",
        "}"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/performance.rs",
      "line": 459,
      "code": "let results = executor.execute_batch(py, tasks).unwrap();",
      "context": [
        "                (\"task1\".to_string(), \"io\".to_string()),",
        "                (\"task2\".to_string(), \"cpu\".to_string()),",
        "                (\"task3\".to_string(), \"async\".to_string()),",
        "            ];",
        "",
        "            let results = executor.execute_batch(py, tasks).unwrap();",
        "            assert_eq!(results.len(), 3);",
        "        });",
        "    }",
        "",
        "    #[test]"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/performance.rs",
      "line": 474,
      "code": "let stats = monitor.get_operation_stats(\"test_op\").unwrap();",
      "context": [
        "        std::thread::sleep(Duration::from_millis(10));",
        "        let duration = monitor.end_operation(\"test_op\".to_string()).unwrap();",
        "",
        "        assert!(duration > 0.01);",
        "",
        "        let stats = monitor.get_operation_stats(\"test_op\").unwrap();",
        "        assert_eq!(stats[\"count\"], 1.0);",
        "    }",
        "",
        "    #[test]",
        "    fn test_resource_pool() {"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/performance.rs",
      "line": 483,
      "code": "let r1 = pool.acquire().unwrap().unwrap();",
      "context": [
        "    #[test]",
        "    fn test_resource_pool() {",
        "        let pool = ResourcePool::new(3);",
        "",
        "        // Acquire resources",
        "        let r1 = pool.acquire().unwrap().unwrap();",
        "        let r2 = pool.acquire().unwrap().unwrap();",
        "        let r3 = pool.acquire().unwrap().unwrap();",
        "",
        "        // Pool should be exhausted",
        "        assert!(pool.acquire().unwrap().is_none());"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/ffi_security.rs",
      "line": 419,
      "code": "let safe = SafeBuffer::from_pybytes(py, &PyBytes::new(py, &normal_buffer)).unwrap();",
      "context": [
        "        let large_buffer = vec![0u8; MAX_BUFFER_SIZE + 1];",
        "        assert!(SafeBuffer::from_pybytes(py, &PyBytes::new(py, &large_buffer)).is_err());",
        "",
        "        // Test normal buffer",
        "        let normal_buffer = vec![1, 2, 3, 4];",
        "        let safe = SafeBuffer::from_pybytes(py, &PyBytes::new(py, &normal_buffer)).unwrap();",
        "        assert_eq!(safe.data(), &[1, 2, 3, 4]);",
        "    }",
        "",
        "    #[test]",
        "    fn test_panic_protection() {"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/security.rs",
      "line": 316,
      "code": "let vault = SecureVault::new(&key).unwrap();",
      "context": [
        "    use super::*;",
        "",
        "    #[test]",
        "    fn test_secure_vault() {",
        "        let key = generate_key(32);",
        "        let vault = SecureVault::new(&key).unwrap();",
        "",
        "        let plaintext = b\"Hello, World!\";",
        "        let ciphertext = vault.encrypt(plaintext).unwrap();",
        "        let decrypted = vault.decrypt(&ciphertext).unwrap();",
        ""
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/security.rs",
      "line": 320,
      "code": "let decrypted = vault.decrypt(&ciphertext).unwrap();",
      "context": [
        "        let key = generate_key(32);",
        "        let vault = SecureVault::new(&key).unwrap();",
        "",
        "        let plaintext = b\"Hello, World!\";",
        "        let ciphertext = vault.encrypt(plaintext).unwrap();",
        "        let decrypted = vault.decrypt(&ciphertext).unwrap();",
        "",
        "        assert_eq!(plaintext, &decrypted[..]);",
        "    }",
        "",
        "    #[test]"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/security.rs",
      "line": 328,
      "code": "let hashes = hash_passwords_batch_py(passwords.clone()).unwrap();",
      "context": [
        "    }",
        "",
        "    #[test]",
        "    fn test_password_hashing() {",
        "        let passwords = vec![\"password123\".to_string(), \"secure_pass\".to_string()];",
        "        let hashes = hash_passwords_batch_py(passwords.clone()).unwrap();",
        "",
        "        assert_eq!(hashes.len(), 2);",
        "",
        "        // Verify the passwords",
        "        let results = verify_passwords_batch_py(passwords, hashes).unwrap();"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/security.rs",
      "line": 333,
      "code": "let results = verify_passwords_batch_py(passwords, hashes).unwrap();",
      "context": [
        "        let hashes = hash_passwords_batch_py(passwords.clone()).unwrap();",
        "",
        "        assert_eq!(hashes.len(), 2);",
        "",
        "        // Verify the passwords",
        "        let results = verify_passwords_batch_py(passwords, hashes).unwrap();",
        "        assert!(results.iter().all(|&r| r));",
        "    }",
        "",
        "    #[test]",
        "    fn test_security_auditor() {"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/security.rs",
      "line": 342,
      "code": "assert!(!auditor.check_password_strength(\"weak\").unwrap());",
      "context": [
        "    #[test]",
        "    fn test_security_auditor() {",
        "        let mut auditor = SecurityAuditor::new();",
        "",
        "        // Test password strength",
        "        assert!(!auditor.check_password_strength(\"weak\").unwrap());",
        "        assert!(auditor.check_password_strength(\"Str0ng!P@ssw0rd\").unwrap());",
        "",
        "        // Test vulnerability scanning",
        "        let mut config = HashMap::new();",
        "        config.insert(\"api_url\".to_string(), \"http://api.example.com\".to_string());"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/security.rs",
      "line": 350,
      "code": "let vulns = auditor.scan_vulnerabilities(config).unwrap();",
      "context": [
        "        // Test vulnerability scanning",
        "        let mut config = HashMap::new();",
        "        config.insert(\"api_url\".to_string(), \"http://api.example.com\".to_string());",
        "        config.insert(\"db_password\".to_string(), \"hardcoded123\".to_string());",
        "",
        "        let vulns = auditor.scan_vulnerabilities(config).unwrap();",
        "        assert!(!vulns.is_empty());",
        "    }",
        "",
        "    #[test]",
        "    fn test_hmac_generation() {"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/security.rs",
      "line": 359,
      "code": "let signatures = generate_hmac_batch_py(messages, key).unwrap();",
      "context": [
        "    #[test]",
        "    fn test_hmac_generation() {",
        "        let messages = vec![\"message1\".to_string(), \"message2\".to_string()];",
        "        let key = b\"secret_key_123\";",
        "",
        "        let signatures = generate_hmac_batch_py(messages, key).unwrap();",
        "        assert_eq!(signatures.len(), 2);",
        "        assert!(!signatures[0].is_empty());",
        "    }",
        "}"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests.rs",
      "line": 16,
      "code": "let rt = Runtime::new().unwrap();",
      "context": [
        "    use std::time::Duration;",
        "    use tokio::runtime::Runtime;",
        "",
        "    #[test]",
        "    fn test_distributed_coordinator() {",
        "        let rt = Runtime::new().unwrap();",
        "",
        "        rt.block_on(async {",
        "            let peers = HashSet::from([\"node2\".to_string(), \"node3\".to_string()]);",
        "            let coordinator = DistributedCoordinator::new(\"node1\".to_string(), peers);",
        ""
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests.rs",
      "line": 35,
      "code": "let rt = Runtime::new().unwrap();",
      "context": [
        "        });",
        "    }",
        "",
        "    #[test]",
        "    fn test_load_balancer_strategies() {",
        "        let rt = Runtime::new().unwrap();",
        "",
        "        rt.block_on(async {",
        "            // Test round-robin",
        "            let lb = LoadBalancer::new(LoadBalancingStrategy::RoundRobin);",
        ""
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests.rs",
      "line": 79,
      "code": "let server1 = lb_hash.select_server(Some(\"user123\")).await.unwrap();",
      "context": [
        "                };",
        "                lb_hash.add_server(server);",
        "            }",
        "",
        "            // Same key should always go to same server",
        "            let server1 = lb_hash.select_server(Some(\"user123\")).await.unwrap();",
        "            let server2 = lb_hash.select_server(Some(\"user123\")).await.unwrap();",
        "            assert_eq!(server1, server2);",
        "        });",
        "    }",
        ""
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests.rs",
      "line": 80,
      "code": "let server2 = lb_hash.select_server(Some(\"user123\")).await.unwrap();",
      "context": [
        "                lb_hash.add_server(server);",
        "            }",
        "",
        "            // Same key should always go to same server",
        "            let server1 = lb_hash.select_server(Some(\"user123\")).await.unwrap();",
        "            let server2 = lb_hash.select_server(Some(\"user123\")).await.unwrap();",
        "            assert_eq!(server1, server2);",
        "        });",
        "    }",
        "",
        "    #[test]"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests.rs",
      "line": 87,
      "code": "let rt = Runtime::new().unwrap();",
      "context": [
        "        });",
        "    }",
        "",
        "    #[test]",
        "    fn test_failover_manager() {",
        "        let rt = Runtime::new().unwrap();",
        "",
        "        rt.block_on(async {",
        "            let manager = FailoverManager::new(FailoverStrategy::ActivePassive);",
        "",
        "            // Add primary node"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests.rs",
      "line": 127,
      "code": "manager.save_snapshot(\"primary\".to_string(), data).await.unwrap();",
      "context": [
        "            // Verify primary",
        "            assert_eq!(manager.get_primary(), Some(\"primary\".to_string()));",
        "",
        "            // Test state snapshot",
        "            let data = b\"test state data\".to_vec();",
        "            manager.save_snapshot(\"primary\".to_string(), data).await.unwrap();",
        "        });",
        "    }",
        "",
        "    #[test]",
        "    fn test_chaos_engineering() {"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests.rs",
      "line": 133,
      "code": "let rt = Runtime::new().unwrap();",
      "context": [
        "        });",
        "    }",
        "",
        "    #[test]",
        "    fn test_chaos_engineering() {",
        "        let rt = Runtime::new().unwrap();",
        "",
        "        rt.block_on(async {",
        "            let chaos = ChaosEngineer::new();",
        "",
        "            // Register mock service"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests.rs",
      "line": 151,
      "code": "let experiment_id = chaos.schedule_experiment(config).await.unwrap();",
      "context": [
        "                intensity: 0.5,",
        "                probability: 1.0,",
        "                params: HashMap::new(),",
        "            };",
        "",
        "            let experiment_id = chaos.schedule_experiment(config).await.unwrap();",
        "            assert!(!experiment_id.is_empty());",
        "",
        "            // Wait for experiment to complete",
        "            tokio::time::sleep(Duration::from_secs(2)).await;",
        ""
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests.rs",
      "line": 165,
      "code": "let rt = Runtime::new().unwrap();",
      "context": [
        "        });",
        "    }",
        "",
        "    #[test]",
        "    fn test_bulkhead_pattern() {",
        "        let rt = Runtime::new().unwrap();",
        "",
        "        rt.block_on(async {",
        "            use crate::mcp_manager::resilience::bulkhead::Bulkhead;",
        "",
        "            let bulkhead = Bulkhead::new(\"api\".to_string(), 2);"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests.rs",
      "line": 175,
      "code": "assert_eq!(result.unwrap(), 42);",
      "context": [
        "            let bulkhead = Bulkhead::new(\"api\".to_string(), 2);",
        "",
        "            // Test successful execution",
        "            let result = bulkhead.execute(async { Ok::<i32, crate::mcp_manager::errors::McpError>(42) }).await;",
        "            assert!(result.is_ok());",
        "            assert_eq!(result.unwrap(), 42);",
        "",
        "            // Test available permits",
        "            assert!(bulkhead.available_permits() <= 2);",
        "            assert!(!bulkhead.is_at_capacity());",
        "        });"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests.rs",
      "line": 185,
      "code": "let rt = Runtime::new().unwrap();",
      "context": [
        "        });",
        "    }",
        "",
        "    #[test]",
        "    fn test_advanced_cache() {",
        "        let rt = Runtime::new().unwrap();",
        "",
        "        rt.block_on(async {",
        "            let cache = AdvancedCache::new(",
        "                1024 * 1024, // 1MB",
        "                100,         // 100 entries"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests.rs",
      "line": 196,
      "code": "cache.put(\"key1\".to_string(), vec![1, 2, 3], 3).await.unwrap();",
      "context": [
        "                EvictionPolicy::LRU,",
        "                Some(Duration::from_secs(60)),",
        "            );",
        "",
        "            // Test basic operations",
        "            cache.put(\"key1\".to_string(), vec![1, 2, 3], 3).await.unwrap();",
        "            cache.put(\"key2\".to_string(), vec![4, 5, 6], 3).await.unwrap();",
        "",
        "            // Test get",
        "            let value = cache.get(&\"key1\".to_string()).await;",
        "            assert_eq!(value, Some(vec![1, 2, 3]));"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests.rs",
      "line": 197,
      "code": "cache.put(\"key2\".to_string(), vec![4, 5, 6], 3).await.unwrap();",
      "context": [
        "                Some(Duration::from_secs(60)),",
        "            );",
        "",
        "            // Test basic operations",
        "            cache.put(\"key1\".to_string(), vec![1, 2, 3], 3).await.unwrap();",
        "            cache.put(\"key2\".to_string(), vec![4, 5, 6], 3).await.unwrap();",
        "",
        "            // Test get",
        "            let value = cache.get(&\"key1\".to_string()).await;",
        "            assert_eq!(value, Some(vec![1, 2, 3]));",
        ""
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests.rs",
      "line": 216,
      "code": "let rt = Runtime::new().unwrap();",
      "context": [
        "        });",
        "    }",
        "",
        "    #[test]",
        "    fn test_predictive_prefetcher() {",
        "        let rt = Runtime::new().unwrap();",
        "",
        "        rt.block_on(async {",
        "            let prefetcher = PredictivePrefetcher::new(PrefetchStrategy::Sequential);",
        "",
        "            // Record sequential access pattern"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests.rs",
      "line": 247,
      "code": "let rt = Runtime::new().unwrap();",
      "context": [
        "        });",
        "    }",
        "",
        "    #[test]",
        "    fn test_multi_tier_cache() {",
        "        let rt = Runtime::new().unwrap();",
        "",
        "        rt.block_on(async {",
        "            let mut cache = MultiTierCache::new();",
        "",
        "            // L1: Small, fast cache"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests.rs",
      "line": 269,
      "code": "cache.put(\"key1\".to_string(), vec![1, 2, 3], 3).await.unwrap();",
      "context": [
        "                EvictionPolicy::LFU,",
        "                Some(Duration::from_secs(300)),",
        "            );",
        "",
        "            // Test operations",
        "            cache.put(\"key1\".to_string(), vec![1, 2, 3], 3).await.unwrap();",
        "",
        "            let value = cache.get(&\"key1\".to_string()).await;",
        "            assert_eq!(value, Some(vec![1, 2, 3]));",
        "",
        "            // Get tier statistics"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/actor_tests.rs",
      "line": 41,
      "code": "let server_id = runtime.deploy(server_config).await.unwrap();",
      "context": [
        "        let config = McpManagerConfig::default();",
        "        let runtime = McpRuntime::new(config);",
        "",
        "        // Deploy a server",
        "        let server_config = create_test_server_config(\"test1\");",
        "        let server_id = runtime.deploy(server_config).await.unwrap();",
        "        assert_eq!(server_id, \"test1\");",
        "",
        "        // List servers",
        "        let servers = runtime.list_servers().await.unwrap();",
        "        assert_eq!(servers.len(), 1);"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/actor_tests.rs",
      "line": 45,
      "code": "let servers = runtime.list_servers().await.unwrap();",
      "context": [
        "        let server_config = create_test_server_config(\"test1\");",
        "        let server_id = runtime.deploy(server_config).await.unwrap();",
        "        assert_eq!(server_id, \"test1\");",
        "",
        "        // List servers",
        "        let servers = runtime.list_servers().await.unwrap();",
        "        assert_eq!(servers.len(), 1);",
        "        assert!(servers.contains(&\"test1\".to_string()));",
        "",
        "        // Check metrics",
        "        let metrics = runtime.get_metrics(None).await.unwrap();"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/actor_tests.rs",
      "line": 50,
      "code": "let metrics = runtime.get_metrics(None).await.unwrap();",
      "context": [
        "        let servers = runtime.list_servers().await.unwrap();",
        "        assert_eq!(servers.len(), 1);",
        "        assert!(servers.contains(&\"test1\".to_string()));",
        "",
        "        // Check metrics",
        "        let metrics = runtime.get_metrics(None).await.unwrap();",
        "        assert_eq!(metrics.active_servers, 1);",
        "        assert!(metrics.total_commands > 0);",
        "        assert!(metrics.successful_commands > 0);",
        "",
        "        // Undeploy"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/actor_tests.rs",
      "line": 56,
      "code": "runtime.undeploy(&server_id).await.unwrap();",
      "context": [
        "        assert_eq!(metrics.active_servers, 1);",
        "        assert!(metrics.total_commands > 0);",
        "        assert!(metrics.successful_commands > 0);",
        "",
        "        // Undeploy",
        "        runtime.undeploy(&server_id).await.unwrap();",
        "",
        "        // Verify server is gone",
        "        let servers = runtime.list_servers().await.unwrap();",
        "        assert!(servers.is_empty());",
        ""
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/actor_tests.rs",
      "line": 59,
      "code": "let servers = runtime.list_servers().await.unwrap();",
      "context": [
        "",
        "        // Undeploy",
        "        runtime.undeploy(&server_id).await.unwrap();",
        "",
        "        // Verify server is gone",
        "        let servers = runtime.list_servers().await.unwrap();",
        "        assert!(servers.is_empty());",
        "",
        "        // Shutdown",
        "        runtime.shutdown().await.unwrap();",
        "    }"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/actor_tests.rs",
      "line": 63,
      "code": "runtime.shutdown().await.unwrap();",
      "context": [
        "        // Verify server is gone",
        "        let servers = runtime.list_servers().await.unwrap();",
        "        assert!(servers.is_empty());",
        "",
        "        // Shutdown",
        "        runtime.shutdown().await.unwrap();",
        "    }",
        "",
        "    #[tokio::test]",
        "    async fn test_concurrent_deployments() {",
        "        let config = McpManagerConfig::default();"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/actor_tests.rs",
      "line": 87,
      "code": "let server_id = result.as_ref().unwrap().as_ref().unwrap();",
      "context": [
        "        // Wait for all deployments",
        "        let results: Vec<_> = futures::future::join_all(tasks).await;",
        "",
        "        // Verify all succeeded",
        "        for (i, result) in results.iter().enumerate() {",
        "            let server_id = result.as_ref().unwrap().as_ref().unwrap();",
        "            assert_eq!(server_id, &format!(\"server{}\", i));",
        "        }",
        "",
        "        // Check server count",
        "        let servers = runtime.list_servers().await.unwrap();"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/actor_tests.rs",
      "line": 92,
      "code": "let servers = runtime.list_servers().await.unwrap();",
      "context": [
        "            let server_id = result.as_ref().unwrap().as_ref().unwrap();",
        "            assert_eq!(server_id, &format!(\"server{}\", i));",
        "        }",
        "",
        "        // Check server count",
        "        let servers = runtime.list_servers().await.unwrap();",
        "        assert_eq!(servers.len(), 10);",
        "",
        "        // Check metrics",
        "        let metrics = runtime.get_metrics(None).await.unwrap();",
        "        assert_eq!(metrics.active_servers, 10);"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/actor_tests.rs",
      "line": 96,
      "code": "let metrics = runtime.get_metrics(None).await.unwrap();",
      "context": [
        "        // Check server count",
        "        let servers = runtime.list_servers().await.unwrap();",
        "        assert_eq!(servers.len(), 10);",
        "",
        "        // Check metrics",
        "        let metrics = runtime.get_metrics(None).await.unwrap();",
        "        assert_eq!(metrics.active_servers, 10);",
        "",
        "        runtime.shutdown().await.unwrap();",
        "    }",
        ""
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/actor_tests.rs",
      "line": 99,
      "code": "runtime.shutdown().await.unwrap();",
      "context": [
        "",
        "        // Check metrics",
        "        let metrics = runtime.get_metrics(None).await.unwrap();",
        "        assert_eq!(metrics.active_servers, 10);",
        "",
        "        runtime.shutdown().await.unwrap();",
        "    }",
        "",
        "    #[tokio::test]",
        "    async fn test_duplicate_deployment_error() {",
        "        let config = McpManagerConfig::default();"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/actor_tests.rs",
      "line": 109,
      "code": "runtime.deploy(server_config.clone()).await.unwrap();",
      "context": [
        "        let config = McpManagerConfig::default();",
        "        let runtime = McpRuntime::new(config);",
        "",
        "        // Deploy a server",
        "        let server_config = create_test_server_config(\"duplicate\");",
        "        runtime.deploy(server_config.clone()).await.unwrap();",
        "",
        "        // Try to deploy again with same name",
        "        let result = runtime.deploy(server_config).await;",
        "        assert!(result.is_err());",
        ""
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/actor_tests.rs",
      "line": 122,
      "code": "runtime.shutdown().await.unwrap();",
      "context": [
        "                assert!(msg.contains(\"duplicate\"));",
        "            }",
        "            _ => panic!(\"Expected AlreadyExists error\"),",
        "        }",
        "",
        "        runtime.shutdown().await.unwrap();",
        "    }",
        "",
        "    #[tokio::test]",
        "    async fn test_undeploy_nonexistent_server() {",
        "        let config = McpManagerConfig::default();"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/actor_tests.rs",
      "line": 141,
      "code": "runtime.shutdown().await.unwrap();",
      "context": [
        "                assert!(msg.contains(\"nonexistent\"));",
        "            }",
        "            _ => panic!(\"Expected NotFound error\"),",
        "        }",
        "",
        "        runtime.shutdown().await.unwrap();",
        "    }",
        "",
        "    #[tokio::test]",
        "    async fn test_backpressure() {",
        "        let config = McpManagerConfig::default();"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/actor_tests.rs",
      "line": 163,
      "code": "assert!(result.unwrap().is_ok());",
      "context": [
        "",
        "        // All should complete successfully despite high load",
        "        let results: Vec<_> = futures::future::join_all(tasks).await;",
        "        for result in results {",
        "            assert!(result.is_ok());",
        "            assert!(result.unwrap().is_ok());",
        "        }",
        "",
        "        runtime.shutdown().await.unwrap();",
        "    }",
        ""
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/actor_tests.rs",
      "line": 166,
      "code": "runtime.shutdown().await.unwrap();",
      "context": [
        "        for result in results {",
        "            assert!(result.is_ok());",
        "            assert!(result.unwrap().is_ok());",
        "        }",
        "",
        "        runtime.shutdown().await.unwrap();",
        "    }",
        "",
        "    #[tokio::test]",
        "    async fn test_manager_v2_integration() {",
        "        let mut config = McpManagerConfig::default();"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/actor_tests.rs",
      "line": 180,
      "code": "manager.initialize().await.unwrap();",
      "context": [
        "        config.servers.push(create_test_server_config(\"config2\"));",
        "",
        "        let manager = McpManagerV2::new(config);",
        "",
        "        // Initialize should deploy configured servers",
        "        manager.initialize().await.unwrap();",
        "",
        "        // Verify servers were deployed",
        "        let servers = manager.list_servers().await.unwrap();",
        "        assert_eq!(servers.len(), 2);",
        "        assert!(servers.contains(&\"config1\".to_string()));"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/actor_tests.rs",
      "line": 183,
      "code": "let servers = manager.list_servers().await.unwrap();",
      "context": [
        "",
        "        // Initialize should deploy configured servers",
        "        manager.initialize().await.unwrap();",
        "",
        "        // Verify servers were deployed",
        "        let servers = manager.list_servers().await.unwrap();",
        "        assert_eq!(servers.len(), 2);",
        "        assert!(servers.contains(&\"config1\".to_string()));",
        "        assert!(servers.contains(&\"config2\".to_string()));",
        "",
        "        // Deploy additional server"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/actor_tests.rs",
      "line": 190,
      "code": "manager.deploy_server(new_server).await.unwrap();",
      "context": [
        "        assert!(servers.contains(&\"config1\".to_string()));",
        "        assert!(servers.contains(&\"config2\".to_string()));",
        "",
        "        // Deploy additional server",
        "        let new_server = create_test_server_config(\"dynamic\");",
        "        manager.deploy_server(new_server).await.unwrap();",
        "",
        "        // Verify total count",
        "        let servers = manager.list_servers().await.unwrap();",
        "        assert_eq!(servers.len(), 3);",
        ""
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/actor_tests.rs",
      "line": 193,
      "code": "let servers = manager.list_servers().await.unwrap();",
      "context": [
        "        // Deploy additional server",
        "        let new_server = create_test_server_config(\"dynamic\");",
        "        manager.deploy_server(new_server).await.unwrap();",
        "",
        "        // Verify total count",
        "        let servers = manager.list_servers().await.unwrap();",
        "        assert_eq!(servers.len(), 3);",
        "",
        "        // Test execute_tool (would fail without real server)",
        "        let result = manager.execute_tool(\"config1\", \"test.tool\", serde_json::json!({})).await;",
        "        // We expect this to fail in tests but the structure should work"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/actor_tests.rs",
      "line": 202,
      "code": "let metrics = manager.get_metrics(None).await.unwrap();",
      "context": [
        "        let result = manager.execute_tool(\"config1\", \"test.tool\", serde_json::json!({})).await;",
        "        // We expect this to fail in tests but the structure should work",
        "        assert!(result.is_err());",
        "",
        "        // Get metrics",
        "        let metrics = manager.get_metrics(None).await.unwrap();",
        "        assert_eq!(metrics.active_servers, 3);",
        "",
        "        // Shutdown",
        "        manager.shutdown().await.unwrap();",
        "    }"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/actor_tests.rs",
      "line": 206,
      "code": "manager.shutdown().await.unwrap();",
      "context": [
        "        // Get metrics",
        "        let metrics = manager.get_metrics(None).await.unwrap();",
        "        assert_eq!(metrics.active_servers, 3);",
        "",
        "        // Shutdown",
        "        manager.shutdown().await.unwrap();",
        "    }",
        "",
        "    #[tokio::test]",
        "    async fn test_graceful_shutdown() {",
        "        let config = McpManagerConfig::default();"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/actor_tests.rs",
      "line": 217,
      "code": "runtime.deploy(config).await.unwrap();",
      "context": [
        "        let runtime = McpRuntime::new(config);",
        "",
        "        // Deploy some servers",
        "        for i in 0..5 {",
        "            let config = create_test_server_config(&format!(\"shutdown{}\", i));",
        "            runtime.deploy(config).await.unwrap();",
        "        }",
        "",
        "        // Start a long-running operation",
        "        let runtime_clone = runtime.clone();",
        "        let long_op = tokio::spawn(async move {"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/actor_tests.rs",
      "line": 229,
      "code": "runtime.shutdown().await.unwrap();",
      "context": [
        "            tokio::time::sleep(Duration::from_secs(5)).await;",
        "            runtime_clone.list_servers().await",
        "        });",
        "",
        "        // Shutdown should wait for operations to complete",
        "        runtime.shutdown().await.unwrap();",
        "",
        "        // The long operation should have been cancelled",
        "        assert!(timeout(Duration::from_millis(100), long_op).await.is_ok());",
        "    }",
        ""
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/actor_tests.rs",
      "line": 242,
      "code": "runtime.deploy(server1).await.unwrap();",
      "context": [
        "        let config = McpManagerConfig::default();",
        "        let runtime = McpRuntime::new(config);",
        "",
        "        // Perform various operations",
        "        let server1 = create_test_server_config(\"metrics1\");",
        "        runtime.deploy(server1).await.unwrap();",
        "",
        "        let server2 = create_test_server_config(\"metrics2\");",
        "        runtime.deploy(server2).await.unwrap();",
        "",
        "        // Some successful operations"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/actor_tests.rs",
      "line": 245,
      "code": "runtime.deploy(server2).await.unwrap();",
      "context": [
        "        // Perform various operations",
        "        let server1 = create_test_server_config(\"metrics1\");",
        "        runtime.deploy(server1).await.unwrap();",
        "",
        "        let server2 = create_test_server_config(\"metrics2\");",
        "        runtime.deploy(server2).await.unwrap();",
        "",
        "        // Some successful operations",
        "        runtime.list_servers().await.unwrap();",
        "        runtime.health_check(\"metrics1\").await.unwrap();",
        ""
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/actor_tests.rs",
      "line": 248,
      "code": "runtime.list_servers().await.unwrap();",
      "context": [
        "",
        "        let server2 = create_test_server_config(\"metrics2\");",
        "        runtime.deploy(server2).await.unwrap();",
        "",
        "        // Some successful operations",
        "        runtime.list_servers().await.unwrap();",
        "        runtime.health_check(\"metrics1\").await.unwrap();",
        "",
        "        // Some failed operations",
        "        let _ = runtime.undeploy(\"nonexistent\").await;",
        "        let _ = runtime.health_check(\"nonexistent\").await;"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/actor_tests.rs",
      "line": 249,
      "code": "runtime.health_check(\"metrics1\").await.unwrap();",
      "context": [
        "        let server2 = create_test_server_config(\"metrics2\");",
        "        runtime.deploy(server2).await.unwrap();",
        "",
        "        // Some successful operations",
        "        runtime.list_servers().await.unwrap();",
        "        runtime.health_check(\"metrics1\").await.unwrap();",
        "",
        "        // Some failed operations",
        "        let _ = runtime.undeploy(\"nonexistent\").await;",
        "        let _ = runtime.health_check(\"nonexistent\").await;",
        ""
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/actor_tests.rs",
      "line": 256,
      "code": "let metrics = runtime.get_metrics(None).await.unwrap();",
      "context": [
        "        // Some failed operations",
        "        let _ = runtime.undeploy(\"nonexistent\").await;",
        "        let _ = runtime.health_check(\"nonexistent\").await;",
        "",
        "        // Check metrics",
        "        let metrics = runtime.get_metrics(None).await.unwrap();",
        "        assert_eq!(metrics.active_servers, 2);",
        "        assert!(metrics.total_commands >= 6); // At least our operations",
        "        assert!(metrics.successful_commands >= 4); // Deploys + list + health",
        "        assert!(metrics.failed_commands >= 2); // Failed undeploy + health",
        "        assert!(metrics.avg_latency_us > 0);"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/actor_tests.rs",
      "line": 263,
      "code": "runtime.shutdown().await.unwrap();",
      "context": [
        "        assert!(metrics.total_commands >= 6); // At least our operations",
        "        assert!(metrics.successful_commands >= 4); // Deploys + list + health",
        "        assert!(metrics.failed_commands >= 2); // Failed undeploy + health",
        "        assert!(metrics.avg_latency_us > 0);",
        "",
        "        runtime.shutdown().await.unwrap();",
        "    }",
        "",
        "    #[tokio::test]",
        "    async fn test_error_propagation() {",
        "        let config = McpManagerConfig::default();"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/actor_tests.rs",
      "line": 286,
      "code": "runtime.shutdown().await.unwrap();",
      "context": [
        "                McpError::NotFound(_) => {}, // Expected",
        "                e => panic!(\"Unexpected error type: {:?}\", e),",
        "            }",
        "        }",
        "",
        "        runtime.shutdown().await.unwrap();",
        "    }",
        "}"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/memory/index.rs",
      "line": 352,
      "code": "index.add_entry(\"docker-build\", NodeIndex::new(0)).unwrap();",
      "context": [
        "    #[test]",
        "    fn test_prefix_search() {",
        "        let index = MemoryIndex::new();",
        "",
        "        // Add multiple entries",
        "        index.add_entry(\"docker-build\", NodeIndex::new(0)).unwrap();",
        "        index.add_entry(\"docker-run\", NodeIndex::new(1)).unwrap();",
        "        index.add_entry(\"kubectl-apply\", NodeIndex::new(2)).unwrap();",
        "",
        "        // Search by prefix",
        "        let docker_results = index.find_by_prefix(\"docker\");"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/memory/index.rs",
      "line": 372,
      "code": "index.add_entry(\"app1\", NodeIndex::new(0)).unwrap();",
      "context": [
        "    #[test]",
        "    fn test_resource_index() {",
        "        let index = MemoryIndex::new();",
        "",
        "        // Add entries with resources",
        "        index.add_entry(\"app1\", NodeIndex::new(0)).unwrap();",
        "        index.update_resources(\"app1\", &HashSet::from([\"port:8080\".to_string()])).unwrap();",
        "",
        "        index.add_entry(\"app2\", NodeIndex::new(1)).unwrap();",
        "        index.update_resources(\"app2\", &HashSet::from([\"port:8080\".to_string(), \"db:postgres\".to_string()])).unwrap();",
        ""
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/memory/optimization.rs",
      "line": 380,
      "code": "assert_eq!(heap.pop().unwrap().entry_id, \"low\");",
      "context": [
        "            score: 5.0,",
        "            memory_size: 1024,",
        "        });",
        "",
        "        // Should pop in order: low (1.0), medium (5.0), high (10.0)",
        "        assert_eq!(heap.pop().unwrap().entry_id, \"low\");",
        "        assert_eq!(heap.pop().unwrap().entry_id, \"medium\");",
        "        assert_eq!(heap.pop().unwrap().entry_id, \"high\");",
        "    }",
        "",
        "    #[test]"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/memory/optimization.rs",
      "line": 381,
      "code": "assert_eq!(heap.pop().unwrap().entry_id, \"medium\");",
      "context": [
        "            memory_size: 1024,",
        "        });",
        "",
        "        // Should pop in order: low (1.0), medium (5.0), high (10.0)",
        "        assert_eq!(heap.pop().unwrap().entry_id, \"low\");",
        "        assert_eq!(heap.pop().unwrap().entry_id, \"medium\");",
        "        assert_eq!(heap.pop().unwrap().entry_id, \"high\");",
        "    }",
        "",
        "    #[test]",
        "    fn test_memory_compactor() {"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/memory/optimization.rs",
      "line": 382,
      "code": "assert_eq!(heap.pop().unwrap().entry_id, \"high\");",
      "context": [
        "        });",
        "",
        "        // Should pop in order: low (1.0), medium (5.0), high (10.0)",
        "        assert_eq!(heap.pop().unwrap().entry_id, \"low\");",
        "        assert_eq!(heap.pop().unwrap().entry_id, \"medium\");",
        "        assert_eq!(heap.pop().unwrap().entry_id, \"high\");",
        "    }",
        "",
        "    #[test]",
        "    fn test_memory_compactor() {",
        "        let compactor = MemoryCompactor::new(0.3);"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/memory/tensor.rs",
      "line": 328,
      "code": "memory.store_pattern(pattern.clone()).unwrap();",
      "context": [
        "    #[test]",
        "    fn test_pattern_storage_and_retrieval() {",
        "        let memory = TensorMemory::new(100);",
        "",
        "        let pattern = create_test_pattern(\"test-1\", \"docker\");",
        "        memory.store_pattern(pattern.clone()).unwrap();",
        "",
        "        let results = memory.find_similar(&pattern, 0.9, 10).unwrap();",
        "        assert_eq!(results.len(), 1);",
        "        assert_eq!(results[0].pattern_id, \"test-1\");",
        "        assert!(results[0].similarity_score >= 0.99);"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/memory/tensor.rs",
      "line": 341,
      "code": "memory.store_pattern(create_test_pattern(\"docker-1\", \"docker\")).unwrap();",
      "context": [
        "    #[test]",
        "    fn test_similarity_search() {",
        "        let memory = TensorMemory::new(100);",
        "",
        "        // Store multiple patterns",
        "        memory.store_pattern(create_test_pattern(\"docker-1\", \"docker\")).unwrap();",
        "        memory.store_pattern(create_test_pattern(\"docker-2\", \"docker\")).unwrap();",
        "        memory.store_pattern(create_test_pattern(\"kubectl-1\", \"kubectl\")).unwrap();",
        "",
        "        // Search for similar docker commands",
        "        let query = create_test_pattern(\"query\", \"docker\");"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/memory/graph.rs",
      "line": 428,
      "code": "let dependents = graph.find_dependents(\"build\").unwrap();",
      "context": [
        "        // Check dependencies",
        "        let deps = graph.find_dependencies(\"push\").unwrap();",
        "        assert_eq!(deps.len(), 1);",
        "        assert_eq!(deps[0].0, \"build\");",
        "",
        "        let dependents = graph.find_dependents(\"build\").unwrap();",
        "        assert_eq!(dependents.len(), 1);",
        "        assert_eq!(dependents[0].0, \"push\");",
        "    }",
        "",
        "    #[test]"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/memory/graph.rs",
      "line": 447,
      "code": "let order = graph.find_execution_order(&commands.iter().map(|s| s.to_string()).collect::<Vec<_>>()).unwrap();",
      "context": [
        "        }",
        "",
        "        graph.add_dependency(\"build\", \"test\", DependencyType::Sequential, 1.0).unwrap();",
        "        graph.add_dependency(\"test\", \"deploy\", DependencyType::Sequential, 1.0).unwrap();",
        "",
        "        let order = graph.find_execution_order(&commands.iter().map(|s| s.to_string()).collect::<Vec<_>>()).unwrap();",
        "        assert_eq!(order, vec![\"build\", \"test\", \"deploy\"]);",
        "    }",
        "",
        "    #[test]",
        "    fn test_resource_conflict_detection() {"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/testing/mod.rs",
      "line": 565,
      "code": "let avg_usage = monitor.get_average_usage().unwrap();",
      "context": [
        "            timestamp: chrono::Utc::now(),",
        "        };",
        "",
        "        monitor.record_usage(usage.clone());",
        "",
        "        let avg_usage = monitor.get_average_usage().unwrap();",
        "        assert_eq!(avg_usage.memory_mb, 100.0);",
        "        assert_eq!(avg_usage.cpu_percent, 50.0);",
        "    }",
        "",
        "    #[test]"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/network/load_balancer.rs",
      "line": 460,
      "code": "let selected3 = lb.select_backend(None).unwrap();",
      "context": [
        "",
        "        // Release one connection",
        "        lb.release_connection(selected1.id, true);",
        "",
        "        // Next selection should go to the first backend again",
        "        let selected3 = lb.select_backend(None).unwrap();",
        "        assert_eq!(selected3.id, selected1.id);",
        "    }",
        "",
        "    #[test]",
        "    fn test_ip_hash() {"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex_bash_god/learning_system.rs",
      "line": 711,
      "code": "let system = LearningSystem::new(LearningConfig::default()).unwrap();",
      "context": [
        "mod tests {",
        "    use super::*;",
        "",
        "    #[test]",
        "    fn test_pattern_extraction() {",
        "        let system = LearningSystem::new(LearningConfig::default()).unwrap();",
        "",
        "        let patterns = futures::executor::block_on(",
        "            system.extract_patterns(\"ls -la | grep test && echo 'Done'\")",
        "        ).unwrap();",
        ""
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex_bash_god/learning_system.rs",
      "line": 723,
      "code": "let system = LearningSystem::new(LearningConfig::default()).unwrap();",
      "context": [
        "        assert!(patterns.iter().any(|p| p.contains(\"LIST_CMD | FILTER_CMD\")));",
        "    }",
        "",
        "    #[test]",
        "    fn test_command_type_detection() {",
        "        let system = LearningSystem::new(LearningConfig::default()).unwrap();",
        "",
        "        assert_eq!(system.get_command_type(\"ls -la\"), \"LIST_CMD\");",
        "        assert_eq!(system.get_command_type(\"grep pattern\"), \"FILTER_CMD\");",
        "        assert_eq!(system.get_command_type(\"echo hello\"), \"OUTPUT_CMD\");",
        "    }"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex_bash_god/command_chain.rs",
      "line": 571,
      "code": "let chain = CommandChain::from_string(input).unwrap();",
      "context": [
        "    }",
        "",
        "    #[test]",
        "    fn test_parse_complex_chain() {",
        "        let input = \"VAR=value ls -la | grep test && echo 'Done' || echo 'Failed'\";",
        "        let chain = CommandChain::from_string(input).unwrap();",
        "        assert_eq!(chain.env_vars.len(), 1);",
        "        assert_eq!(chain.env_vars[0], (\"VAR\".to_string(), \"value\".to_string()));",
        "    }",
        "}"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/circle_of_experts/test_module.rs",
      "line": 47,
      "code": "let consensus = result.unwrap();",
      "context": [
        "",
        "        let config = Arc::new(CircleConfig::default());",
        "        let result = process_expert_responses(responses, config);",
        "",
        "        assert!(result.is_ok());",
        "        let consensus = result.unwrap();",
        "        assert!(!consensus.consensus_text.is_empty());",
        "        assert!(consensus.confidence_score > 0.0 && consensus.confidence_score <= 1.0);",
        "    }",
        "",
        "    #[test]"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/learning_engine/optimizer.rs",
      "line": 740,
      "code": "let optimizer = ChainOptimizer::new(config).unwrap();",
      "context": [
        "    use super::*;",
        "",
        "    #[test]",
        "    fn test_chain_optimization() {",
        "        let config = OptimizerConfig::default();",
        "        let optimizer = ChainOptimizer::new(config).unwrap();",
        "",
        "        let commands = vec![",
        "            \"npm install\".to_string(),",
        "            \"npm run build\".to_string(),",
        "            \"npm test\".to_string(),"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/learning_engine/optimizer.rs",
      "line": 757,
      "code": "let optimizer = ChainOptimizer::new(config).unwrap();",
      "context": [
        "    }",
        "",
        "    #[test]",
        "    fn test_parallel_optimization() {",
        "        let config = OptimizerConfig::default();",
        "        let optimizer = ChainOptimizer::new(config).unwrap();",
        "",
        "        let commands = vec![",
        "            \"curl -o file1.txt https://example.com/1\".to_string(),",
        "            \"curl -o file2.txt https://example.com/2\".to_string(),",
        "            \"curl -o file3.txt https://example.com/3\".to_string(),"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/learning_engine/pattern_detector.rs",
      "line": 609,
      "code": "let detector = PatternDetector::new(config).unwrap();",
      "context": [
        "    use super::*;",
        "",
        "    #[test]",
        "    fn test_pattern_detection() {",
        "        let config = PatternDetectorConfig::default();",
        "        let detector = PatternDetector::new(config).unwrap();",
        "",
        "        let pattern = CommandPattern {",
        "            commands: vec![\"make build\".to_string(), \"make test\".to_string()],",
        "            execution_time_ms: 5000,",
        "            success_rate: 0.95,"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/learning_engine/pattern_detector.rs",
      "line": 634,
      "code": "let detected = detector.detect_patterns(&commands).unwrap();",
      "context": [
        "        };",
        "",
        "        detector.record_pattern(pattern).unwrap();",
        "",
        "        let commands = vec![\"make build\".to_string(), \"make test\".to_string()];",
        "        let detected = detector.detect_patterns(&commands).unwrap();",
        "",
        "        assert!(!detected.is_empty());",
        "    }",
        "",
        "    #[test]"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/learning_engine/pattern_detector.rs",
      "line": 642,
      "code": "let detector = PatternDetector::new(config).unwrap();",
      "context": [
        "    }",
        "",
        "    #[test]",
        "    fn test_parallelization_detection() {",
        "        let config = PatternDetectorConfig::default();",
        "        let detector = PatternDetector::new(config).unwrap();",
        "",
        "        let commands = vec![",
        "            \"npm install\".to_string(),",
        "            \"pip install -r requirements.txt\".to_string(),",
        "            \"cargo build\".to_string(),"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/learning_engine/predictor.rs",
      "line": 778,
      "code": "let predictor = ChainPredictor::new(config).unwrap();",
      "context": [
        "    use super::*;",
        "",
        "    #[test]",
        "    fn test_prediction() {",
        "        let config = PredictorConfig::default();",
        "        let predictor = ChainPredictor::new(config).unwrap();",
        "",
        "        let commands = vec![",
        "            \"make build\".to_string(),",
        "            \"make test\".to_string(),",
        "            \"make deploy\".to_string(),"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/learning_engine/predictor.rs",
      "line": 796,
      "code": "let predictor = ChainPredictor::new(config).unwrap();",
      "context": [
        "    }",
        "",
        "    #[test]",
        "    fn test_feature_extraction() {",
        "        let config = PredictorConfig::default();",
        "        let predictor = ChainPredictor::new(config).unwrap();",
        "",
        "        let commands = vec![",
        "            \"npm install\".to_string(),",
        "            \"npm run build\".to_string(),",
        "            \"npm test\".to_string(),"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex_bashgod/tests.rs",
      "line": 89,
      "code": "let serialized = serde_json::to_string(&strategy).unwrap();",
      "context": [
        "            ExecutionStrategy::Optimized,",
        "            ExecutionStrategy::Predictive,",
        "        ];",
        "",
        "        for strategy in strategies {",
        "            let serialized = serde_json::to_string(&strategy).unwrap();",
        "            let deserialized: ExecutionStrategy = serde_json::from_str(&serialized).unwrap();",
        "            assert_eq!(format!(\"{:?}\", strategy), format!(\"{:?}\", deserialized));",
        "        }",
        "    }",
        "}"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex_bashgod/tests.rs",
      "line": 90,
      "code": "let deserialized: ExecutionStrategy = serde_json::from_str(&serialized).unwrap();",
      "context": [
        "            ExecutionStrategy::Predictive,",
        "        ];",
        "",
        "        for strategy in strategies {",
        "            let serialized = serde_json::to_string(&strategy).unwrap();",
        "            let deserialized: ExecutionStrategy = serde_json::from_str(&serialized).unwrap();",
        "            assert_eq!(format!(\"{:?}\", strategy), format!(\"{:?}\", deserialized));",
        "        }",
        "    }",
        "}",
        ""
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex_bashgod/tests.rs",
      "line": 111,
      "code": "let service = create_bashgod_service(config).await.unwrap();",
      "context": [
        "    }",
        "",
        "    #[tokio::test]",
        "    async fn test_simple_command_execution() {",
        "        let config = BashGodConfig::default();",
        "        let service = create_bashgod_service(config).await.unwrap();",
        "",
        "        let chain = CommandChain {",
        "            id: \"test-chain\".to_string(),",
        "            commands: vec![",
        "                BashCommand {"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex_bashgod/tests.rs",
      "line": 139,
      "code": "let chain_result = result.unwrap();",
      "context": [
        "        };",
        "",
        "        let result = service.execute_chain(chain).await;",
        "        assert!(result.is_ok());",
        "",
        "        let chain_result = result.unwrap();",
        "        assert!(chain_result.success);",
        "        assert_eq!(chain_result.command_results.len(), 1);",
        "    }",
        "",
        "    #[tokio::test]"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex_bashgod/tests.rs",
      "line": 146,
      "code": "let service = create_bashgod_service(BashGodConfig::default()).await.unwrap();",
      "context": [
        "        assert_eq!(chain_result.command_results.len(), 1);",
        "    }",
        "",
        "    #[tokio::test]",
        "    async fn test_chain_optimization() {",
        "        let service = create_bashgod_service(BashGodConfig::default()).await.unwrap();",
        "",
        "        let chain = CommandChain {",
        "            id: \"optimize-test\".to_string(),",
        "            commands: vec![",
        "                BashCommand {"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex_bashgod/tests.rs",
      "line": 185,
      "code": "let service = create_bashgod_service(BashGodConfig::default()).await.unwrap();",
      "context": [
        "        assert!(optimized.is_ok());",
        "    }",
        "",
        "    #[tokio::test]",
        "    async fn test_learning_insights() {",
        "        let service = create_bashgod_service(BashGodConfig::default()).await.unwrap();",
        "",
        "        let insights = service.get_insights().await;",
        "        assert!(insights.is_ok());",
        "",
        "        // Initially should be empty"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex_bashgod/tests.rs",
      "line": 191,
      "code": "assert_eq!(insights.unwrap().len(), 0);",
      "context": [
        "",
        "        let insights = service.get_insights().await;",
        "        assert!(insights.is_ok());",
        "",
        "        // Initially should be empty",
        "        assert_eq!(insights.unwrap().len(), 0);",
        "    }",
        "}",
        "",
        "#[cfg(test)]",
        "mod memory_tests {"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex_bashgod/tests.rs",
      "line": 212,
      "code": "assert!(!similar.unwrap().is_empty());",
      "context": [
        "        let stored = memory.store_pattern(pattern_id, pattern.clone()).await;",
        "        assert!(stored.is_ok());",
        "",
        "        let similar = memory.find_similar(&pattern, 5).await;",
        "        assert!(similar.is_ok());",
        "        assert!(!similar.unwrap().is_empty());",
        "    }",
        "",
        "    #[tokio::test]",
        "    async fn test_graph_memory() {",
        "        let memory = GraphMemory::new();"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex_bashgod/tests.rs",
      "line": 227,
      "code": "}).await.unwrap();",
      "context": [
        "            command: \"echo\".to_string(),",
        "            args: vec![\"test\".to_string()],",
        "            env: HashMap::new(),",
        "            working_dir: None,",
        "            resources: ResourceEstimate::default(),",
        "        }).await.unwrap();",
        "",
        "        memory.add_command_node(\"cmd2\", &BashCommand {",
        "            id: \"cmd2\".to_string(),",
        "            command: \"grep\".to_string(),",
        "            args: vec![\"pattern\".to_string()],"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex_bashgod/tests.rs",
      "line": 236,
      "code": "}).await.unwrap();",
      "context": [
        "            command: \"grep\".to_string(),",
        "            args: vec![\"pattern\".to_string()],",
        "            env: HashMap::new(),",
        "            working_dir: None,",
        "            resources: ResourceEstimate::default(),",
        "        }).await.unwrap();",
        "",
        "        // Add dependency",
        "        memory.add_dependency(\"cmd1\", \"cmd2\").await.unwrap();",
        "",
        "        // Find dependencies"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex_bashgod/tests.rs",
      "line": 239,
      "code": "memory.add_dependency(\"cmd1\", \"cmd2\").await.unwrap();",
      "context": [
        "            working_dir: None,",
        "            resources: ResourceEstimate::default(),",
        "        }).await.unwrap();",
        "",
        "        // Add dependency",
        "        memory.add_dependency(\"cmd1\", \"cmd2\").await.unwrap();",
        "",
        "        // Find dependencies",
        "        let deps = memory.find_dependencies(\"cmd1\").await.unwrap();",
        "        assert_eq!(deps.len(), 1);",
        "        assert_eq!(deps[0], \"cmd2\");"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex_bashgod/tests.rs",
      "line": 242,
      "code": "let deps = memory.find_dependencies(\"cmd1\").await.unwrap();",
      "context": [
        "",
        "        // Add dependency",
        "        memory.add_dependency(\"cmd1\", \"cmd2\").await.unwrap();",
        "",
        "        // Find dependencies",
        "        let deps = memory.find_dependencies(\"cmd1\").await.unwrap();",
        "        assert_eq!(deps.len(), 1);",
        "        assert_eq!(deps[0], \"cmd2\");",
        "    }",
        "",
        "    #[tokio::test]"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex_bashgod/tests.rs",
      "line": 309,
      "code": "let synergies = detector.detect(&commands, &context).await.unwrap();",
      "context": [
        "                max_memory_mb: None,",
        "                atomic_required: false,",
        "            },",
        "        };",
        "",
        "        let synergies = detector.detect(&commands, &context).await.unwrap();",
        "        assert!(!synergies.is_empty());",
        "",
        "        // Should detect pipeline synergy",
        "        let pipeline_synergy = synergies.iter()",
        "            .find(|s| matches!(s.synergy_type, synergy::SynergyType::DataPipeline))"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex_bashgod/tests.rs",
      "line": 365,
      "code": "let result = optimizer.optimize(commands, vec![synergy], &context).await.unwrap();",
      "context": [
        "                max_memory_mb: None,",
        "                atomic_required: false,",
        "            },",
        "        };",
        "",
        "        let result = optimizer.optimize(commands, vec![synergy], &context).await.unwrap();",
        "        assert!(result.success);",
        "        assert_eq!(result.optimized.len(), 1); // Should merge into single pipeline",
        "        assert!(result.optimized[0].contains(\"|\"));",
        "    }",
        "}"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex_bashgod/tests.rs",
      "line": 404,
      "code": "let enhanced = enhancer.enhance(&cmd, &config).await.unwrap();",
      "context": [
        "            },",
        "            enable_caching: true,",
        "            cache_ttl: 300,",
        "        };",
        "",
        "        let enhanced = enhancer.enhance(&cmd, &config).await.unwrap();",
        "        assert!(enhanced.mcp_tool.is_some());",
        "        assert!(enhanced.performance_estimate.speedup > 1.0);",
        "    }",
        "",
        "    #[tokio::test]"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex_bashgod/tests.rs",
      "line": 440,
      "code": "}).await.unwrap();",
      "context": [
        "    #[tokio::test]",
        "    async fn test_concurrent_execution_performance() {",
        "        let service = create_bashgod_service(BashGodConfig {",
        "            executor_pool_size: 8,",
        "            ..Default::default()",
        "        }).await.unwrap();",
        "",
        "        // Create chain with multiple independent commands",
        "        let mut commands = Vec::new();",
        "        for i in 0..10 {",
        "            commands.push(BashCommand {"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex_bashgod/tests.rs",
      "line": 470,
      "code": "let result = service.execute_chain(chain).await.unwrap();",
      "context": [
        "                created_at: chrono::Utc::now(),",
        "            },",
        "        };",
        "",
        "        let start = Instant::now();",
        "        let result = service.execute_chain(chain).await.unwrap();",
        "        let duration = start.elapsed();",
        "",
        "        assert!(result.success);",
        "        assert_eq!(result.command_results.len(), 10);",
        ""
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex_bashgod/tests.rs",
      "line": 489,
      "code": "memory.store_pattern(&format!(\"pattern-{}\", i), pattern).await.unwrap();",
      "context": [
        "        let start = Instant::now();",
        "",
        "        // Store many patterns",
        "        for i in 0..1000 {",
        "            let pattern: Vec<f32> = (0..128).map(|j| (i * j) as f32).collect();",
        "            memory.store_pattern(&format!(\"pattern-{}\", i), pattern).await.unwrap();",
        "        }",
        "",
        "        let store_duration = start.elapsed();",
        "",
        "        // Search for similar patterns"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex_bashgod/tests.rs",
      "line": 497,
      "code": "let similar = memory.find_similar(&search_pattern, 10).await.unwrap();",
      "context": [
        "        let store_duration = start.elapsed();",
        "",
        "        // Search for similar patterns",
        "        let search_pattern: Vec<f32> = (0..128).map(|j| j as f32 * 500.0).collect();",
        "        let search_start = Instant::now();",
        "        let similar = memory.find_similar(&search_pattern, 10).await.unwrap();",
        "        let search_duration = search_start.elapsed();",
        "",
        "        assert_eq!(similar.len(), 10);",
        "        assert!(store_duration.as_millis() < 5000); // Should store 1000 patterns in < 5s",
        "        assert!(search_duration.as_millis() < 100); // Should search in < 100ms"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex_bashgod/tests.rs",
      "line": 512,
      "code": "let service = create_bashgod_service(BashGodConfig::default()).await.unwrap();",
      "context": [
        "mod error_handling_tests {",
        "    use super::*;",
        "",
        "    #[tokio::test]",
        "    async fn test_invalid_command_handling() {",
        "        let service = create_bashgod_service(BashGodConfig::default()).await.unwrap();",
        "",
        "        let chain = CommandChain {",
        "            id: \"error-test\".to_string(),",
        "            commands: vec![",
        "                BashCommand {"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex_bashgod/tests.rs",
      "line": 538,
      "code": "assert!(result.is_err() || !result.unwrap().success);",
      "context": [
        "                created_at: chrono::Utc::now(),",
        "            },",
        "        };",
        "",
        "        let result = service.execute_chain(chain).await;",
        "        assert!(result.is_err() || !result.unwrap().success);",
        "    }",
        "",
        "    #[tokio::test]",
        "    async fn test_resource_limit_enforcement() {",
        "        let service = create_bashgod_service(BashGodConfig::default()).await.unwrap();"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex_bashgod/tests.rs",
      "line": 543,
      "code": "let service = create_bashgod_service(BashGodConfig::default()).await.unwrap();",
      "context": [
        "        assert!(result.is_err() || !result.unwrap().success);",
        "    }",
        "",
        "    #[tokio::test]",
        "    async fn test_resource_limit_enforcement() {",
        "        let service = create_bashgod_service(BashGodConfig::default()).await.unwrap();",
        "",
        "        let chain = CommandChain {",
        "            id: \"resource-test\".to_string(),",
        "            commands: vec![",
        "                BashCommand {"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex_bashgod/tests.rs",
      "line": 576,
      "code": "assert!(result.is_err() || !result.unwrap().success);",
      "context": [
        "            },",
        "        };",
        "",
        "        let result = service.execute_chain(chain).await;",
        "        // Should either fail or handle gracefully",
        "        assert!(result.is_err() || !result.unwrap().success);",
        "    }",
        "}"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex_bashgod/python_bindings.rs",
      "line": 587,
      "code": "let module = PyModule::new(py, \"test_synthex_bashgod\").unwrap();",
      "context": [
        "    #[test]",
        "    fn test_python_module() {",
        "        pyo3::prepare_freethreaded_python();",
        "",
        "        Python::with_gil(|py| {",
        "            let module = PyModule::new(py, \"test_synthex_bashgod\").unwrap();",
        "            synthex_bashgod(py, module).unwrap();",
        "",
        "            assert!(module.hasattr(\"PySynthexBashGod\").unwrap());",
        "            assert!(module.hasattr(\"__version__\").unwrap());",
        "        });"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/test_compilation.rs",
      "line": 26,
      "code": "let runtime = tokio::runtime::Runtime::new().unwrap();",
      "context": [
        "    }",
        "",
        "    #[test]",
        "    fn test_create_engine() {",
        "        // This will test that SynthexEngine can be created",
        "        let runtime = tokio::runtime::Runtime::new().unwrap();",
        "        let config = SynthexConfig::default();",
        "",
        "        runtime.block_on(async {",
        "            let result = SynthexEngine::new(config).await;",
        "            assert!(result.is_ok());"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/fusion/tool_enhancer.rs",
      "line": 545,
      "code": "let params = extract_docker_params(\"docker ps -a\", \"list_containers\").unwrap();",
      "context": [
        "        assert!(estimate.mcp_enhanced_ms < estimate.bash_only_ms);",
        "    }",
        "",
        "    #[test]",
        "    fn test_extract_docker_params() {",
        "        let params = extract_docker_params(\"docker ps -a\", \"list_containers\").unwrap();",
        "        assert_eq!(params[\"all\"], true);",
        "",
        "        let params = extract_docker_params(\"docker run -d nginx\", \"run_container\").unwrap();",
        "        assert_eq!(params[\"image\"], \"nginx\");",
        "        assert_eq!(params[\"detached\"], true);"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/fusion/tool_enhancer.rs",
      "line": 548,
      "code": "let params = extract_docker_params(\"docker run -d nginx\", \"run_container\").unwrap();",
      "context": [
        "    #[test]",
        "    fn test_extract_docker_params() {",
        "        let params = extract_docker_params(\"docker ps -a\", \"list_containers\").unwrap();",
        "        assert_eq!(params[\"all\"], true);",
        "",
        "        let params = extract_docker_params(\"docker run -d nginx\", \"run_container\").unwrap();",
        "        assert_eq!(params[\"image\"], \"nginx\");",
        "        assert_eq!(params[\"detached\"], true);",
        "    }",
        "}"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/protocols/mod.rs",
      "line": 283,
      "code": "let deserialized: MessageType = serde_json::from_str(&json).unwrap();",
      "context": [
        "            method: \"test\".to_string(),",
        "            params: serde_json::json!({\"key\": \"value\"}),",
        "        };",
        "",
        "        let json = serde_json::to_string(&request).unwrap();",
        "        let deserialized: MessageType = serde_json::from_str(&json).unwrap();",
        "",
        "        assert_eq!(request, deserialized);",
        "    }",
        "",
        "    #[test]"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/stress_tests.rs",
      "line": 23,
      "code": "manager.register_server(server).await.unwrap();",
      "context": [
        "    let manager = Arc::new(MCPManager::new(config));",
        "",
        "    // Register multiple servers",
        "    for i in 0..10 {",
        "        let server = create_mock_server(&format!(\"stress_server_{}\", i));",
        "        manager.register_server(server).await.unwrap();",
        "    }",
        "",
        "    // Metrics tracking",
        "    let total_requests = Arc::new(AtomicU64::new(0));",
        "    let successful_requests = Arc::new(AtomicU64::new(0));"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/stress_tests.rs",
      "line": 119,
      "code": "manager.register_server(server).await.unwrap();",
      "context": [
        "    let manager = Arc::new(MCPManager::new(config));",
        "",
        "    // Register servers",
        "    for i in 0..5 {",
        "        let server = create_mock_server(&format!(\"sustained_{}\", i));",
        "        manager.register_server(server).await.unwrap();",
        "    }",
        "",
        "    // Memory tracking",
        "    let memory_samples = Arc::new(tokio::sync::Mutex::new(Vec::new()));",
        "    let should_stop = Arc::new(AtomicBool::new(false));"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/stress_tests.rs",
      "line": 258,
      "code": "manager.register_server(server).await.unwrap();",
      "context": [
        "    let manager = Arc::new(MCPManager::new(config));",
        "",
        "    // Register many servers",
        "    for i in 0..20 {",
        "        let server = create_mock_server(&format!(\"memory_test_{}\", i));",
        "        manager.register_server(server).await.unwrap();",
        "    }",
        "",
        "    // Track memory allocations",
        "    let large_payloads_sent = Arc::new(AtomicU64::new(0));",
        ""
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/stress_tests.rs",
      "line": 329,
      "code": "manager.register_server(server).await.unwrap();",
      "context": [
        "    let primary_servers = 3;",
        "    let backup_servers = 2;",
        "",
        "    for i in 0..primary_servers {",
        "        let server = create_mock_server(&format!(\"primary_{}\", i));",
        "        manager.register_server(server).await.unwrap();",
        "    }",
        "",
        "    for i in 0..backup_servers {",
        "        let server = create_mock_server(&format!(\"backup_{}\", i));",
        "        manager.register_server(server).await.unwrap();"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/stress_tests.rs",
      "line": 334,
      "code": "manager.register_server(server).await.unwrap();",
      "context": [
        "        manager.register_server(server).await.unwrap();",
        "    }",
        "",
        "    for i in 0..backup_servers {",
        "        let server = create_mock_server(&format!(\"backup_{}\", i));",
        "        manager.register_server(server).await.unwrap();",
        "    }",
        "",
        "    // Chaos injector for cascade failures",
        "    let chaos = Arc::new(ChaosInjector::new());",
        ""
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/stress_tests.rs",
      "line": 431,
      "code": "manager.register_server(server).await.unwrap();",
      "context": [
        "    let manager = Arc::new(MCPManager::new(config));",
        "",
        "    // Register servers",
        "    for i in 0..5 {",
        "        let server = create_mock_server(&format!(\"extreme_{}\", i));",
        "        manager.register_server(server).await.unwrap();",
        "    }",
        "",
        "    // Extreme concurrency parameters",
        "    let concurrent_requests = 10000;",
        "    let burst_duration = Duration::from_secs(1);"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/unit_tests.rs",
      "line": 207,
      "code": "let error = response.error.unwrap();",
      "context": [
        "        let response = MCPResponse::error(-32600, \"Invalid request\");",
        "",
        "        assert!(response.result.is_none());",
        "        assert!(response.error.is_some());",
        "",
        "        let error = response.error.unwrap();",
        "        assert_eq!(error.code, -32600);",
        "        assert_eq!(error.message, \"Invalid request\");",
        "    }",
        "",
        "    #[test]"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/unit_tests.rs",
      "line": 260,
      "code": "registry.register(server1.clone()).unwrap();",
      "context": [
        "            \"http://localhost:8002\".to_string(),",
        "            MCPProtocol::Http,",
        "            HashMap::new(),",
        "        );",
        "",
        "        registry.register(server1.clone()).unwrap();",
        "        registry.register(server2.clone()).unwrap();",
        "",
        "        // Test retrieval",
        "        assert_eq!(registry.get_all().len(), 2);",
        "        assert!(registry.get(\"server1\").is_some());"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/unit_tests.rs",
      "line": 261,
      "code": "registry.register(server2.clone()).unwrap();",
      "context": [
        "            MCPProtocol::Http,",
        "            HashMap::new(),",
        "        );",
        "",
        "        registry.register(server1.clone()).unwrap();",
        "        registry.register(server2.clone()).unwrap();",
        "",
        "        // Test retrieval",
        "        assert_eq!(registry.get_all().len(), 2);",
        "        assert!(registry.get(\"server1\").is_some());",
        "        assert!(registry.get(\"server2\").is_some());"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/unit_tests.rs",
      "line": 273,
      "code": "registry.unregister(\"server1\").unwrap();",
      "context": [
        "        // Test duplicate registration",
        "        let result = registry.register(server1.clone());",
        "        assert!(result.is_err());",
        "",
        "        // Test removal",
        "        registry.unregister(\"server1\").unwrap();",
        "        assert_eq!(registry.get_all().len(), 1);",
        "        assert!(registry.get(\"server1\").is_none());",
        "",
        "        // Test removing non-existent",
        "        let result = registry.unregister(\"nonexistent\");"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/unit_tests.rs",
      "line": 311,
      "code": "registry.register(healthy).unwrap();",
      "context": [
        "            MCPProtocol::Http,",
        "            HashMap::new(),",
        "        );",
        "        degraded.set_state(ServerState::Degraded);",
        "",
        "        registry.register(healthy).unwrap();",
        "        registry.register(unhealthy).unwrap();",
        "        registry.register(degraded).unwrap();",
        "",
        "        // Test health filtering",
        "        let healthy_servers = registry.get_healthy_servers();"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/unit_tests.rs",
      "line": 312,
      "code": "registry.register(unhealthy).unwrap();",
      "context": [
        "            HashMap::new(),",
        "        );",
        "        degraded.set_state(ServerState::Degraded);",
        "",
        "        registry.register(healthy).unwrap();",
        "        registry.register(unhealthy).unwrap();",
        "        registry.register(degraded).unwrap();",
        "",
        "        // Test health filtering",
        "        let healthy_servers = registry.get_healthy_servers();",
        "        assert_eq!(healthy_servers.len(), 1);"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/unit_tests.rs",
      "line": 313,
      "code": "registry.register(degraded).unwrap();",
      "context": [
        "        );",
        "        degraded.set_state(ServerState::Degraded);",
        "",
        "        registry.register(healthy).unwrap();",
        "        registry.register(unhealthy).unwrap();",
        "        registry.register(degraded).unwrap();",
        "",
        "        // Test health filtering",
        "        let healthy_servers = registry.get_healthy_servers();",
        "        assert_eq!(healthy_servers.len(), 1);",
        "        assert_eq!(healthy_servers[0].id(), \"healthy\");"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/unit_tests.rs",
      "line": 378,
      "code": "assert!(p50.unwrap().as_millis() >= 25 && p50.unwrap().as_millis() <= 35);",
      "context": [
        "        assert!(p50.is_some());",
        "        assert!(p95.is_some());",
        "        assert!(p99.is_some());",
        "",
        "        // p50 should be around 30ms",
        "        assert!(p50.unwrap().as_millis() >= 25 && p50.unwrap().as_millis() <= 35);",
        "",
        "        // Percentiles should be ordered",
        "        assert!(p50.unwrap() <= p95.unwrap());",
        "        assert!(p95.unwrap() <= p99.unwrap());",
        "    }"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/unit_tests.rs",
      "line": 381,
      "code": "assert!(p50.unwrap() <= p95.unwrap());",
      "context": [
        "",
        "        // p50 should be around 30ms",
        "        assert!(p50.unwrap().as_millis() >= 25 && p50.unwrap().as_millis() <= 35);",
        "",
        "        // Percentiles should be ordered",
        "        assert!(p50.unwrap() <= p95.unwrap());",
        "        assert!(p95.unwrap() <= p99.unwrap());",
        "    }",
        "",
        "    #[test]",
        "    fn test_metrics_reset() {"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/unit_tests.rs",
      "line": 382,
      "code": "assert!(p95.unwrap() <= p99.unwrap());",
      "context": [
        "        // p50 should be around 30ms",
        "        assert!(p50.unwrap().as_millis() >= 25 && p50.unwrap().as_millis() <= 35);",
        "",
        "        // Percentiles should be ordered",
        "        assert!(p50.unwrap() <= p95.unwrap());",
        "        assert!(p95.unwrap() <= p99.unwrap());",
        "    }",
        "",
        "    #[test]",
        "    fn test_metrics_reset() {",
        "        let metrics = MCPMetrics::new();"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/unit_tests.rs",
      "line": 422,
      "code": "let s1 = lb.select_server_sync(&servers).unwrap();",
      "context": [
        "        ];",
        "",
        "        let lb = LoadBalancer::new(strategy);",
        "",
        "        // Should cycle through servers",
        "        let s1 = lb.select_server_sync(&servers).unwrap();",
        "        let s2 = lb.select_server_sync(&servers).unwrap();",
        "        let s3 = lb.select_server_sync(&servers).unwrap();",
        "        let s4 = lb.select_server_sync(&servers).unwrap();",
        "",
        "        assert_eq!(s1.id(), \"server1\");"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/unit_tests.rs",
      "line": 423,
      "code": "let s2 = lb.select_server_sync(&servers).unwrap();",
      "context": [
        "",
        "        let lb = LoadBalancer::new(strategy);",
        "",
        "        // Should cycle through servers",
        "        let s1 = lb.select_server_sync(&servers).unwrap();",
        "        let s2 = lb.select_server_sync(&servers).unwrap();",
        "        let s3 = lb.select_server_sync(&servers).unwrap();",
        "        let s4 = lb.select_server_sync(&servers).unwrap();",
        "",
        "        assert_eq!(s1.id(), \"server1\");",
        "        assert_eq!(s2.id(), \"server2\");"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/unit_tests.rs",
      "line": 424,
      "code": "let s3 = lb.select_server_sync(&servers).unwrap();",
      "context": [
        "        let lb = LoadBalancer::new(strategy);",
        "",
        "        // Should cycle through servers",
        "        let s1 = lb.select_server_sync(&servers).unwrap();",
        "        let s2 = lb.select_server_sync(&servers).unwrap();",
        "        let s3 = lb.select_server_sync(&servers).unwrap();",
        "        let s4 = lb.select_server_sync(&servers).unwrap();",
        "",
        "        assert_eq!(s1.id(), \"server1\");",
        "        assert_eq!(s2.id(), \"server2\");",
        "        assert_eq!(s3.id(), \"server3\");"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/unit_tests.rs",
      "line": 425,
      "code": "let s4 = lb.select_server_sync(&servers).unwrap();",
      "context": [
        "",
        "        // Should cycle through servers",
        "        let s1 = lb.select_server_sync(&servers).unwrap();",
        "        let s2 = lb.select_server_sync(&servers).unwrap();",
        "        let s3 = lb.select_server_sync(&servers).unwrap();",
        "        let s4 = lb.select_server_sync(&servers).unwrap();",
        "",
        "        assert_eq!(s1.id(), \"server1\");",
        "        assert_eq!(s2.id(), \"server2\");",
        "        assert_eq!(s3.id(), \"server3\");",
        "        assert_eq!(s4.id(), \"server1\"); // Cycles back"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/unit_tests.rs",
      "line": 450,
      "code": "let selected = lb.select_server_sync(&servers).unwrap();",
      "context": [
        "        servers[2].set_connection_count(8);",
        "",
        "        let lb = LoadBalancer::new(strategy);",
        "",
        "        // Should select server with least connections",
        "        let selected = lb.select_server_sync(&servers).unwrap();",
        "        assert_eq!(selected.id(), \"server2\");",
        "    }",
        "",
        "    #[test]",
        "    fn test_random_strategy() {"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/unit_tests.rs",
      "line": 468,
      "code": "let server = lb.select_server_sync(&servers).unwrap();",
      "context": [
        "        let lb = LoadBalancer::new(strategy);",
        "",
        "        // Should select random servers",
        "        let mut selections = HashMap::new();",
        "        for _ in 0..100 {",
        "            let server = lb.select_server_sync(&servers).unwrap();",
        "            *selections.entry(server.id().to_string()).or_insert(0) += 1;",
        "        }",
        "",
        "        // All servers should be selected at least once",
        "        assert_eq!(selections.len(), 3);"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/unit_tests.rs",
      "line": 493,
      "code": "let server = lb.select_server_sync(&servers).unwrap();",
      "context": [
        "        let lb = LoadBalancer::new(strategy);",
        "",
        "        // Count selections",
        "        let mut selections = HashMap::new();",
        "        for _ in 0..60 {",
        "            let server = lb.select_server_sync(&servers).unwrap();",
        "            *selections.entry(server.id().to_string()).or_insert(0) += 1;",
        "        }",
        "",
        "        // Selections should be proportional to weights",
        "        assert!(selections[\"server1\"] < selections[\"server2\"]);"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/security_tests.rs",
      "line": 27,
      "code": "let token = security_server.generate_token(\"user123\", Duration::from_secs(3600)).await.unwrap();",
      "context": [
        "    #[tokio::test]",
        "    async fn test_token_authentication() {",
        "        let security_server = SecurityServer::new(\"auth_server\");",
        "",
        "        // Generate token",
        "        let token = security_server.generate_token(\"user123\", Duration::from_secs(3600)).await.unwrap();",
        "        assert!(!token.is_empty());",
        "",
        "        // Validate token",
        "        let validation = security_server.validate_token(&token).await;",
        "        assert!(validation.is_ok());"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/security_tests.rs",
      "line": 34,
      "code": "let claims = validation.unwrap();",
      "context": [
        "",
        "        // Validate token",
        "        let validation = security_server.validate_token(&token).await;",
        "        assert!(validation.is_ok());",
        "",
        "        let claims = validation.unwrap();",
        "        assert_eq!(claims.subject, \"user123\");",
        "        assert!(claims.expiry > SystemTime::now());",
        "    }",
        "",
        "    #[tokio::test]"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/security_tests.rs",
      "line": 44,
      "code": "let token = security_server.generate_token(\"user123\", Duration::from_millis(100)).await.unwrap();",
      "context": [
        "    #[tokio::test]",
        "    async fn test_token_expiration() {",
        "        let security_server = SecurityServer::new(\"auth_server\");",
        "",
        "        // Generate short-lived token",
        "        let token = security_server.generate_token(\"user123\", Duration::from_millis(100)).await.unwrap();",
        "",
        "        // Should be valid immediately",
        "        assert!(security_server.validate_token(&token).await.is_ok());",
        "",
        "        // Wait for expiration"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/security_tests.rs",
      "line": 70,
      "code": ").await.unwrap();",
      "context": [
        "        // Configure mTLS",
        "        security_server.configure_mtls(",
        "            \"/path/to/ca.crt\",",
        "            \"/path/to/server.crt\",",
        "            \"/path/to/server.key\",",
        "        ).await.unwrap();",
        "",
        "        // Test client certificate validation",
        "        let valid_cert = include_bytes!(\"test_certs/valid_client.crt\");",
        "        let invalid_cert = include_bytes!(\"test_certs/invalid_client.crt\");",
        ""
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/security_tests.rs",
      "line": 89,
      "code": ").await.unwrap();",
      "context": [
        "        // Create API key",
        "        let api_key = security_server.create_api_key(",
        "            \"service_account_1\",",
        "            vec![\"read\", \"write\"],",
        "            Some(Duration::from_secs(86400)),",
        "        ).await.unwrap();",
        "",
        "        assert!(!api_key.is_empty());",
        "        assert!(api_key.len() >= 32); // Should be sufficiently long",
        "",
        "        // Validate API key"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/security_tests.rs",
      "line": 95,
      "code": "let validation = security_server.validate_api_key(&api_key).await.unwrap();",
      "context": [
        "",
        "        assert!(!api_key.is_empty());",
        "        assert!(api_key.len() >= 32); // Should be sufficiently long",
        "",
        "        // Validate API key",
        "        let validation = security_server.validate_api_key(&api_key).await.unwrap();",
        "        assert_eq!(validation.account, \"service_account_1\");",
        "        assert!(validation.permissions.contains(&\"read\".to_string()));",
        "        assert!(validation.permissions.contains(&\"write\".to_string()));",
        "",
        "        // Revoke API key"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/security_tests.rs",
      "line": 101,
      "code": "security_server.revoke_api_key(&api_key).await.unwrap();",
      "context": [
        "        assert_eq!(validation.account, \"service_account_1\");",
        "        assert!(validation.permissions.contains(&\"read\".to_string()));",
        "        assert!(validation.permissions.contains(&\"write\".to_string()));",
        "",
        "        // Revoke API key",
        "        security_server.revoke_api_key(&api_key).await.unwrap();",
        "",
        "        // Should no longer be valid",
        "        assert!(security_server.validate_api_key(&api_key).await.is_err());",
        "    }",
        "}"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/security_tests.rs",
      "line": 121,
      "code": "]).await.unwrap();",
      "context": [
        "        // Define roles",
        "        security_server.create_role(\"admin\", vec![",
        "            \"servers:*\",",
        "            \"config:*\",",
        "            \"metrics:read\",",
        "        ]).await.unwrap();",
        "",
        "        security_server.create_role(\"operator\", vec![",
        "            \"servers:read\",",
        "            \"servers:restart\",",
        "            \"metrics:read\","
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/security_tests.rs",
      "line": 127,
      "code": "]).await.unwrap();",
      "context": [
        "",
        "        security_server.create_role(\"operator\", vec![",
        "            \"servers:read\",",
        "            \"servers:restart\",",
        "            \"metrics:read\",",
        "        ]).await.unwrap();",
        "",
        "        security_server.create_role(\"viewer\", vec![",
        "            \"servers:read\",",
        "            \"metrics:read\",",
        "        ]).await.unwrap();"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/security_tests.rs",
      "line": 132,
      "code": "]).await.unwrap();",
      "context": [
        "        ]).await.unwrap();",
        "",
        "        security_server.create_role(\"viewer\", vec![",
        "            \"servers:read\",",
        "            \"metrics:read\",",
        "        ]).await.unwrap();",
        "",
        "        // Assign roles to users",
        "        security_server.assign_role(\"alice\", \"admin\").await.unwrap();",
        "        security_server.assign_role(\"bob\", \"operator\").await.unwrap();",
        "        security_server.assign_role(\"charlie\", \"viewer\").await.unwrap();"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/security_tests.rs",
      "line": 135,
      "code": "security_server.assign_role(\"alice\", \"admin\").await.unwrap();",
      "context": [
        "            \"servers:read\",",
        "            \"metrics:read\",",
        "        ]).await.unwrap();",
        "",
        "        // Assign roles to users",
        "        security_server.assign_role(\"alice\", \"admin\").await.unwrap();",
        "        security_server.assign_role(\"bob\", \"operator\").await.unwrap();",
        "        security_server.assign_role(\"charlie\", \"viewer\").await.unwrap();",
        "",
        "        // Test permissions",
        "        assert!(security_server.check_permission(\"alice\", \"servers:delete\").await.unwrap());"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/security_tests.rs",
      "line": 136,
      "code": "security_server.assign_role(\"bob\", \"operator\").await.unwrap();",
      "context": [
        "            \"metrics:read\",",
        "        ]).await.unwrap();",
        "",
        "        // Assign roles to users",
        "        security_server.assign_role(\"alice\", \"admin\").await.unwrap();",
        "        security_server.assign_role(\"bob\", \"operator\").await.unwrap();",
        "        security_server.assign_role(\"charlie\", \"viewer\").await.unwrap();",
        "",
        "        // Test permissions",
        "        assert!(security_server.check_permission(\"alice\", \"servers:delete\").await.unwrap());",
        "        assert!(security_server.check_permission(\"alice\", \"config:write\").await.unwrap());"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/security_tests.rs",
      "line": 137,
      "code": "security_server.assign_role(\"charlie\", \"viewer\").await.unwrap();",
      "context": [
        "        ]).await.unwrap();",
        "",
        "        // Assign roles to users",
        "        security_server.assign_role(\"alice\", \"admin\").await.unwrap();",
        "        security_server.assign_role(\"bob\", \"operator\").await.unwrap();",
        "        security_server.assign_role(\"charlie\", \"viewer\").await.unwrap();",
        "",
        "        // Test permissions",
        "        assert!(security_server.check_permission(\"alice\", \"servers:delete\").await.unwrap());",
        "        assert!(security_server.check_permission(\"alice\", \"config:write\").await.unwrap());",
        ""
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/security_tests.rs",
      "line": 140,
      "code": "assert!(security_server.check_permission(\"alice\", \"servers:delete\").await.unwrap());",
      "context": [
        "        security_server.assign_role(\"alice\", \"admin\").await.unwrap();",
        "        security_server.assign_role(\"bob\", \"operator\").await.unwrap();",
        "        security_server.assign_role(\"charlie\", \"viewer\").await.unwrap();",
        "",
        "        // Test permissions",
        "        assert!(security_server.check_permission(\"alice\", \"servers:delete\").await.unwrap());",
        "        assert!(security_server.check_permission(\"alice\", \"config:write\").await.unwrap());",
        "",
        "        assert!(security_server.check_permission(\"bob\", \"servers:restart\").await.unwrap());",
        "        assert!(!security_server.check_permission(\"bob\", \"config:write\").await.unwrap());",
        ""
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/security_tests.rs",
      "line": 141,
      "code": "assert!(security_server.check_permission(\"alice\", \"config:write\").await.unwrap());",
      "context": [
        "        security_server.assign_role(\"bob\", \"operator\").await.unwrap();",
        "        security_server.assign_role(\"charlie\", \"viewer\").await.unwrap();",
        "",
        "        // Test permissions",
        "        assert!(security_server.check_permission(\"alice\", \"servers:delete\").await.unwrap());",
        "        assert!(security_server.check_permission(\"alice\", \"config:write\").await.unwrap());",
        "",
        "        assert!(security_server.check_permission(\"bob\", \"servers:restart\").await.unwrap());",
        "        assert!(!security_server.check_permission(\"bob\", \"config:write\").await.unwrap());",
        "",
        "        assert!(security_server.check_permission(\"charlie\", \"servers:read\").await.unwrap());"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/security_tests.rs",
      "line": 143,
      "code": "assert!(security_server.check_permission(\"bob\", \"servers:restart\").await.unwrap());",
      "context": [
        "",
        "        // Test permissions",
        "        assert!(security_server.check_permission(\"alice\", \"servers:delete\").await.unwrap());",
        "        assert!(security_server.check_permission(\"alice\", \"config:write\").await.unwrap());",
        "",
        "        assert!(security_server.check_permission(\"bob\", \"servers:restart\").await.unwrap());",
        "        assert!(!security_server.check_permission(\"bob\", \"config:write\").await.unwrap());",
        "",
        "        assert!(security_server.check_permission(\"charlie\", \"servers:read\").await.unwrap());",
        "        assert!(!security_server.check_permission(\"charlie\", \"servers:restart\").await.unwrap());",
        "    }"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/security_tests.rs",
      "line": 144,
      "code": "assert!(!security_server.check_permission(\"bob\", \"config:write\").await.unwrap());",
      "context": [
        "        // Test permissions",
        "        assert!(security_server.check_permission(\"alice\", \"servers:delete\").await.unwrap());",
        "        assert!(security_server.check_permission(\"alice\", \"config:write\").await.unwrap());",
        "",
        "        assert!(security_server.check_permission(\"bob\", \"servers:restart\").await.unwrap());",
        "        assert!(!security_server.check_permission(\"bob\", \"config:write\").await.unwrap());",
        "",
        "        assert!(security_server.check_permission(\"charlie\", \"servers:read\").await.unwrap());",
        "        assert!(!security_server.check_permission(\"charlie\", \"servers:restart\").await.unwrap());",
        "    }",
        ""
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/security_tests.rs",
      "line": 146,
      "code": "assert!(security_server.check_permission(\"charlie\", \"servers:read\").await.unwrap());",
      "context": [
        "        assert!(security_server.check_permission(\"alice\", \"config:write\").await.unwrap());",
        "",
        "        assert!(security_server.check_permission(\"bob\", \"servers:restart\").await.unwrap());",
        "        assert!(!security_server.check_permission(\"bob\", \"config:write\").await.unwrap());",
        "",
        "        assert!(security_server.check_permission(\"charlie\", \"servers:read\").await.unwrap());",
        "        assert!(!security_server.check_permission(\"charlie\", \"servers:restart\").await.unwrap());",
        "    }",
        "",
        "    #[tokio::test]",
        "    async fn test_resource_based_access_control() {"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/security_tests.rs",
      "line": 147,
      "code": "assert!(!security_server.check_permission(\"charlie\", \"servers:restart\").await.unwrap());",
      "context": [
        "",
        "        assert!(security_server.check_permission(\"bob\", \"servers:restart\").await.unwrap());",
        "        assert!(!security_server.check_permission(\"bob\", \"config:write\").await.unwrap());",
        "",
        "        assert!(security_server.check_permission(\"charlie\", \"servers:read\").await.unwrap());",
        "        assert!(!security_server.check_permission(\"charlie\", \"servers:restart\").await.unwrap());",
        "    }",
        "",
        "    #[tokio::test]",
        "    async fn test_resource_based_access_control() {",
        "        let security_server = SecurityServer::new(\"resource_server\");"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/security_tests.rs",
      "line": 158,
      "code": "]).await.unwrap();",
      "context": [
        "",
        "        // Define resource policies",
        "        security_server.create_resource_policy(\"production_servers\", vec![",
        "            (\"alice\", vec![\"read\", \"write\", \"delete\"]),",
        "            (\"bob\", vec![\"read\"]),",
        "        ]).await.unwrap();",
        "",
        "        security_server.create_resource_policy(\"staging_servers\", vec![",
        "            (\"alice\", vec![\"read\", \"write\"]),",
        "            (\"bob\", vec![\"read\", \"write\", \"delete\"]),",
        "            (\"charlie\", vec![\"read\", \"write\"]),"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/security_tests.rs",
      "line": 164,
      "code": "]).await.unwrap();",
      "context": [
        "",
        "        security_server.create_resource_policy(\"staging_servers\", vec![",
        "            (\"alice\", vec![\"read\", \"write\"]),",
        "            (\"bob\", vec![\"read\", \"write\", \"delete\"]),",
        "            (\"charlie\", vec![\"read\", \"write\"]),",
        "        ]).await.unwrap();",
        "",
        "        // Test resource access",
        "        assert!(security_server.check_resource_access(",
        "            \"alice\", \"production_servers\", \"write\"",
        "        ).await.unwrap());"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/security_tests.rs",
      "line": 169,
      "code": ").await.unwrap());",
      "context": [
        "        ]).await.unwrap();",
        "",
        "        // Test resource access",
        "        assert!(security_server.check_resource_access(",
        "            \"alice\", \"production_servers\", \"write\"",
        "        ).await.unwrap());",
        "",
        "        assert!(!security_server.check_resource_access(",
        "            \"bob\", \"production_servers\", \"write\"",
        "        ).await.unwrap());",
        ""
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/security_tests.rs",
      "line": 173,
      "code": ").await.unwrap());",
      "context": [
        "            \"alice\", \"production_servers\", \"write\"",
        "        ).await.unwrap());",
        "",
        "        assert!(!security_server.check_resource_access(",
        "            \"bob\", \"production_servers\", \"write\"",
        "        ).await.unwrap());",
        "",
        "        assert!(security_server.check_resource_access(",
        "            \"bob\", \"staging_servers\", \"delete\"",
        "        ).await.unwrap());",
        "    }"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/security_tests.rs",
      "line": 177,
      "code": ").await.unwrap());",
      "context": [
        "            \"bob\", \"production_servers\", \"write\"",
        "        ).await.unwrap());",
        "",
        "        assert!(security_server.check_resource_access(",
        "            \"bob\", \"staging_servers\", \"delete\"",
        "        ).await.unwrap());",
        "    }",
        "",
        "    #[tokio::test]",
        "    async fn test_attribute_based_access_control() {",
        "        let security_server = SecurityServer::new(\"abac_server\");"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/security_tests.rs",
      "line": 188,
      "code": "}).await.unwrap();",
      "context": [
        "",
        "        // Define ABAC policies",
        "        security_server.create_abac_policy(\"sensitive_data_access\", |attributes| {",
        "            attributes.get(\"clearance_level\").map(|l| l == \"top_secret\").unwrap_or(false) &&",
        "            attributes.get(\"department\").map(|d| d == \"security\").unwrap_or(false)",
        "        }).await.unwrap();",
        "",
        "        // Test with different attribute sets",
        "        let mut alice_attrs = HashMap::new();",
        "        alice_attrs.insert(\"clearance_level\".to_string(), \"top_secret\".to_string());",
        "        alice_attrs.insert(\"department\".to_string(), \"security\".to_string());"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/security_tests.rs",
      "line": 201,
      "code": ").await.unwrap());",
      "context": [
        "        bob_attrs.insert(\"clearance_level\".to_string(), \"secret\".to_string());",
        "        bob_attrs.insert(\"department\".to_string(), \"security\".to_string());",
        "",
        "        assert!(security_server.evaluate_abac_policy(",
        "            \"sensitive_data_access\", &alice_attrs",
        "        ).await.unwrap());",
        "",
        "        assert!(!security_server.evaluate_abac_policy(",
        "            \"sensitive_data_access\", &bob_attrs",
        "        ).await.unwrap());",
        "    }"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/security_tests.rs",
      "line": 205,
      "code": ").await.unwrap());",
      "context": [
        "            \"sensitive_data_access\", &alice_attrs",
        "        ).await.unwrap());",
        "",
        "        assert!(!security_server.evaluate_abac_policy(",
        "            \"sensitive_data_access\", &bob_attrs",
        "        ).await.unwrap());",
        "    }",
        "}",
        "",
        "#[cfg(test)]",
        "mod encryption_tests {"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/security_tests.rs",
      "line": 224,
      "code": "let encrypted = security_server.encrypt_data(&sensitive_data).await.unwrap();",
      "context": [
        "            \"ssn\": \"123-45-6789\",",
        "            \"api_key\": \"secret_key_12345\",",
        "        });",
        "",
        "        // Encrypt data",
        "        let encrypted = security_server.encrypt_data(&sensitive_data).await.unwrap();",
        "        assert_ne!(encrypted, sensitive_data.to_string());",
        "        assert!(encrypted.len() > sensitive_data.to_string().len()); // Should include IV/tag",
        "",
        "        // Decrypt data",
        "        let decrypted = security_server.decrypt_data(&encrypted).await.unwrap();"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/security_tests.rs",
      "line": 229,
      "code": "let decrypted = security_server.decrypt_data(&encrypted).await.unwrap();",
      "context": [
        "        let encrypted = security_server.encrypt_data(&sensitive_data).await.unwrap();",
        "        assert_ne!(encrypted, sensitive_data.to_string());",
        "        assert!(encrypted.len() > sensitive_data.to_string().len()); // Should include IV/tag",
        "",
        "        // Decrypt data",
        "        let decrypted = security_server.decrypt_data(&encrypted).await.unwrap();",
        "        assert_eq!(decrypted, sensitive_data);",
        "    }",
        "",
        "    #[tokio::test]",
        "    async fn test_field_level_encryption() {"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/security_tests.rs",
      "line": 246,
      "code": "security_server.encrypt_fields(&mut document, vec![\"ssn\", \"phone\"]).await.unwrap();",
      "context": [
        "            \"ssn\": \"123-45-6789\",",
        "            \"phone\": \"555-1234\",",
        "        });",
        "",
        "        // Encrypt specific fields",
        "        security_server.encrypt_fields(&mut document, vec![\"ssn\", \"phone\"]).await.unwrap();",
        "",
        "        // Verify only specified fields are encrypted",
        "        assert_eq!(document[\"user_id\"], \"12345\");",
        "        assert_eq!(document[\"name\"], \"John Doe\");",
        "        assert_ne!(document[\"ssn\"], \"123-45-6789\");"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/security_tests.rs",
      "line": 255,
      "code": "security_server.decrypt_fields(&mut document, vec![\"ssn\", \"phone\"]).await.unwrap();",
      "context": [
        "        assert_eq!(document[\"name\"], \"John Doe\");",
        "        assert_ne!(document[\"ssn\"], \"123-45-6789\");",
        "        assert_ne!(document[\"phone\"], \"555-1234\");",
        "",
        "        // Decrypt fields",
        "        security_server.decrypt_fields(&mut document, vec![\"ssn\", \"phone\"]).await.unwrap();",
        "        assert_eq!(document[\"ssn\"], \"123-45-6789\");",
        "        assert_eq!(document[\"phone\"], \"555-1234\");",
        "    }",
        "",
        "    #[tokio::test]"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/security_tests.rs",
      "line": 266,
      "code": "let encrypted_v1 = security_server.encrypt_data(&data).await.unwrap();",
      "context": [
        "    async fn test_key_rotation() {",
        "        let security_server = SecurityServer::new(\"key_rotation_server\");",
        "",
        "        // Encrypt with current key",
        "        let data = \"sensitive information\";",
        "        let encrypted_v1 = security_server.encrypt_data(&data).await.unwrap();",
        "",
        "        // Rotate encryption key",
        "        security_server.rotate_encryption_key().await.unwrap();",
        "",
        "        // Should still be able to decrypt old data"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/security_tests.rs",
      "line": 269,
      "code": "security_server.rotate_encryption_key().await.unwrap();",
      "context": [
        "        // Encrypt with current key",
        "        let data = \"sensitive information\";",
        "        let encrypted_v1 = security_server.encrypt_data(&data).await.unwrap();",
        "",
        "        // Rotate encryption key",
        "        security_server.rotate_encryption_key().await.unwrap();",
        "",
        "        // Should still be able to decrypt old data",
        "        let decrypted = security_server.decrypt_data(&encrypted_v1).await.unwrap();",
        "        assert_eq!(decrypted, data);",
        ""
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/security_tests.rs",
      "line": 272,
      "code": "let decrypted = security_server.decrypt_data(&encrypted_v1).await.unwrap();",
      "context": [
        "",
        "        // Rotate encryption key",
        "        security_server.rotate_encryption_key().await.unwrap();",
        "",
        "        // Should still be able to decrypt old data",
        "        let decrypted = security_server.decrypt_data(&encrypted_v1).await.unwrap();",
        "        assert_eq!(decrypted, data);",
        "",
        "        // New encryption should use new key",
        "        let encrypted_v2 = security_server.encrypt_data(&data).await.unwrap();",
        "        assert_ne!(encrypted_v1, encrypted_v2);"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/security_tests.rs",
      "line": 276,
      "code": "let encrypted_v2 = security_server.encrypt_data(&data).await.unwrap();",
      "context": [
        "        // Should still be able to decrypt old data",
        "        let decrypted = security_server.decrypt_data(&encrypted_v1).await.unwrap();",
        "        assert_eq!(decrypted, data);",
        "",
        "        // New encryption should use new key",
        "        let encrypted_v2 = security_server.encrypt_data(&data).await.unwrap();",
        "        assert_ne!(encrypted_v1, encrypted_v2);",
        "",
        "        // Both should decrypt to same value",
        "        assert_eq!(",
        "            security_server.decrypt_data(&encrypted_v1).await.unwrap(),"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/security_tests.rs",
      "line": 281,
      "code": "security_server.decrypt_data(&encrypted_v1).await.unwrap(),",
      "context": [
        "        let encrypted_v2 = security_server.encrypt_data(&data).await.unwrap();",
        "        assert_ne!(encrypted_v1, encrypted_v2);",
        "",
        "        // Both should decrypt to same value",
        "        assert_eq!(",
        "            security_server.decrypt_data(&encrypted_v1).await.unwrap(),",
        "            security_server.decrypt_data(&encrypted_v2).await.unwrap()",
        "        );",
        "    }",
        "}",
        ""
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/security_tests.rs",
      "line": 282,
      "code": "security_server.decrypt_data(&encrypted_v2).await.unwrap()",
      "context": [
        "        assert_ne!(encrypted_v1, encrypted_v2);",
        "",
        "        // Both should decrypt to same value",
        "        assert_eq!(",
        "            security_server.decrypt_data(&encrypted_v1).await.unwrap(),",
        "            security_server.decrypt_data(&encrypted_v2).await.unwrap()",
        "        );",
        "    }",
        "}",
        "",
        "#[cfg(test)]"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/security_tests.rs",
      "line": 301,
      "code": "security_server.train_anomaly_detector().await.unwrap();",
      "context": [
        "        for _ in 0..100 {",
        "            security_server.record_request_pattern(\"user1\", \"GET\", \"/api/users\", 150).await;",
        "            security_server.record_request_pattern(\"user1\", \"GET\", \"/api/posts\", 200).await;",
        "        }",
        "",
        "        security_server.train_anomaly_detector().await.unwrap();",
        "",
        "        // Normal behavior should not trigger alerts",
        "        let normal_score = security_server.calculate_anomaly_score(",
        "            \"user1\", \"GET\", \"/api/users\", 160",
        "        ).await.unwrap();"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/security_tests.rs",
      "line": 306,
      "code": ").await.unwrap();",
      "context": [
        "        security_server.train_anomaly_detector().await.unwrap();",
        "",
        "        // Normal behavior should not trigger alerts",
        "        let normal_score = security_server.calculate_anomaly_score(",
        "            \"user1\", \"GET\", \"/api/users\", 160",
        "        ).await.unwrap();",
        "        assert!(normal_score < 0.5);",
        "",
        "        // Anomalous behavior should trigger alerts",
        "        let anomaly_score = security_server.calculate_anomaly_score(",
        "            \"user1\", \"DELETE\", \"/api/admin/users\", 50"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/security_tests.rs",
      "line": 312,
      "code": ").await.unwrap();",
      "context": [
        "        assert!(normal_score < 0.5);",
        "",
        "        // Anomalous behavior should trigger alerts",
        "        let anomaly_score = security_server.calculate_anomaly_score(",
        "            \"user1\", \"DELETE\", \"/api/admin/users\", 50",
        "        ).await.unwrap();",
        "        assert!(anomaly_score > 0.7);",
        "    }",
        "",
        "    #[tokio::test]",
        "    async fn test_rate_limiting() {"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/security_tests.rs",
      "line": 321,
      "code": "security_server.set_rate_limit(\"api_key_123\", 10, Duration::from_secs(60)).await.unwrap();",
      "context": [
        "    #[tokio::test]",
        "    async fn test_rate_limiting() {",
        "        let security_server = SecurityServer::new(\"rate_limit_server\");",
        "",
        "        // Configure rate limits",
        "        security_server.set_rate_limit(\"api_key_123\", 10, Duration::from_secs(60)).await.unwrap();",
        "",
        "        // Should allow up to limit",
        "        for i in 0..10 {",
        "            let allowed = security_server.check_rate_limit(\"api_key_123\").await.unwrap();",
        "            assert!(allowed, \"Request {} should be allowed\", i);"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/security_tests.rs",
      "line": 325,
      "code": "let allowed = security_server.check_rate_limit(\"api_key_123\").await.unwrap();",
      "context": [
        "        // Configure rate limits",
        "        security_server.set_rate_limit(\"api_key_123\", 10, Duration::from_secs(60)).await.unwrap();",
        "",
        "        // Should allow up to limit",
        "        for i in 0..10 {",
        "            let allowed = security_server.check_rate_limit(\"api_key_123\").await.unwrap();",
        "            assert!(allowed, \"Request {} should be allowed\", i);",
        "        }",
        "",
        "        // Should block after limit",
        "        let blocked = security_server.check_rate_limit(\"api_key_123\").await.unwrap();"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/security_tests.rs",
      "line": 330,
      "code": "let blocked = security_server.check_rate_limit(\"api_key_123\").await.unwrap();",
      "context": [
        "            let allowed = security_server.check_rate_limit(\"api_key_123\").await.unwrap();",
        "            assert!(allowed, \"Request {} should be allowed\", i);",
        "        }",
        "",
        "        // Should block after limit",
        "        let blocked = security_server.check_rate_limit(\"api_key_123\").await.unwrap();",
        "        assert!(!blocked, \"Should be rate limited\");",
        "",
        "        // Get rate limit status",
        "        let status = security_server.get_rate_limit_status(\"api_key_123\").await.unwrap();",
        "        assert_eq!(status.requests_made, 11);"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/security_tests.rs",
      "line": 334,
      "code": "let status = security_server.get_rate_limit_status(\"api_key_123\").await.unwrap();",
      "context": [
        "        // Should block after limit",
        "        let blocked = security_server.check_rate_limit(\"api_key_123\").await.unwrap();",
        "        assert!(!blocked, \"Should be rate limited\");",
        "",
        "        // Get rate limit status",
        "        let status = security_server.get_rate_limit_status(\"api_key_123\").await.unwrap();",
        "        assert_eq!(status.requests_made, 11);",
        "        assert_eq!(status.limit, 10);",
        "        assert!(status.reset_time > SystemTime::now());",
        "    }",
        ""
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/security_tests.rs",
      "line": 348,
      "code": ").await.unwrap();",
      "context": [
        "",
        "        // Configure DDoS protection",
        "        security_server.enable_ddos_protection(",
        "            100, // requests per second threshold",
        "            Duration::from_secs(10), // ban duration",
        "        ).await.unwrap();",
        "",
        "        // Simulate attack from IP",
        "        let attacker_ip = \"192.168.1.100\";",
        "",
        "        // Burst of requests"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/security_tests.rs",
      "line": 359,
      "code": "let threat_level = security_server.assess_threat(attacker_ip).await.unwrap();",
      "context": [
        "        for _ in 0..150 {",
        "            security_server.record_request(attacker_ip).await;",
        "        }",
        "",
        "        // Should detect and block",
        "        let threat_level = security_server.assess_threat(attacker_ip).await.unwrap();",
        "        assert_eq!(threat_level, ThreatLevel::High);",
        "",
        "        let is_blocked = security_server.is_ip_blocked(attacker_ip).await.unwrap();",
        "        assert!(is_blocked);",
        "    }"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/security_tests.rs",
      "line": 362,
      "code": "let is_blocked = security_server.is_ip_blocked(attacker_ip).await.unwrap();",
      "context": [
        "",
        "        // Should detect and block",
        "        let threat_level = security_server.assess_threat(attacker_ip).await.unwrap();",
        "        assert_eq!(threat_level, ThreatLevel::High);",
        "",
        "        let is_blocked = security_server.is_ip_blocked(attacker_ip).await.unwrap();",
        "        assert!(is_blocked);",
        "    }",
        "",
        "    #[tokio::test]",
        "    async fn test_sql_injection_detection() {"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/security_tests.rs",
      "line": 387,
      "code": "let is_safe = security_server.validate_input(input, \"sql\").await.unwrap();",
      "context": [
        "            \"' UNION SELECT * FROM passwords--\",",
        "            \"1' AND (SELECT COUNT(*) FROM users) > 0--\",",
        "        ];",
        "",
        "        for input in safe_inputs {",
        "            let is_safe = security_server.validate_input(input, \"sql\").await.unwrap();",
        "            assert!(is_safe, \"Input '{}' should be safe\", input);",
        "        }",
        "",
        "        for input in malicious_inputs {",
        "            let is_safe = security_server.validate_input(input, \"sql\").await.unwrap();"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/security_tests.rs",
      "line": 392,
      "code": "let is_safe = security_server.validate_input(input, \"sql\").await.unwrap();",
      "context": [
        "            let is_safe = security_server.validate_input(input, \"sql\").await.unwrap();",
        "            assert!(is_safe, \"Input '{}' should be safe\", input);",
        "        }",
        "",
        "        for input in malicious_inputs {",
        "            let is_safe = security_server.validate_input(input, \"sql\").await.unwrap();",
        "            assert!(!is_safe, \"Input '{}' should be detected as malicious\", input);",
        "        }",
        "    }",
        "}",
        ""
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/security_tests.rs",
      "line": 412,
      "code": "]).await.unwrap();",
      "context": [
        "        security_server.enable_audit_logging(vec![",
        "            \"authentication\",",
        "            \"authorization\",",
        "            \"data_access\",",
        "            \"configuration_change\",",
        "        ]).await.unwrap();",
        "",
        "        // Perform actions that should be audited",
        "        let token = security_server.generate_token(\"alice\", Duration::from_secs(3600)).await.unwrap();",
        "        security_server.check_permission(\"alice\", \"servers:read\").await.unwrap();",
        "        security_server.access_sensitive_data(\"alice\", \"customer_records\").await;"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/security_tests.rs",
      "line": 415,
      "code": "let token = security_server.generate_token(\"alice\", Duration::from_secs(3600)).await.unwrap();",
      "context": [
        "            \"data_access\",",
        "            \"configuration_change\",",
        "        ]).await.unwrap();",
        "",
        "        // Perform actions that should be audited",
        "        let token = security_server.generate_token(\"alice\", Duration::from_secs(3600)).await.unwrap();",
        "        security_server.check_permission(\"alice\", \"servers:read\").await.unwrap();",
        "        security_server.access_sensitive_data(\"alice\", \"customer_records\").await;",
        "        security_server.update_configuration(\"alice\", \"rate_limit\", \"100\").await;",
        "",
        "        // Retrieve audit logs"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/security_tests.rs",
      "line": 416,
      "code": "security_server.check_permission(\"alice\", \"servers:read\").await.unwrap();",
      "context": [
        "            \"configuration_change\",",
        "        ]).await.unwrap();",
        "",
        "        // Perform actions that should be audited",
        "        let token = security_server.generate_token(\"alice\", Duration::from_secs(3600)).await.unwrap();",
        "        security_server.check_permission(\"alice\", \"servers:read\").await.unwrap();",
        "        security_server.access_sensitive_data(\"alice\", \"customer_records\").await;",
        "        security_server.update_configuration(\"alice\", \"rate_limit\", \"100\").await;",
        "",
        "        // Retrieve audit logs",
        "        let logs = security_server.get_audit_logs("
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/security_tests.rs",
      "line": 426,
      "code": ").await.unwrap();",
      "context": [
        "        let logs = security_server.get_audit_logs(",
        "            Some(\"alice\"),",
        "            None,",
        "            Some(SystemTime::now() - Duration::from_secs(60)),",
        "            Some(SystemTime::now()),",
        "        ).await.unwrap();",
        "",
        "        assert!(logs.len() >= 4);",
        "",
        "        // Verify log integrity",
        "        for log in &logs {"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/security_tests.rs",
      "line": 438,
      "code": "let is_valid = security_server.verify_audit_log_integrity(&log).await.unwrap();",
      "context": [
        "            assert!(!log.user.is_empty());",
        "            assert!(!log.action.is_empty());",
        "            assert!(log.timestamp <= SystemTime::now());",
        "",
        "            // Verify log signature",
        "            let is_valid = security_server.verify_audit_log_integrity(&log).await.unwrap();",
        "            assert!(is_valid, \"Audit log should have valid signature\");",
        "        }",
        "    }",
        "",
        "    #[tokio::test]"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/security_tests.rs",
      "line": 448,
      "code": "let gdpr_report = security_server.generate_compliance_report(\"GDPR\").await.unwrap();",
      "context": [
        "    #[tokio::test]",
        "    async fn test_compliance_reporting() {",
        "        let security_server = SecurityServer::new(\"compliance_server\");",
        "",
        "        // Generate compliance reports",
        "        let gdpr_report = security_server.generate_compliance_report(\"GDPR\").await.unwrap();",
        "        let pci_report = security_server.generate_compliance_report(\"PCI-DSS\").await.unwrap();",
        "        let soc2_report = security_server.generate_compliance_report(\"SOC2\").await.unwrap();",
        "",
        "        // Verify report contents",
        "        assert!(gdpr_report.contains(\"data_retention\"));"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/security_tests.rs",
      "line": 449,
      "code": "let pci_report = security_server.generate_compliance_report(\"PCI-DSS\").await.unwrap();",
      "context": [
        "    async fn test_compliance_reporting() {",
        "        let security_server = SecurityServer::new(\"compliance_server\");",
        "",
        "        // Generate compliance reports",
        "        let gdpr_report = security_server.generate_compliance_report(\"GDPR\").await.unwrap();",
        "        let pci_report = security_server.generate_compliance_report(\"PCI-DSS\").await.unwrap();",
        "        let soc2_report = security_server.generate_compliance_report(\"SOC2\").await.unwrap();",
        "",
        "        // Verify report contents",
        "        assert!(gdpr_report.contains(\"data_retention\"));",
        "        assert!(gdpr_report.contains(\"right_to_erasure\"));"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/security_tests.rs",
      "line": 450,
      "code": "let soc2_report = security_server.generate_compliance_report(\"SOC2\").await.unwrap();",
      "context": [
        "        let security_server = SecurityServer::new(\"compliance_server\");",
        "",
        "        // Generate compliance reports",
        "        let gdpr_report = security_server.generate_compliance_report(\"GDPR\").await.unwrap();",
        "        let pci_report = security_server.generate_compliance_report(\"PCI-DSS\").await.unwrap();",
        "        let soc2_report = security_server.generate_compliance_report(\"SOC2\").await.unwrap();",
        "",
        "        // Verify report contents",
        "        assert!(gdpr_report.contains(\"data_retention\"));",
        "        assert!(gdpr_report.contains(\"right_to_erasure\"));",
        "        assert!(gdpr_report.contains(\"data_portability\"));"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/security_tests.rs",
      "line": 487,
      "code": "}).await.unwrap();",
      "context": [
        "            require_encryption: true,",
        "            allowed_tls_versions: vec![\"1.2\", \"1.3\"],",
        "            allowed_ciphers: vec![\"AES256-GCM-SHA384\", \"CHACHA20-POLY1305\"],",
        "            enable_audit_logging: true,",
        "            enable_threat_detection: true,",
        "        }).await.unwrap();",
        "",
        "        manager.register_security_server(security_server.clone()).await.unwrap();",
        "",
        "        // Authenticate user",
        "        let token = manager.authenticate_user(\"alice\", \"password123\").await.unwrap();"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/security_tests.rs",
      "line": 489,
      "code": "manager.register_security_server(security_server.clone()).await.unwrap();",
      "context": [
        "            allowed_ciphers: vec![\"AES256-GCM-SHA384\", \"CHACHA20-POLY1305\"],",
        "            enable_audit_logging: true,",
        "            enable_threat_detection: true,",
        "        }).await.unwrap();",
        "",
        "        manager.register_security_server(security_server.clone()).await.unwrap();",
        "",
        "        // Authenticate user",
        "        let token = manager.authenticate_user(\"alice\", \"password123\").await.unwrap();",
        "",
        "        // Make authenticated request"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/security_tests.rs",
      "line": 492,
      "code": "let token = manager.authenticate_user(\"alice\", \"password123\").await.unwrap();",
      "context": [
        "        }).await.unwrap();",
        "",
        "        manager.register_security_server(security_server.clone()).await.unwrap();",
        "",
        "        // Authenticate user",
        "        let token = manager.authenticate_user(\"alice\", \"password123\").await.unwrap();",
        "",
        "        // Make authenticated request",
        "        let request = MCPRequest::new(\"get_servers\", serde_json::json!({}))",
        "            .with_auth_token(&token);",
        ""
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/security_tests.rs",
      "line": 498,
      "code": "let response = manager.send_secure_request(request).await.unwrap();",
      "context": [
        "",
        "        // Make authenticated request",
        "        let request = MCPRequest::new(\"get_servers\", serde_json::json!({}))",
        "            .with_auth_token(&token);",
        "",
        "        let response = manager.send_secure_request(request).await.unwrap();",
        "",
        "        // Verify response is encrypted",
        "        assert!(response.is_encrypted());",
        "",
        "        // Decrypt and verify"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/security_tests.rs",
      "line": 504,
      "code": "let decrypted = manager.decrypt_response(response).await.unwrap();",
      "context": [
        "",
        "        // Verify response is encrypted",
        "        assert!(response.is_encrypted());",
        "",
        "        // Decrypt and verify",
        "        let decrypted = manager.decrypt_response(response).await.unwrap();",
        "        assert!(decrypted.result.is_some());",
        "",
        "        // Check audit log",
        "        let audit_logs = security_server.get_recent_audit_logs(1).await.unwrap();",
        "        assert_eq!(audit_logs.len(), 1);"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/security_tests.rs",
      "line": 508,
      "code": "let audit_logs = security_server.get_recent_audit_logs(1).await.unwrap();",
      "context": [
        "        // Decrypt and verify",
        "        let decrypted = manager.decrypt_response(response).await.unwrap();",
        "        assert!(decrypted.result.is_some());",
        "",
        "        // Check audit log",
        "        let audit_logs = security_server.get_recent_audit_logs(1).await.unwrap();",
        "        assert_eq!(audit_logs.len(), 1);",
        "        assert_eq!(audit_logs[0].user, \"alice\");",
        "        assert_eq!(audit_logs[0].action, \"get_servers\");",
        "    }",
        "}"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/property_tests.rs",
      "line": 129,
      "code": "let rt = Runtime::new().unwrap();",
      "context": [
        "",
        "    #[test]",
        "    fn prop_server_registration_idempotent(",
        "        servers in prop::collection::vec(arb_mcp_server(), 1..10)",
        "    ) {",
        "        let rt = Runtime::new().unwrap();",
        "        rt.block_on(async {",
        "            let manager = create_test_manager();",
        "",
        "            // Register servers multiple times",
        "            for server in &servers {"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/property_tests.rs",
      "line": 153,
      "code": "let rt = Runtime::new().unwrap();",
      "context": [
        "    #[test]",
        "    fn prop_unregister_removes_server(",
        "        servers in prop::collection::vec(arb_mcp_server(), 1..10),",
        "        remove_indices in prop::collection::vec(any::<usize>(), 1..5)",
        "    ) {",
        "        let rt = Runtime::new().unwrap();",
        "        rt.block_on(async {",
        "            let manager = create_test_manager();",
        "",
        "            // Register all servers",
        "            for server in &servers {"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/property_tests.rs",
      "line": 159,
      "code": "manager.register_server(server.clone()).await.unwrap();",
      "context": [
        "        rt.block_on(async {",
        "            let manager = create_test_manager();",
        "",
        "            // Register all servers",
        "            for server in &servers {",
        "                manager.register_server(server.clone()).await.unwrap();",
        "            }",
        "",
        "            // Remove some servers",
        "            let mut removed_ids = std::collections::HashSet::new();",
        "            for idx in remove_indices {"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/property_tests.rs",
      "line": 185,
      "code": "let rt = Runtime::new().unwrap();",
      "context": [
        "    #[test]",
        "    fn prop_retry_config_affects_behavior(",
        "        base_config in arb_mcp_config(),",
        "        fail_probability in 0.0f64..1.0",
        "    ) {",
        "        let rt = Runtime::new().unwrap();",
        "        rt.block_on(async {",
        "            // Test with no retries",
        "            let mut no_retry_config = base_config.clone();",
        "            no_retry_config.max_retries = 0;",
        "            let no_retry_manager = MCPManager::new(no_retry_config);"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/property_tests.rs",
      "line": 202,
      "code": "no_retry_manager.register_server(server.clone()).await.unwrap();",
      "context": [
        "            // Register mock servers",
        "            let server = create_mock_server(\"retry_test\");",
        "            let mock_conn = Arc::new(MockMCPConnection::new(server.id().to_string()));",
        "            mock_conn.set_fail_rate(fail_probability).await;",
        "",
        "            no_retry_manager.register_server(server.clone()).await.unwrap();",
        "            retry_manager.register_server(server).await.unwrap();",
        "",
        "            // Send requests",
        "            let request = MCPRequest::new(\"test\", serde_json::json!({}));",
        ""
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/property_tests.rs",
      "line": 203,
      "code": "retry_manager.register_server(server).await.unwrap();",
      "context": [
        "            let server = create_mock_server(\"retry_test\");",
        "            let mock_conn = Arc::new(MockMCPConnection::new(server.id().to_string()));",
        "            mock_conn.set_fail_rate(fail_probability).await;",
        "",
        "            no_retry_manager.register_server(server.clone()).await.unwrap();",
        "            retry_manager.register_server(server).await.unwrap();",
        "",
        "            // Send requests",
        "            let request = MCPRequest::new(\"test\", serde_json::json!({}));",
        "",
        "            let no_retry_result = no_retry_manager.send_request(request.clone()).await;"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/property_tests.rs",
      "line": 223,
      "code": "let rt = Runtime::new().unwrap();",
      "context": [
        "    #[test]",
        "    fn prop_load_balancing_distributes_requests(",
        "        num_servers in 2usize..10,",
        "        num_requests in 10usize..100",
        "    ) {",
        "        let rt = Runtime::new().unwrap();",
        "        rt.block_on(async {",
        "            let mut config = create_test_config();",
        "            config.enable_load_balancing = true;",
        "            let manager = MCPManager::new(config);",
        ""
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/property_tests.rs",
      "line": 236,
      "code": "manager.register_server(server).await.unwrap();",
      "context": [
        "",
        "            // Register servers",
        "            for i in 0..num_servers {",
        "                let server = create_mock_server(&format!(\"lb_server_{}\", i));",
        "                request_counts.insert(server.id().to_string(), 0u64);",
        "                manager.register_server(server).await.unwrap();",
        "            }",
        "",
        "            // Send requests",
        "            for i in 0..num_requests {",
        "                let request = MCPRequest::new(\"lb_test\", serde_json::json!({\"seq\": i}));"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/property_tests.rs",
      "line": 270,
      "code": "let rt = Runtime::new().unwrap();",
      "context": [
        "                arb_server_id().prop_map(|id| (\"get\", id, None)),",
        "            ],",
        "            1..50",
        "        )",
        "    ) {",
        "        let rt = Runtime::new().unwrap();",
        "        rt.block_on(async {",
        "            let manager = Arc::new(create_test_manager());",
        "            let mut handles = vec![];",
        "",
        "            // Execute operations concurrently"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/property_tests.rs",
      "line": 320,
      "code": "let rt = Runtime::new().unwrap();",
      "context": [
        "    #[test]",
        "    fn prop_metrics_accuracy(",
        "        num_requests in 10usize..100,",
        "        success_rate in 0.0f64..1.0",
        "    ) {",
        "        let rt = Runtime::new().unwrap();",
        "        rt.block_on(async {",
        "            let manager = create_test_manager();",
        "            let server = create_mock_server(\"metrics_test\");",
        "            let mock_conn = Arc::new(MockMCPConnection::new(server.id().to_string()));",
        ""
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/property_tests.rs",
      "line": 328,
      "code": "manager.register_server(server).await.unwrap();",
      "context": [
        "            let server = create_mock_server(\"metrics_test\");",
        "            let mock_conn = Arc::new(MockMCPConnection::new(server.id().to_string()));",
        "",
        "            // Set failure rate",
        "            mock_conn.set_fail_rate(1.0 - success_rate).await;",
        "            manager.register_server(server).await.unwrap();",
        "",
        "            // Send requests and track results",
        "            let mut success_count = 0;",
        "            let mut failure_count = 0;",
        ""
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/property_tests.rs",
      "line": 363,
      "code": "let rt = Runtime::new().unwrap();",
      "context": [
        "    #[test]",
        "    fn prop_connection_pool_respects_limits(",
        "        config in arb_mcp_config(),",
        "        concurrent_requests in 1usize..200",
        "    ) {",
        "        let rt = Runtime::new().unwrap();",
        "        rt.block_on(async {",
        "            let manager = Arc::new(MCPManager::new(config.clone()));",
        "            let server = create_mock_server(\"pool_limit_test\");",
        "            manager.register_server(server).await.unwrap();",
        ""
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/property_tests.rs",
      "line": 367,
      "code": "manager.register_server(server).await.unwrap();",
      "context": [
        "    ) {",
        "        let rt = Runtime::new().unwrap();",
        "        rt.block_on(async {",
        "            let manager = Arc::new(MCPManager::new(config.clone()));",
        "            let server = create_mock_server(\"pool_limit_test\");",
        "            manager.register_server(server).await.unwrap();",
        "",
        "            // Send many concurrent requests",
        "            let mut handles = vec![];",
        "            for i in 0..concurrent_requests {",
        "                let manager_clone = manager.clone();"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/integration_tests.rs",
      "line": 24,
      "code": "manager.register_server(server1.clone()).await.unwrap();",
      "context": [
        "    // Register multiple servers",
        "    let server1 = create_mock_server(\"server1\");",
        "    let server2 = create_mock_server(\"server2\");",
        "    let server3 = create_mock_server(\"server3\");",
        "",
        "    manager.register_server(server1.clone()).await.unwrap();",
        "    manager.register_server(server2.clone()).await.unwrap();",
        "    manager.register_server(server3.clone()).await.unwrap();",
        "",
        "    // Verify all servers are registered",
        "    let servers = manager.get_servers().await;"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/integration_tests.rs",
      "line": 25,
      "code": "manager.register_server(server2.clone()).await.unwrap();",
      "context": [
        "    let server1 = create_mock_server(\"server1\");",
        "    let server2 = create_mock_server(\"server2\");",
        "    let server3 = create_mock_server(\"server3\");",
        "",
        "    manager.register_server(server1.clone()).await.unwrap();",
        "    manager.register_server(server2.clone()).await.unwrap();",
        "    manager.register_server(server3.clone()).await.unwrap();",
        "",
        "    // Verify all servers are registered",
        "    let servers = manager.get_servers().await;",
        "    assert_eq!(servers.len(), 3);"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/integration_tests.rs",
      "line": 26,
      "code": "manager.register_server(server3.clone()).await.unwrap();",
      "context": [
        "    let server2 = create_mock_server(\"server2\");",
        "    let server3 = create_mock_server(\"server3\");",
        "",
        "    manager.register_server(server1.clone()).await.unwrap();",
        "    manager.register_server(server2.clone()).await.unwrap();",
        "    manager.register_server(server3.clone()).await.unwrap();",
        "",
        "    // Verify all servers are registered",
        "    let servers = manager.get_servers().await;",
        "    assert_eq!(servers.len(), 3);",
        ""
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/integration_tests.rs",
      "line": 39,
      "code": "manager.unregister_server(\"server2\").await.unwrap();",
      "context": [
        "    assert!(manager.get_server(\"server2\").await.is_some());",
        "    assert!(manager.get_server(\"server3\").await.is_some());",
        "    assert!(manager.get_server(\"nonexistent\").await.is_none());",
        "",
        "    // Unregister a server",
        "    manager.unregister_server(\"server2\").await.unwrap();",
        "",
        "    // Verify server is removed",
        "    let servers = manager.get_servers().await;",
        "    assert_eq!(servers.len(), 2);",
        "    assert!(manager.get_server(\"server2\").await.is_none());"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/integration_tests.rs",
      "line": 61,
      "code": "manager.register_server(server).await.unwrap();",
      "context": [
        "        let server = create_mock_server(&format!(\"server{}\", i));",
        "        let mock_conn = Arc::new(MockMCPConnection::new(server.id().to_string()));",
        "",
        "        // Inject the mock connection",
        "        servers.push((server.clone(), mock_conn.clone()));",
        "        manager.register_server(server).await.unwrap();",
        "    }",
        "",
        "    // Send multiple requests",
        "    let num_requests = 30;",
        "    for i in 0..num_requests {"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/integration_tests.rs",
      "line": 101,
      "code": "manager.register_server(server.clone()).await.unwrap();",
      "context": [
        "    let mut config = create_test_config();",
        "    config.max_connections_per_server = 3;",
        "    let manager = MCPManager::new(config);",
        "",
        "    let server = create_mock_server(\"pool_test_server\");",
        "    manager.register_server(server.clone()).await.unwrap();",
        "",
        "    // Send concurrent requests that should reuse connections",
        "    let mut handles = vec![];",
        "    for i in 0..10 {",
        "        let manager_clone = Arc::new(manager);"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/integration_tests.rs",
      "line": 138,
      "code": "manager.register_server(healthy_server.clone()).await.unwrap();",
      "context": [
        "    // Create servers with different health states",
        "    let healthy_server = create_mock_server(\"healthy\");",
        "    let unhealthy_server = create_mock_server(\"unhealthy\");",
        "",
        "    // Register servers",
        "    manager.register_server(healthy_server.clone()).await.unwrap();",
        "    manager.register_server(unhealthy_server.clone()).await.unwrap();",
        "",
        "    // Wait for initial health checks",
        "    tokio::time::sleep(Duration::from_secs(2)).await;",
        ""
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/integration_tests.rs",
      "line": 139,
      "code": "manager.register_server(unhealthy_server.clone()).await.unwrap();",
      "context": [
        "    let healthy_server = create_mock_server(\"healthy\");",
        "    let unhealthy_server = create_mock_server(\"unhealthy\");",
        "",
        "    // Register servers",
        "    manager.register_server(healthy_server.clone()).await.unwrap();",
        "    manager.register_server(unhealthy_server.clone()).await.unwrap();",
        "",
        "    // Wait for initial health checks",
        "    tokio::time::sleep(Duration::from_secs(2)).await;",
        "",
        "    // Send requests - should prefer healthy server"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/integration_tests.rs",
      "line": 176,
      "code": "manager.register_server(server.clone()).await.unwrap();",
      "context": [
        "    let mock_conn = Arc::new(MockMCPConnection::new(server.id().to_string()));",
        "",
        "    // Make connection fail",
        "    mock_conn.set_fail_rate(1.0).await;",
        "",
        "    manager.register_server(server.clone()).await.unwrap();",
        "",
        "    // Send requests until circuit breaker trips",
        "    let mut trip_count = 0;",
        "    for i in 0..5 {",
        "        let request = MCPRequest::new(\"circuit_test\", serde_json::json!({\"attempt\": i}));"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/integration_tests.rs",
      "line": 224,
      "code": "manager.register_server(server).await.unwrap();",
      "context": [
        "    let mock_conn = Arc::new(MockMCPConnection::new(server.id().to_string()));",
        "",
        "    // Set intermittent failure rate",
        "    mock_conn.set_fail_rate(0.6).await; // 60% failure rate",
        "",
        "    manager.register_server(server).await.unwrap();",
        "",
        "    // Send multiple requests",
        "    let mut success_count = 0;",
        "    let mut total_attempts = 0;",
        ""
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/integration_tests.rs",
      "line": 263,
      "code": "manager.register_server(server).await.unwrap();",
      "context": [
        "    let mock_conn = Arc::new(MockMCPConnection::new(server.id().to_string()));",
        "",
        "    // Set high latency to trigger timeouts",
        "    mock_conn.set_latency(300);",
        "",
        "    manager.register_server(server).await.unwrap();",
        "",
        "    // Request should timeout",
        "    let request = MCPRequest::new(\"timeout_test\", serde_json::json!({}));",
        "    let result = manager.send_request(request).await;",
        ""
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/integration_tests.rs",
      "line": 294,
      "code": "handle.await.unwrap().unwrap();",
      "context": [
        "        handles.push(handle);",
        "    }",
        "",
        "    // Wait for all registrations",
        "    for handle in handles {",
        "        handle.await.unwrap().unwrap();",
        "    }",
        "",
        "    // Verify all servers registered",
        "    assert_eq!(manager.get_servers().await.len(), 5);",
        ""
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/integration_tests.rs",
      "line": 330,
      "code": "manager.register_server(server).await.unwrap();",
      "context": [
        "    let manager = create_test_manager();",
        "",
        "    // Register servers",
        "    for i in 0..3 {",
        "        let server = create_mock_server(&format!(\"shutdown_{}\", i));",
        "        manager.register_server(server).await.unwrap();",
        "    }",
        "",
        "    // Start some background operations",
        "    let manager_clone = Arc::new(manager);",
        "    let operation_handle = tokio::spawn({"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/integration_tests.rs",
      "line": 351,
      "code": "manager_clone.unregister_server(&format!(\"shutdown_{}\", i)).await.unwrap();",
      "context": [
        "    // Let some operations run",
        "    tokio::time::sleep(Duration::from_millis(100)).await;",
        "",
        "    // Unregister all servers (graceful shutdown)",
        "    for i in 0..3 {",
        "        manager_clone.unregister_server(&format!(\"shutdown_{}\", i)).await.unwrap();",
        "    }",
        "",
        "    // Cancel background operations",
        "    operation_handle.abort();",
        ""
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/optimization_tests.rs",
      "line": 349,
      "code": "let _ = handle.await.unwrap();",
      "context": [
        "            tokio::time::sleep(Duration::from_millis(10)).await;",
        "        }",
        "",
        "        // Wait for all requests",
        "        for handle in handles {",
        "            let _ = handle.await.unwrap();",
        "        }",
        "",
        "        // Should have created multiple batches",
        "        let final_count = batch_count.load(Ordering::Relaxed);",
        "        assert!(final_count >= 2, \"Should have created multiple batches\");"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/optimization_tests.rs",
      "line": 400,
      "code": "let _ = handle.await.unwrap();",
      "context": [
        "            });",
        "            handles.push(handle);",
        "        }",
        "",
        "        for handle in handles {",
        "            let _ = handle.await.unwrap();",
        "        }",
        "",
        "        let elapsed = start.elapsed();",
        "",
        "        // Should process immediately when size is reached"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/optimization_tests.rs",
      "line": 512,
      "code": "let selected = lb.select_server(&request).await.unwrap();",
      "context": [
        "",
        "        // Should prefer fast server",
        "        let mut selections = HashMap::new();",
        "        for _ in 0..100 {",
        "            let request = MCPRequest::new(\"test\", serde_json::json!({}));",
        "            let selected = lb.select_server(&request).await.unwrap();",
        "            *selections.entry(selected.id().to_string()).or_insert(0) += 1;",
        "        }",
        "",
        "        // Fast server should get most requests",
        "        assert!(selections[\"fast\"] > selections[\"medium\"]);"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/optimization_tests.rs",
      "line": 543,
      "code": "let selected = lb.select_server(&request).await.unwrap();",
      "context": [
        "                \"test\".to_string(),",
        "                serde_json::json!({}),",
        "            );",
        "",
        "            for _ in 0..10 {",
        "                let selected = lb.select_server(&request).await.unwrap();",
        "                let entry = key_mapping.entry(key).or_insert(selected.id().to_string());",
        "                assert_eq!(*entry, selected.id(), \"Same key should always map to same server\");",
        "            }",
        "        }",
        "    }"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/optimization_tests.rs",
      "line": 579,
      "code": "let selected = lb.select_server(&request).await.unwrap();",
      "context": [
        "",
        "        // Should prefer lower loaded servers",
        "        let mut selections = HashMap::new();",
        "        for _ in 0..1000 {",
        "            let request = MCPRequest::new(\"test\", serde_json::json!({}));",
        "            let selected = lb.select_server(&request).await.unwrap();",
        "            *selections.entry(selected.id().to_string()).or_insert(0) += 1;",
        "        }",
        "",
        "        // Low load servers should get more requests",
        "        let high_load_avg = (selections.get(\"server0\").unwrap_or(&0) +"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/optimization_tests.rs",
      "line": 630,
      "code": "let selected = lb.select_server(&request).await.unwrap();",
      "context": [
        "",
        "        // Test final distribution",
        "        let mut selections = HashMap::new();",
        "        for _ in 0..300 {",
        "            let request = MCPRequest::new(\"test\", serde_json::json!({}));",
        "            let selected = lb.select_server(&request).await.unwrap();",
        "            *selections.entry(selected.id().to_string()).or_insert(0) += 1;",
        "        }",
        "",
        "        // Server0 should get most traffic due to consistent good performance",
        "        assert!(selections[\"server0\"] > selections[\"server1\"]);"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/resilience_tests.rs",
      "line": 57,
      "code": "match handle.await.unwrap() {",
      "context": [
        "        // Wait for all to complete",
        "        let mut success_count = 0;",
        "        let mut rejection_count = 0;",
        "",
        "        for handle in handles {",
        "            match handle.await.unwrap() {",
        "                Ok(_) => success_count += 1,",
        "                Err(MCPError::Capacity(_)) => rejection_count += 1,",
        "                Err(e) => panic!(\"Unexpected error: {:?}\", e),",
        "            }",
        "        }"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/resilience_tests.rs",
      "line": 168,
      "code": "chaos_engine.start_experiment(experiment).await.unwrap();",
      "context": [
        "            probability: 1.0, // Always inject",
        "            duration: Duration::from_secs(10),",
        "            targets: vec![\"service1\".to_string()],",
        "        };",
        "",
        "        chaos_engine.start_experiment(experiment).await.unwrap();",
        "",
        "        // Measure execution time",
        "        let start = Instant::now();",
        "        chaos_engine.inject_fault(\"service1\", async {",
        "            // Normal operation"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/resilience_tests.rs",
      "line": 175,
      "code": "}).await.unwrap();",
      "context": [
        "        // Measure execution time",
        "        let start = Instant::now();",
        "        chaos_engine.inject_fault(\"service1\", async {",
        "            // Normal operation",
        "            Ok::<_, MCPError>(())",
        "        }).await.unwrap();",
        "        let elapsed = start.elapsed();",
        "",
        "        // Should have added latency",
        "        assert!(elapsed >= Duration::from_millis(80), \"Should have injected latency\");",
        "        assert!(elapsed <= Duration::from_millis(150), \"Latency should be within bounds\");"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/resilience_tests.rs",
      "line": 198,
      "code": "chaos_engine.start_experiment(experiment).await.unwrap();",
      "context": [
        "            probability: 0.5, // 50% chance",
        "            duration: Duration::from_secs(10),",
        "            targets: vec![\"service2\".to_string()],",
        "        };",
        "",
        "        chaos_engine.start_experiment(experiment).await.unwrap();",
        "",
        "        let mut error_count = 0;",
        "        let mut success_count = 0;",
        "",
        "        // Run multiple times to test probability"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/resilience_tests.rs",
      "line": 233,
      "code": "chaos_engine.start_experiment(experiment).await.unwrap();",
      "context": [
        "            probability: 1.0,",
        "            duration: Duration::from_millis(500),",
        "            targets: vec![\"service3\".to_string()],",
        "        };",
        "",
        "        chaos_engine.start_experiment(experiment).await.unwrap();",
        "",
        "        // Should simulate resource pressure",
        "        let result = chaos_engine.inject_fault(\"service3\", async {",
        "            // Simulate memory-intensive operation",
        "            let _data: Vec<u8> = vec![0; 1024 * 1024]; // 1MB"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/resilience_tests.rs",
      "line": 268,
      "code": "chaos_engine.start_experiment(experiment).await.unwrap();",
      "context": [
        "            probability: 1.0,",
        "            duration: Duration::from_secs(1),",
        "            targets: vec![\"node1\".to_string(), \"node2\".to_string(), \"node3\".to_string(), \"node4\".to_string()],",
        "        };",
        "",
        "        chaos_engine.start_experiment(experiment).await.unwrap();",
        "",
        "        // Communication within partition should work",
        "        let result1 = chaos_engine.can_communicate(\"node1\", \"node2\").await;",
        "        assert!(result1, \"Nodes in same partition should communicate\");",
        ""
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/resilience_tests.rs",
      "line": 296,
      "code": "assert_eq!(result.unwrap(), serde_json::json!({\"status\": \"fallback\", \"data\": []}));",
      "context": [
        "        let result = fallback.execute(async {",
        "            Err::<serde_json::Value, MCPError>(MCPError::Connection(\"Primary failed\".to_string()))",
        "        }).await;",
        "",
        "        assert!(result.is_ok());",
        "        assert_eq!(result.unwrap(), serde_json::json!({\"status\": \"fallback\", \"data\": []}));",
        "    }",
        "",
        "    #[tokio::test]",
        "    async fn test_fallback_cache() {",
        "        let fallback = FallbackHandler::new(FallbackStrategy::Cache {"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/resilience_tests.rs",
      "line": 309,
      "code": "}).await.unwrap();",
      "context": [
        "        });",
        "",
        "        // First call - populate cache",
        "        let result1 = fallback.execute(async {",
        "            Ok(serde_json::json!({\"id\": 1, \"value\": \"cached\"}))",
        "        }).await.unwrap();",
        "",
        "        // Second call - primary fails, should use cache",
        "        let result2 = fallback.execute(async {",
        "            Err::<serde_json::Value, MCPError>(MCPError::Connection(\"Failed\".to_string()))",
        "        }).await.unwrap();"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/resilience_tests.rs",
      "line": 314,
      "code": "}).await.unwrap();",
      "context": [
        "        }).await.unwrap();",
        "",
        "        // Second call - primary fails, should use cache",
        "        let result2 = fallback.execute(async {",
        "            Err::<serde_json::Value, MCPError>(MCPError::Connection(\"Failed\".to_string()))",
        "        }).await.unwrap();",
        "",
        "        assert_eq!(result1, result2);",
        "    }",
        "",
        "    #[tokio::test]"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/resilience_tests.rs",
      "line": 338,
      "code": "assert_eq!(result.unwrap(), serde_json::json!(\"final fallback\"));",
      "context": [
        "        let result = chain.execute(async {",
        "            Err::<serde_json::Value, MCPError>(MCPError::Connection(\"Primary failed\".to_string()))",
        "        }).await;",
        "",
        "        assert!(result.is_ok());",
        "        assert_eq!(result.unwrap(), serde_json::json!(\"final fallback\"));",
        "    }",
        "",
        "    #[tokio::test]",
        "    async fn test_fallback_circuit_breaker_integration() {",
        "        let fallback = FallbackHandler::new(FallbackStrategy::CircuitBreaker {"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/distributed_tests.rs",
      "line": 37,
      "code": "consensus.start_election().await.unwrap();",
      "context": [
        "            node_ids.clone(),",
        "            ConsensusProtocol::Raft,",
        "        );",
        "",
        "        // Start election",
        "        consensus.start_election().await.unwrap();",
        "",
        "        // Wait for election to complete",
        "        tokio::time::sleep(Duration::from_millis(500)).await;",
        "",
        "        // Should have a leader"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/distributed_tests.rs",
      "line": 45,
      "code": "assert!(node_ids.contains(&leader.unwrap().as_str()));",
      "context": [
        "        tokio::time::sleep(Duration::from_millis(500)).await;",
        "",
        "        // Should have a leader",
        "        let leader = consensus.get_leader().await;",
        "        assert!(leader.is_some());",
        "        assert!(node_ids.contains(&leader.unwrap().as_str()));",
        "",
        "        // Check consensus state",
        "        let state = consensus.get_state().await;",
        "        assert!(matches!(state, ConsensusState::Leader | ConsensusState::Follower));",
        "    }"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/distributed_tests.rs",
      "line": 61,
      "code": "consensus.become_leader().await.unwrap();",
      "context": [
        "            vec![\"leader\", \"follower1\", \"follower2\"],",
        "            ConsensusProtocol::Raft,",
        "        );",
        "",
        "        // Make this node the leader",
        "        consensus.become_leader().await.unwrap();",
        "",
        "        // Propose a value",
        "        let proposal = serde_json::json!({",
        "            \"action\": \"update_config\",",
        "            \"key\": \"max_connections\","
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/distributed_tests.rs",
      "line": 70,
      "code": "let index = consensus.propose(proposal.clone()).await.unwrap();",
      "context": [
        "            \"action\": \"update_config\",",
        "            \"key\": \"max_connections\",",
        "            \"value\": 100",
        "        });",
        "",
        "        let index = consensus.propose(proposal.clone()).await.unwrap();",
        "        assert!(index > 0);",
        "",
        "        // Wait for replication",
        "        tokio::time::sleep(Duration::from_millis(100)).await;",
        ""
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/distributed_tests.rs",
      "line": 81,
      "code": "let value = consensus.get_committed_value(index).await.unwrap();",
      "context": [
        "        // Check if committed",
        "        let committed = consensus.is_committed(index).await;",
        "        assert!(committed);",
        "",
        "        // Retrieve committed value",
        "        let value = consensus.get_committed_value(index).await.unwrap();",
        "        assert_eq!(value, proposal);",
        "    }",
        "",
        "    #[tokio::test]",
        "    async fn test_consensus_Byzantine_fault_tolerance() {"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/distributed_tests.rs",
      "line": 137,
      "code": "coordinator.add_node(\"node1\", NodeRole::Worker).await.unwrap();",
      "context": [
        "    #[tokio::test]",
        "    async fn test_coordinator_role_assignment() {",
        "        let coordinator = Coordinator::new(\"coord1\".to_string());",
        "",
        "        // Add nodes",
        "        coordinator.add_node(\"node1\", NodeRole::Worker).await.unwrap();",
        "        coordinator.add_node(\"node2\", NodeRole::Worker).await.unwrap();",
        "        coordinator.add_node(\"node3\", NodeRole::Manager).await.unwrap();",
        "",
        "        // Assign roles",
        "        coordinator.assign_role(\"node1\", NodeRole::Manager).await.unwrap();"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/distributed_tests.rs",
      "line": 138,
      "code": "coordinator.add_node(\"node2\", NodeRole::Worker).await.unwrap();",
      "context": [
        "    async fn test_coordinator_role_assignment() {",
        "        let coordinator = Coordinator::new(\"coord1\".to_string());",
        "",
        "        // Add nodes",
        "        coordinator.add_node(\"node1\", NodeRole::Worker).await.unwrap();",
        "        coordinator.add_node(\"node2\", NodeRole::Worker).await.unwrap();",
        "        coordinator.add_node(\"node3\", NodeRole::Manager).await.unwrap();",
        "",
        "        // Assign roles",
        "        coordinator.assign_role(\"node1\", NodeRole::Manager).await.unwrap();",
        ""
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/distributed_tests.rs",
      "line": 139,
      "code": "coordinator.add_node(\"node3\", NodeRole::Manager).await.unwrap();",
      "context": [
        "        let coordinator = Coordinator::new(\"coord1\".to_string());",
        "",
        "        // Add nodes",
        "        coordinator.add_node(\"node1\", NodeRole::Worker).await.unwrap();",
        "        coordinator.add_node(\"node2\", NodeRole::Worker).await.unwrap();",
        "        coordinator.add_node(\"node3\", NodeRole::Manager).await.unwrap();",
        "",
        "        // Assign roles",
        "        coordinator.assign_role(\"node1\", NodeRole::Manager).await.unwrap();",
        "",
        "        // Verify role assignment"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/distributed_tests.rs",
      "line": 142,
      "code": "coordinator.assign_role(\"node1\", NodeRole::Manager).await.unwrap();",
      "context": [
        "        coordinator.add_node(\"node1\", NodeRole::Worker).await.unwrap();",
        "        coordinator.add_node(\"node2\", NodeRole::Worker).await.unwrap();",
        "        coordinator.add_node(\"node3\", NodeRole::Manager).await.unwrap();",
        "",
        "        // Assign roles",
        "        coordinator.assign_role(\"node1\", NodeRole::Manager).await.unwrap();",
        "",
        "        // Verify role assignment",
        "        let role = coordinator.get_node_role(\"node1\").await.unwrap();",
        "        assert_eq!(role, NodeRole::Manager);",
        ""
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/distributed_tests.rs",
      "line": 145,
      "code": "let role = coordinator.get_node_role(\"node1\").await.unwrap();",
      "context": [
        "",
        "        // Assign roles",
        "        coordinator.assign_role(\"node1\", NodeRole::Manager).await.unwrap();",
        "",
        "        // Verify role assignment",
        "        let role = coordinator.get_node_role(\"node1\").await.unwrap();",
        "        assert_eq!(role, NodeRole::Manager);",
        "",
        "        // Get nodes by role",
        "        let managers = coordinator.get_nodes_by_role(NodeRole::Manager).await;",
        "        assert_eq!(managers.len(), 2);"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/distributed_tests.rs",
      "line": 161,
      "code": "coordinator.add_node(&format!(\"worker{}\", i), NodeRole::Worker).await.unwrap();",
      "context": [
        "    async fn test_coordinator_task_distribution() {",
        "        let coordinator = Arc::new(Coordinator::new(\"coord1\".to_string()));",
        "",
        "        // Add worker nodes",
        "        for i in 0..5 {",
        "            coordinator.add_node(&format!(\"worker{}\", i), NodeRole::Worker).await.unwrap();",
        "        }",
        "",
        "        // Distribute tasks",
        "        let mut task_distribution = HashMap::new();",
        ""
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/distributed_tests.rs",
      "line": 168,
      "code": "let assigned_node = coordinator.assign_task(&format!(\"task{}\", task_id)).await.unwrap();",
      "context": [
        "",
        "        // Distribute tasks",
        "        let mut task_distribution = HashMap::new();",
        "",
        "        for task_id in 0..100 {",
        "            let assigned_node = coordinator.assign_task(&format!(\"task{}\", task_id)).await.unwrap();",
        "            *task_distribution.entry(assigned_node).or_insert(0) += 1;",
        "        }",
        "",
        "        // Verify even distribution",
        "        for (_, count) in task_distribution {"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/distributed_tests.rs",
      "line": 183,
      "code": "coordinator.add_node(\"node1\", NodeRole::Worker).await.unwrap();",
      "context": [
        "    #[tokio::test]",
        "    async fn test_coordinator_heartbeat_monitoring() {",
        "        let coordinator = Coordinator::new(\"coord1\".to_string());",
        "",
        "        // Add nodes",
        "        coordinator.add_node(\"node1\", NodeRole::Worker).await.unwrap();",
        "        coordinator.add_node(\"node2\", NodeRole::Worker).await.unwrap();",
        "",
        "        // Start heartbeat monitoring",
        "        coordinator.start_heartbeat_monitoring(Duration::from_millis(100)).await;",
        ""
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/distributed_tests.rs",
      "line": 184,
      "code": "coordinator.add_node(\"node2\", NodeRole::Worker).await.unwrap();",
      "context": [
        "    async fn test_coordinator_heartbeat_monitoring() {",
        "        let coordinator = Coordinator::new(\"coord1\".to_string());",
        "",
        "        // Add nodes",
        "        coordinator.add_node(\"node1\", NodeRole::Worker).await.unwrap();",
        "        coordinator.add_node(\"node2\", NodeRole::Worker).await.unwrap();",
        "",
        "        // Start heartbeat monitoring",
        "        coordinator.start_heartbeat_monitoring(Duration::from_millis(100)).await;",
        "",
        "        // Send heartbeats"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/distributed_tests.rs",
      "line": 218,
      "code": "coordinator.add_node(&node_id, NodeRole::Worker).await.unwrap();",
      "context": [
        "        // Add nodes with message handlers",
        "        let received_messages = Arc::new(RwLock::new(Vec::new()));",
        "",
        "        for i in 0..3 {",
        "            let node_id = format!(\"node{}\", i);",
        "            coordinator.add_node(&node_id, NodeRole::Worker).await.unwrap();",
        "",
        "            let messages_clone = received_messages.clone();",
        "            coordinator.register_message_handler(&node_id, move |msg| {",
        "                let messages = messages_clone.clone();",
        "                Box::pin(async move {"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/distributed_tests.rs",
      "line": 231,
      "code": "coordinator.broadcast(message).await.unwrap();",
      "context": [
        "            }).await;",
        "        }",
        "",
        "        // Broadcast message",
        "        let message = CoordinationMessage::new(\"test_broadcast\", serde_json::json!({\"data\": \"test\"}));",
        "        coordinator.broadcast(message).await.unwrap();",
        "",
        "        // Wait for propagation",
        "        tokio::time::sleep(Duration::from_millis(100)).await;",
        "",
        "        // All nodes should have received the message"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/distributed_tests.rs",
      "line": 263,
      "code": "let new_primary = failover.get_active_server().await.unwrap();",
      "context": [
        "",
        "        // Simulate primary failure",
        "        failover.mark_server_failed(&primary.id()).await;",
        "",
        "        // Should automatically failover",
        "        let new_primary = failover.get_active_server().await.unwrap();",
        "        assert_ne!(new_primary.id(), primary.id());",
        "        assert!(new_primary.id() == backup1.id() || new_primary.id() == backup2.id());",
        "",
        "        // Check failover event",
        "        let events = failover.get_failover_events().await;"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/distributed_tests.rs",
      "line": 285,
      "code": "failover.trigger_failover().await.unwrap();",
      "context": [
        "",
        "        failover.set_primary(primary.clone()).await;",
        "        failover.add_backup(backup.clone()).await;",
        "",
        "        // Manual failover",
        "        failover.trigger_failover().await.unwrap();",
        "",
        "        // Should switch to backup",
        "        let active = failover.get_active_server().await.unwrap();",
        "        assert_eq!(active.id(), backup.id());",
        "    }"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/distributed_tests.rs",
      "line": 288,
      "code": "let active = failover.get_active_server().await.unwrap();",
      "context": [
        "",
        "        // Manual failover",
        "        failover.trigger_failover().await.unwrap();",
        "",
        "        // Should switch to backup",
        "        let active = failover.get_active_server().await.unwrap();",
        "        assert_eq!(active.id(), backup.id());",
        "    }",
        "",
        "    #[tokio::test]",
        "    async fn test_failover_priority_based() {"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/distributed_tests.rs",
      "line": 308,
      "code": "let active = failover.get_active_server().await.unwrap();",
      "context": [
        "",
        "        // Trigger failover",
        "        failover.mark_server_failed(&primary.id()).await;",
        "",
        "        // Should select high priority backup",
        "        let active = failover.get_active_server().await.unwrap();",
        "        assert_eq!(active.id(), high_priority.id());",
        "    }",
        "",
        "    #[tokio::test]",
        "    async fn test_failover_cascading_failures() {"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/distributed_tests.rs",
      "line": 329,
      "code": "let first_backup = failover.get_active_server().await.unwrap();",
      "context": [
        "            failover.add_backup(backup.clone()).await;",
        "        }",
        "",
        "        // Simulate cascading failures",
        "        failover.mark_server_failed(&primary.id()).await;",
        "        let first_backup = failover.get_active_server().await.unwrap();",
        "",
        "        failover.mark_server_failed(&first_backup.id()).await;",
        "        let second_backup = failover.get_active_server().await.unwrap();",
        "",
        "        // Should have different active servers"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/distributed_tests.rs",
      "line": 332,
      "code": "let second_backup = failover.get_active_server().await.unwrap();",
      "context": [
        "        // Simulate cascading failures",
        "        failover.mark_server_failed(&primary.id()).await;",
        "        let first_backup = failover.get_active_server().await.unwrap();",
        "",
        "        failover.mark_server_failed(&first_backup.id()).await;",
        "        let second_backup = failover.get_active_server().await.unwrap();",
        "",
        "        // Should have different active servers",
        "        assert_ne!(first_backup.id(), second_backup.id());",
        "",
        "        // Verify failover history"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/distributed_tests.rs",
      "line": 354,
      "code": "assert_eq!(failover.get_active_server().await.unwrap().id(), backup.id());",
      "context": [
        "        failover.set_primary(primary.clone()).await;",
        "        failover.add_backup(backup.clone()).await;",
        "",
        "        // Fail primary",
        "        failover.mark_server_failed(&primary.id()).await;",
        "        assert_eq!(failover.get_active_server().await.unwrap().id(), backup.id());",
        "",
        "        // Recover primary",
        "        failover.mark_server_recovered(&primary.id()).await;",
        "",
        "        // With auto-recovery enabled, should switch back"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/distributed_tests.rs",
      "line": 363,
      "code": "assert_eq!(failover.get_active_server().await.unwrap().id(), primary.id());",
      "context": [
        "",
        "        // With auto-recovery enabled, should switch back",
        "        failover.enable_auto_recovery(true).await;",
        "        failover.check_recovery().await;",
        "",
        "        assert_eq!(failover.get_active_server().await.unwrap().id(), primary.id());",
        "    }",
        "}",
        "",
        "#[cfg(test)]",
        "mod shard_manager_tests {"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/distributed_tests.rs",
      "line": 383,
      "code": "shard_manager.add_node(&format!(\"node{}\", i)).await.unwrap();",
      "context": [
        "",
        "        let mut shard_manager = ShardManager::new(config);",
        "",
        "        // Add nodes",
        "        for i in 0..5 {",
        "            shard_manager.add_node(&format!(\"node{}\", i)).await.unwrap();",
        "        }",
        "",
        "        // Test key distribution",
        "        let mut shard_distribution = HashMap::new();",
        ""
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/distributed_tests.rs",
      "line": 413,
      "code": "shard_manager.add_node(&format!(\"node{}\", i)).await.unwrap();",
      "context": [
        "",
        "        let mut shard_manager = ShardManager::new(config);",
        "",
        "        // Initial nodes",
        "        for i in 0..3 {",
        "            shard_manager.add_node(&format!(\"node{}\", i)).await.unwrap();",
        "        }",
        "",
        "        // Get initial distribution",
        "        let initial_assignments = shard_manager.get_shard_assignments().await;",
        ""
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/distributed_tests.rs",
      "line": 420,
      "code": "shard_manager.add_node(\"node3\").await.unwrap();",
      "context": [
        "",
        "        // Get initial distribution",
        "        let initial_assignments = shard_manager.get_shard_assignments().await;",
        "",
        "        // Add new node",
        "        shard_manager.add_node(\"node3\").await.unwrap();",
        "",
        "        // Trigger rebalancing",
        "        let migrations = shard_manager.rebalance().await.unwrap();",
        "",
        "        // Should have migration plans"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/distributed_tests.rs",
      "line": 423,
      "code": "let migrations = shard_manager.rebalance().await.unwrap();",
      "context": [
        "",
        "        // Add new node",
        "        shard_manager.add_node(\"node3\").await.unwrap();",
        "",
        "        // Trigger rebalancing",
        "        let migrations = shard_manager.rebalance().await.unwrap();",
        "",
        "        // Should have migration plans",
        "        assert!(!migrations.is_empty());",
        "",
        "        // Verify new distribution is more balanced"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/distributed_tests.rs",
      "line": 445,
      "code": "shard_manager.add_node(&format!(\"node{}\", i)).await.unwrap();",
      "context": [
        "",
        "        let mut shard_manager = ShardManager::new(config);",
        "",
        "        // Add nodes",
        "        for i in 0..5 {",
        "            shard_manager.add_node(&format!(\"node{}\", i)).await.unwrap();",
        "        }",
        "",
        "        // Check replication",
        "        for shard_id in 0..8 {",
        "            let replicas = shard_manager.get_shard_replicas(shard_id).await.unwrap();"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/distributed_tests.rs",
      "line": 450,
      "code": "let replicas = shard_manager.get_shard_replicas(shard_id).await.unwrap();",
      "context": [
        "            shard_manager.add_node(&format!(\"node{}\", i)).await.unwrap();",
        "        }",
        "",
        "        // Check replication",
        "        for shard_id in 0..8 {",
        "            let replicas = shard_manager.get_shard_replicas(shard_id).await.unwrap();",
        "            assert_eq!(replicas.len(), 3, \"Each shard should have 3 replicas\");",
        "",
        "            // Replicas should be on different nodes",
        "            let unique_nodes: std::collections::HashSet<_> = replicas.into_iter().collect();",
        "            assert_eq!(unique_nodes.len(), 3, \"Replicas should be on different nodes\");"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/distributed_tests.rs",
      "line": 471,
      "code": "shard_manager.add_node(&format!(\"node{}\", i)).await.unwrap();",
      "context": [
        "",
        "        let mut shard_manager = ShardManager::new(config);",
        "",
        "        // Add nodes",
        "        for i in 0..6 {",
        "            shard_manager.add_node(&format!(\"node{}\", i)).await.unwrap();",
        "        }",
        "",
        "        // Simulate node failure",
        "        shard_manager.mark_node_failed(\"node2\").await.unwrap();",
        ""
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/distributed_tests.rs",
      "line": 475,
      "code": "shard_manager.mark_node_failed(\"node2\").await.unwrap();",
      "context": [
        "        for i in 0..6 {",
        "            shard_manager.add_node(&format!(\"node{}\", i)).await.unwrap();",
        "        }",
        "",
        "        // Simulate node failure",
        "        shard_manager.mark_node_failed(\"node2\").await.unwrap();",
        "",
        "        // All shards should still be accessible",
        "        for shard_id in 0..10 {",
        "            let available_replicas = shard_manager.get_available_replicas(shard_id).await.unwrap();",
        "            assert!(available_replicas.len() >= 2, \"Should have at least 2 available replicas\");"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/distributed_tests.rs",
      "line": 479,
      "code": "let available_replicas = shard_manager.get_available_replicas(shard_id).await.unwrap();",
      "context": [
        "        // Simulate node failure",
        "        shard_manager.mark_node_failed(\"node2\").await.unwrap();",
        "",
        "        // All shards should still be accessible",
        "        for shard_id in 0..10 {",
        "            let available_replicas = shard_manager.get_available_replicas(shard_id).await.unwrap();",
        "            assert!(available_replicas.len() >= 2, \"Should have at least 2 available replicas\");",
        "        }",
        "",
        "        // Should trigger re-replication",
        "        let replication_tasks = shard_manager.get_pending_replications().await;"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/distributed_tests.rs",
      "line": 508,
      "code": "let selected = lb.select_server(&request).await.unwrap();",
      "context": [
        "        lb.add_server(us_west.clone()).await;",
        "        lb.add_server(eu_west.clone()).await;",
        "",
        "        // Request from us-east client",
        "        let request = create_request_with_metadata(\"client_region\", \"us-east\");",
        "        let selected = lb.select_server(&request).await.unwrap();",
        "        assert_eq!(selected.id(), \"us-east-1\");",
        "",
        "        // Request from eu-west client",
        "        let request = create_request_with_metadata(\"client_region\", \"eu-west\");",
        "        let selected = lb.select_server(&request).await.unwrap();"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/distributed_tests.rs",
      "line": 513,
      "code": "let selected = lb.select_server(&request).await.unwrap();",
      "context": [
        "        let selected = lb.select_server(&request).await.unwrap();",
        "        assert_eq!(selected.id(), \"us-east-1\");",
        "",
        "        // Request from eu-west client",
        "        let request = create_request_with_metadata(\"client_region\", \"eu-west\");",
        "        let selected = lb.select_server(&request).await.unwrap();",
        "        assert_eq!(selected.id(), \"eu-west-1\");",
        "    }",
        "",
        "    #[tokio::test]",
        "    async fn test_distributed_load_balancer_affinity() {"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/distributed_tests.rs",
      "line": 532,
      "code": "let selected = lb.select_server(&request).await.unwrap();",
      "context": [
        "        let session_id = \"session123\";",
        "        let mut selected_servers = std::collections::HashSet::new();",
        "",
        "        for _ in 0..10 {",
        "            let request = create_request_with_metadata(\"session_id\", session_id);",
        "            let selected = lb.select_server(&request).await.unwrap();",
        "            selected_servers.insert(selected.id().to_string());",
        "        }",
        "",
        "        assert_eq!(selected_servers.len(), 1, \"All requests from same session should go to same server\");",
        "    }"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/tests/distributed_tests.rs",
      "line": 557,
      "code": "let selected = lb.select_server(&request).await.unwrap();",
      "context": [
        "        // Send many requests and count distribution",
        "        let mut distribution = HashMap::new();",
        "",
        "        for i in 0..1000 {",
        "            let request = MCPRequest::new(\"test\", serde_json::json!({\"i\": i}));",
        "            let selected = lb.select_server(&request).await.unwrap();",
        "            *distribution.entry(selected.id().to_string()).or_insert(0) += 1;",
        "        }",
        "",
        "        // High capacity should get approximately 4x more than low capacity",
        "        let high_count = distribution[\"high-cap\"];"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/plugin/discovery.rs",
      "line": 590,
      "code": ").unwrap();",
      "context": [
        "    #[test]",
        "    fn test_plugin_matcher() {",
        "        let matcher = PluginMatcher::new(",
        "            &[\"*.so\".to_string(), \"*.dll\".to_string()],",
        "            &[\"*test*\".to_string()],",
        "        ).unwrap();",
        "",
        "        assert!(matcher.matches(Path::new(\"plugin.so\")));",
        "        assert!(matcher.matches(Path::new(\"my_plugin.dll\")));",
        "        assert!(!matcher.matches(Path::new(\"plugin_test.so\")));",
        "        assert!(!matcher.matches(Path::new(\"plugin.txt\")));"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/plugin/mod.rs",
      "line": 443,
      "code": "let cap = Capability::parse(\"docker.container.create:1\").unwrap();",
      "context": [
        "mod tests {",
        "    use super::*;",
        "",
        "    #[test]",
        "    fn test_capability_parsing() {",
        "        let cap = Capability::parse(\"docker.container.create:1\").unwrap();",
        "        assert_eq!(cap.namespace, \"docker\");",
        "        assert_eq!(cap.name, \"container.create\");",
        "        assert_eq!(cap.version, 1);",
        "",
        "        let cap_str = cap.to_string();"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/mcp_manager/optimization/prefetch.rs",
      "line": 643,
      "code": "self.stats.read().unwrap().clone()",
      "context": [
        "        }",
        "    }",
        "",
        "    /// Get statistics",
        "    pub fn get_stats(&self) -> PrefetchStats {",
        "        self.stats.read().unwrap().clone()",
        "    }",
        "}",
        "",
        "#[cfg(test)]",
        "mod tests {"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex_bashgod/mcp_integration/server_manager.rs",
      "line": 475,
      "code": "let servers = manager.list_servers().await.unwrap();",
      "context": [
        "            settings: Default::default(),",
        "        };",
        "",
        "        let manager = MCPServerManager::new(vec![config]);",
        "",
        "        let servers = manager.list_servers().await.unwrap();",
        "        assert_eq!(servers.len(), 1);",
        "        assert_eq!(servers[0].name, \"test-server\");",
        "    }",
        "",
        "    #[test]"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/engine_tests.rs",
      "line": 19,
      "code": "let engine = SynthexEngine::new(config).await.unwrap();",
      "context": [
        "    use super::super::test_utils::*;",
        "",
        "    #[tokio::test]",
        "    async fn test_engine_initialization() {",
        "        let config = test_config();",
        "        let engine = SynthexEngine::new(config).await.unwrap();",
        "",
        "        assert_eq!(engine.agent_count(), 0); // No agents registered yet",
        "        assert!(engine.is_ready());",
        "    }",
        ""
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/engine_tests.rs",
      "line": 33,
      "code": "engine_guard.register_agent(agent1).await.unwrap();",
      "context": [
        "        let mut engine_guard = engine.write().await;",
        "",
        "        let agent1 = Box::new(MockTestAgent::new(\"agent1\".to_string()));",
        "        let agent2 = Box::new(MockTestAgent::new(\"agent2\".to_string()));",
        "",
        "        engine_guard.register_agent(agent1).await.unwrap();",
        "        engine_guard.register_agent(agent2).await.unwrap();",
        "",
        "        assert_eq!(engine_guard.agent_count(), 2);",
        "    }",
        ""
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/engine_tests.rs",
      "line": 34,
      "code": "engine_guard.register_agent(agent2).await.unwrap();",
      "context": [
        "",
        "        let agent1 = Box::new(MockTestAgent::new(\"agent1\".to_string()));",
        "        let agent2 = Box::new(MockTestAgent::new(\"agent2\".to_string()));",
        "",
        "        engine_guard.register_agent(agent1).await.unwrap();",
        "        engine_guard.register_agent(agent2).await.unwrap();",
        "",
        "        assert_eq!(engine_guard.agent_count(), 2);",
        "    }",
        "",
        "    #[tokio::test]"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/engine_tests.rs",
      "line": 47,
      "code": "engine_guard.register_agent(agent1).await.unwrap();",
      "context": [
        "        let mut engine_guard = engine.write().await;",
        "",
        "        let agent1 = Box::new(MockTestAgent::new(\"duplicate\".to_string()));",
        "        let agent2 = Box::new(MockTestAgent::new(\"duplicate\".to_string()));",
        "",
        "        engine_guard.register_agent(agent1).await.unwrap();",
        "        let result = engine_guard.register_agent(agent2).await;",
        "",
        "        assert!(result.is_err());",
        "        match result {",
        "            Err(SynthexError::DuplicateAgent(id)) => {"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/engine_tests.rs",
      "line": 67,
      "code": "engine_guard.register_agent(agent).await.unwrap();",
      "context": [
        "        let mut engine_guard = engine.write().await;",
        "",
        "        // Register test agents",
        "        for i in 0..3 {",
        "            let agent = Box::new(MockTestAgent::new(format!(\"search_agent_{}\", i)));",
        "            engine_guard.register_agent(agent).await.unwrap();",
        "        }",
        "",
        "        drop(engine_guard); // Release write lock",
        "",
        "        let query = QueryBuilder::new(\"test search query\")"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/engine_tests.rs",
      "line": 77,
      "code": "let results = engine_guard.search(&query).await.unwrap();",
      "context": [
        "        let query = QueryBuilder::new(\"test search query\")",
        "            .with_max_results(10)",
        "            .build();",
        "",
        "        let engine_guard = engine.read().await;",
        "        let results = engine_guard.search(&query).await.unwrap();",
        "",
        "        assert_eq!(results.len(), 3); // One result per agent",
        "        for result in &results {",
        "            assert!(result.content.contains(\"test search query\"));",
        "            assert!(result.relevance > 0.0);"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/engine_tests.rs",
      "line": 97,
      "code": "engine_guard.register_agent(agent).await.unwrap();",
      "context": [
        "        for i in 0..5 {",
        "            let agent = Box::new(",
        "                MockTestAgent::new(format!(\"parallel_agent_{}\", i))",
        "                    .with_delay(i * 100) // Different delays",
        "            );",
        "            engine_guard.register_agent(agent).await.unwrap();",
        "        }",
        "",
        "        drop(engine_guard);",
        "",
        "        let query = QueryBuilder::new(\"parallel test\")"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/engine_tests.rs",
      "line": 108,
      "code": "let results = engine_guard.search(&query).await.unwrap();",
      "context": [
        "            .with_parallel_execution(true)",
        "            .build();",
        "",
        "        let start = std::time::Instant::now();",
        "        let engine_guard = engine.read().await;",
        "        let results = engine_guard.search(&query).await.unwrap();",
        "        let elapsed = start.elapsed().as_millis();",
        "",
        "        assert_eq!(results.len(), 5);",
        "        // Should complete faster than sequential (< 1000ms instead of 1500ms)",
        "        assert!(elapsed < 1000, \"Parallel execution too slow: {}ms\", elapsed);"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/engine_tests.rs",
      "line": 122,
      "code": "engine_guard.register_agent(agent).await.unwrap();",
      "context": [
        "    async fn test_engine_caching() {",
        "        let engine = test_engine().await;",
        "        let mut engine_guard = engine.write().await;",
        "",
        "        let agent = Box::new(MockTestAgent::new(\"cache_test\".to_string()));",
        "        engine_guard.register_agent(agent).await.unwrap();",
        "",
        "        drop(engine_guard);",
        "",
        "        let query = QueryBuilder::new(\"cached query\")",
        "            .with_cache_enabled(true)"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/engine_tests.rs",
      "line": 133,
      "code": "let results1 = engine_guard.search(&query).await.unwrap();",
      "context": [
        "            .build();",
        "",
        "        // First search - should hit agent",
        "        let engine_guard = engine.read().await;",
        "        let start1 = std::time::Instant::now();",
        "        let results1 = engine_guard.search(&query).await.unwrap();",
        "        let time1 = start1.elapsed().as_millis();",
        "",
        "        // Second search - should hit cache",
        "        let start2 = std::time::Instant::now();",
        "        let results2 = engine_guard.search(&query).await.unwrap();"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/engine_tests.rs",
      "line": 138,
      "code": "let results2 = engine_guard.search(&query).await.unwrap();",
      "context": [
        "        let results1 = engine_guard.search(&query).await.unwrap();",
        "        let time1 = start1.elapsed().as_millis();",
        "",
        "        // Second search - should hit cache",
        "        let start2 = std::time::Instant::now();",
        "        let results2 = engine_guard.search(&query).await.unwrap();",
        "        let time2 = start2.elapsed().as_millis();",
        "",
        "        assert_eq!(results1.len(), results2.len());",
        "        assert!(time2 < time1 / 2, \"Cache not effective: {}ms vs {}ms\", time2, time1);",
        "    }"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/engine_tests.rs",
      "line": 153,
      "code": ").await.unwrap();",
      "context": [
        "        let mut engine_guard = engine.write().await;",
        "",
        "        // Mix of successful and failing agents",
        "        engine_guard.register_agent(",
        "            Box::new(MockTestAgent::new(\"success1\".to_string()))",
        "        ).await.unwrap();",
        "",
        "        engine_guard.register_agent(",
        "            Box::new(MockTestAgent::new(\"fail1\".to_string()).with_failure())",
        "        ).await.unwrap();",
        ""
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/engine_tests.rs",
      "line": 157,
      "code": ").await.unwrap();",
      "context": [
        "            Box::new(MockTestAgent::new(\"success1\".to_string()))",
        "        ).await.unwrap();",
        "",
        "        engine_guard.register_agent(",
        "            Box::new(MockTestAgent::new(\"fail1\".to_string()).with_failure())",
        "        ).await.unwrap();",
        "",
        "        engine_guard.register_agent(",
        "            Box::new(MockTestAgent::new(\"success2\".to_string()))",
        "        ).await.unwrap();",
        ""
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/engine_tests.rs",
      "line": 161,
      "code": ").await.unwrap();",
      "context": [
        "            Box::new(MockTestAgent::new(\"fail1\".to_string()).with_failure())",
        "        ).await.unwrap();",
        "",
        "        engine_guard.register_agent(",
        "            Box::new(MockTestAgent::new(\"success2\".to_string()))",
        "        ).await.unwrap();",
        "",
        "        drop(engine_guard);",
        "",
        "        let query = QueryBuilder::new(\"error test\").build();",
        "        let engine_guard = engine.read().await;"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/engine_tests.rs",
      "line": 167,
      "code": "let results = engine_guard.search(&query).await.unwrap();",
      "context": [
        "",
        "        drop(engine_guard);",
        "",
        "        let query = QueryBuilder::new(\"error test\").build();",
        "        let engine_guard = engine.read().await;",
        "        let results = engine_guard.search(&query).await.unwrap();",
        "",
        "        // Should get results from successful agents only",
        "        assert_eq!(results.len(), 2);",
        "        assert!(results.iter().all(|r| !r.source.contains(\"fail\")));",
        "    }"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/engine_tests.rs",
      "line": 179,
      "code": "let engine = SynthexEngine::new(config).await.unwrap();",
      "context": [
        "    #[tokio::test]",
        "    async fn test_engine_resource_management() {",
        "        let mut config = test_config();",
        "        config.max_concurrent_agents = 3;",
        "",
        "        let engine = SynthexEngine::new(config).await.unwrap();",
        "        let engine = Arc::new(RwLock::new(engine));",
        "        let mut engine_guard = engine.write().await;",
        "",
        "        // Register more agents than max concurrent",
        "        for i in 0..10 {"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/engine_tests.rs",
      "line": 189,
      "code": "engine_guard.register_agent(agent).await.unwrap();",
      "context": [
        "        for i in 0..10 {",
        "            let agent = Box::new(",
        "                MockTestAgent::new(format!(\"resource_agent_{}\", i))",
        "                    .with_delay(100)",
        "            );",
        "            engine_guard.register_agent(agent).await.unwrap();",
        "        }",
        "",
        "        drop(engine_guard);",
        "",
        "        let query = QueryBuilder::new(\"resource test\")"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/engine_tests.rs",
      "line": 200,
      "code": "let results = engine_guard.search(&query).await.unwrap();",
      "context": [
        "            .with_parallel_execution(true)",
        "            .build();",
        "",
        "        let start = std::time::Instant::now();",
        "        let engine_guard = engine.read().await;",
        "        let results = engine_guard.search(&query).await.unwrap();",
        "        let elapsed = start.elapsed().as_millis();",
        "",
        "        assert_eq!(results.len(), 10);",
        "        // Should batch process with max 3 concurrent",
        "        assert!(elapsed >= 300, \"Too fast, batching not working: {}ms\", elapsed);"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/engine_tests.rs",
      "line": 217,
      "code": "engine_guard.register_agent(agent).await.unwrap();",
      "context": [
        "        let mut engine_guard = engine.write().await;",
        "",
        "        // Register agents",
        "        for i in 0..5 {",
        "            let agent = Box::new(MockTestAgent::new(format!(\"shutdown_{}\", i)));",
        "            engine_guard.register_agent(agent).await.unwrap();",
        "        }",
        "",
        "        // Shutdown",
        "        engine_guard.shutdown().await.unwrap();",
        ""
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/engine_tests.rs",
      "line": 221,
      "code": "engine_guard.shutdown().await.unwrap();",
      "context": [
        "            let agent = Box::new(MockTestAgent::new(format!(\"shutdown_{}\", i)));",
        "            engine_guard.register_agent(agent).await.unwrap();",
        "        }",
        "",
        "        // Shutdown",
        "        engine_guard.shutdown().await.unwrap();",
        "",
        "        assert_eq!(engine_guard.agent_count(), 0);",
        "        assert!(!engine_guard.is_ready());",
        "",
        "        // Further operations should fail"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/engine_tests.rs",
      "line": 238,
      "code": "engine_guard.register_agent(agent).await.unwrap();",
      "context": [
        "    async fn test_engine_metrics() {",
        "        let engine = test_engine().await;",
        "        let mut engine_guard = engine.write().await;",
        "",
        "        let agent = Box::new(MockTestAgent::new(\"metrics_test\".to_string()));",
        "        engine_guard.register_agent(agent).await.unwrap();",
        "",
        "        drop(engine_guard);",
        "",
        "        // Perform several searches",
        "        for i in 0..10 {"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/agent_tests.rs",
      "line": 49,
      "code": "let temp_dir = TempDir::new().unwrap();",
      "context": [
        "    #[tokio::test]",
        "    async fn test_file_agent_search() {",
        "        use tempfile::TempDir;",
        "        use std::fs;",
        "",
        "        let temp_dir = TempDir::new().unwrap();",
        "        let test_file = temp_dir.path().join(\"test.txt\");",
        "        fs::write(&test_file, \"This is test content for SYNTHEX\").unwrap();",
        "",
        "        let config = FileAgentConfig {",
        "            root_path: temp_dir.path().to_path_buf(),"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/agent_tests.rs",
      "line": 51,
      "code": "fs::write(&test_file, \"This is test content for SYNTHEX\").unwrap();",
      "context": [
        "        use tempfile::TempDir;",
        "        use std::fs;",
        "",
        "        let temp_dir = TempDir::new().unwrap();",
        "        let test_file = temp_dir.path().join(\"test.txt\");",
        "        fs::write(&test_file, \"This is test content for SYNTHEX\").unwrap();",
        "",
        "        let config = FileAgentConfig {",
        "            root_path: temp_dir.path().to_path_buf(),",
        "            allowed_extensions: vec![\"txt\".to_string()],",
        "            max_file_size_mb: 10,"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/agent_tests.rs",
      "line": 65,
      "code": "let results = agent.execute(&query).await.unwrap();",
      "context": [
        "        let agent = FileAgent::new(\"test_files\", config);",
        "        let query = QueryBuilder::new(\"test content\")",
        "            .with_max_results(5)",
        "            .build();",
        "",
        "        let results = agent.execute(&query).await.unwrap();",
        "        assert!(!results.is_empty());",
        "        assert!(results[0].content.contains(\"test content\"));",
        "    }",
        "",
        "    #[tokio::test]"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/agent_tests.rs",
      "line": 99,
      "code": "agent.add_document(\"doc1\", \"SYNTHEX is a high-performance search system\").await.unwrap();",
      "context": [
        "        };",
        "",
        "        let mut agent = KnowledgeBaseAgent::new(\"test_kb\", config);",
        "",
        "        // Add test documents",
        "        agent.add_document(\"doc1\", \"SYNTHEX is a high-performance search system\").await.unwrap();",
        "        agent.add_document(\"doc2\", \"It uses multiple agents for parallel execution\").await.unwrap();",
        "",
        "        let query = QueryBuilder::new(\"SYNTHEX performance\")",
        "            .with_max_results(10)",
        "            .build();"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/agent_tests.rs",
      "line": 100,
      "code": "agent.add_document(\"doc2\", \"It uses multiple agents for parallel execution\").await.unwrap();",
      "context": [
        "",
        "        let mut agent = KnowledgeBaseAgent::new(\"test_kb\", config);",
        "",
        "        // Add test documents",
        "        agent.add_document(\"doc1\", \"SYNTHEX is a high-performance search system\").await.unwrap();",
        "        agent.add_document(\"doc2\", \"It uses multiple agents for parallel execution\").await.unwrap();",
        "",
        "        let query = QueryBuilder::new(\"SYNTHEX performance\")",
        "            .with_max_results(10)",
        "            .build();",
        ""
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/agent_tests.rs",
      "line": 106,
      "code": "let results = agent.execute(&query).await.unwrap();",
      "context": [
        "",
        "        let query = QueryBuilder::new(\"SYNTHEX performance\")",
        "            .with_max_results(10)",
        "            .build();",
        "",
        "        let results = agent.execute(&query).await.unwrap();",
        "        assert!(!results.is_empty());",
        "        assert!(results[0].relevance > 0.5);",
        "    }",
        "",
        "    #[tokio::test]"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/agent_tests.rs",
      "line": 170,
      "code": "tx_clone.send((agent.id().to_string(), result)).await.unwrap();",
      "context": [
        "            let query_clone = query.clone();",
        "            let tx_clone = tx.clone();",
        "",
        "            let handle = tokio::spawn(async move {",
        "                let result = agent.execute(&query_clone).await;",
        "                tx_clone.send((agent.id().to_string(), result)).await.unwrap();",
        "            });",
        "",
        "            handles.push(handle);",
        "        }",
        ""
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/agent_tests.rs",
      "line": 187,
      "code": "let search_results = result.unwrap();",
      "context": [
        "        }",
        "",
        "        assert_eq!(results.len(), 3);",
        "        for (agent_id, result) in results {",
        "            assert!(result.is_ok());",
        "            let search_results = result.unwrap();",
        "            assert!(!search_results.is_empty());",
        "            assert!(search_results[0].content.contains(&agent_id));",
        "        }",
        "    }",
        ""
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/integration_tests.rs",
      "line": 32,
      "code": "let service = SynthexService::new(config).await.unwrap();",
      "context": [
        "            max_retries: 3,",
        "            batch_size: 20,",
        "            memory_limit_mb: 1024,",
        "        };",
        "",
        "        let service = SynthexService::new(config).await.unwrap();",
        "",
        "        // Register different agent types",
        "        service.register_agent(",
        "            Box::new(MockTestAgent::new(\"mock1\".to_string()))",
        "        ).await.unwrap();"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/integration_tests.rs",
      "line": 37,
      "code": ").await.unwrap();",
      "context": [
        "        let service = SynthexService::new(config).await.unwrap();",
        "",
        "        // Register different agent types",
        "        service.register_agent(",
        "            Box::new(MockTestAgent::new(\"mock1\".to_string()))",
        "        ).await.unwrap();",
        "",
        "        service.register_agent(",
        "            Box::new(FileAgent::new(\"files\", FileAgentConfig {",
        "                root_path: std::env::temp_dir(),",
        "                allowed_extensions: vec![\"txt\".to_string(), \"md\".to_string()],"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/integration_tests.rs",
      "line": 46,
      "code": ").await.unwrap();",
      "context": [
        "                root_path: std::env::temp_dir(),",
        "                allowed_extensions: vec![\"txt\".to_string(), \"md\".to_string()],",
        "                max_file_size_mb: 10,",
        "                enable_content_indexing: true,",
        "            }))",
        "        ).await.unwrap();",
        "",
        "        // Execute complex query",
        "        let query = QueryBuilder::new(\"integration test\")",
        "            .with_context(\"testing full pipeline\")",
        "            .with_max_results(20)"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/integration_tests.rs",
      "line": 56,
      "code": "let results = service.search(&query).await.unwrap();",
      "context": [
        "            .with_max_results(20)",
        "            .with_parallel_execution(true)",
        "            .with_cache_enabled(true)",
        "            .build();",
        "",
        "        let results = service.search(&query).await.unwrap();",
        "",
        "        assert!(!results.is_empty());",
        "        assert!(results.iter().all(|r| r.relevance >= 0.0 && r.relevance <= 1.0));",
        "    }",
        ""
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/integration_tests.rs",
      "line": 72,
      "code": "engine_guard.register_agent(api_agent).await.unwrap();",
      "context": [
        "        // Create agents with different capabilities",
        "        let api_agent = Box::new(MockTestAgent::new(\"api\".to_string()));",
        "        let db_agent = Box::new(MockTestAgent::new(\"database\".to_string()));",
        "        let file_agent = Box::new(MockTestAgent::new(\"files\".to_string()));",
        "",
        "        engine_guard.register_agent(api_agent).await.unwrap();",
        "        engine_guard.register_agent(db_agent).await.unwrap();",
        "        engine_guard.register_agent(file_agent).await.unwrap();",
        "",
        "        drop(engine_guard);",
        ""
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/integration_tests.rs",
      "line": 73,
      "code": "engine_guard.register_agent(db_agent).await.unwrap();",
      "context": [
        "        let api_agent = Box::new(MockTestAgent::new(\"api\".to_string()));",
        "        let db_agent = Box::new(MockTestAgent::new(\"database\".to_string()));",
        "        let file_agent = Box::new(MockTestAgent::new(\"files\".to_string()));",
        "",
        "        engine_guard.register_agent(api_agent).await.unwrap();",
        "        engine_guard.register_agent(db_agent).await.unwrap();",
        "        engine_guard.register_agent(file_agent).await.unwrap();",
        "",
        "        drop(engine_guard);",
        "",
        "        // Complex query requiring multiple agents"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/integration_tests.rs",
      "line": 74,
      "code": "engine_guard.register_agent(file_agent).await.unwrap();",
      "context": [
        "        let db_agent = Box::new(MockTestAgent::new(\"database\".to_string()));",
        "        let file_agent = Box::new(MockTestAgent::new(\"files\".to_string()));",
        "",
        "        engine_guard.register_agent(api_agent).await.unwrap();",
        "        engine_guard.register_agent(db_agent).await.unwrap();",
        "        engine_guard.register_agent(file_agent).await.unwrap();",
        "",
        "        drop(engine_guard);",
        "",
        "        // Complex query requiring multiple agents",
        "        let query = QueryBuilder::new(\"user data from multiple sources\")"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/integration_tests.rs",
      "line": 85,
      "code": "let results = engine_guard.search(&query).await.unwrap();",
      "context": [
        "            .with_filters(vec![\"source:api\".to_string(), \"source:database\".to_string()])",
        "            .with_parallel_execution(true)",
        "            .build();",
        "",
        "        let engine_guard = engine.read().await;",
        "        let results = engine_guard.search(&query).await.unwrap();",
        "",
        "        // Should have results from multiple agents",
        "        let sources: std::collections::HashSet<_> = results.iter()",
        "            .map(|r| r.source.clone())",
        "            .collect();"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/integration_tests.rs",
      "line": 166,
      "code": ").await.unwrap();",
      "context": [
        "        let mut engine_guard = engine.write().await;",
        "",
        "        // Mix of reliable and unreliable agents",
        "        engine_guard.register_agent(",
        "            Box::new(MockTestAgent::new(\"reliable1\".to_string()))",
        "        ).await.unwrap();",
        "",
        "        engine_guard.register_agent(",
        "            Box::new(MockTestAgent::new(\"unreliable1\".to_string()).with_failure())",
        "        ).await.unwrap();",
        ""
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/integration_tests.rs",
      "line": 170,
      "code": ").await.unwrap();",
      "context": [
        "            Box::new(MockTestAgent::new(\"reliable1\".to_string()))",
        "        ).await.unwrap();",
        "",
        "        engine_guard.register_agent(",
        "            Box::new(MockTestAgent::new(\"unreliable1\".to_string()).with_failure())",
        "        ).await.unwrap();",
        "",
        "        engine_guard.register_agent(",
        "            Box::new(MockTestAgent::new(\"reliable2\".to_string()))",
        "        ).await.unwrap();",
        ""
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/integration_tests.rs",
      "line": 174,
      "code": ").await.unwrap();",
      "context": [
        "            Box::new(MockTestAgent::new(\"unreliable1\".to_string()).with_failure())",
        "        ).await.unwrap();",
        "",
        "        engine_guard.register_agent(",
        "            Box::new(MockTestAgent::new(\"reliable2\".to_string()))",
        "        ).await.unwrap();",
        "",
        "        engine_guard.register_agent(",
        "            Box::new(MockTestAgent::new(\"slow\".to_string()).with_delay(5000))",
        "        ).await.unwrap();",
        ""
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/integration_tests.rs",
      "line": 178,
      "code": ").await.unwrap();",
      "context": [
        "            Box::new(MockTestAgent::new(\"reliable2\".to_string()))",
        "        ).await.unwrap();",
        "",
        "        engine_guard.register_agent(",
        "            Box::new(MockTestAgent::new(\"slow\".to_string()).with_delay(5000))",
        "        ).await.unwrap();",
        "",
        "        drop(engine_guard);",
        "",
        "        let query = QueryBuilder::new(\"error recovery test\")",
        "            .with_timeout(1) // 1 second timeout"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/integration_tests.rs",
      "line": 187,
      "code": "let results = engine_guard.search(&query).await.unwrap();",
      "context": [
        "        let query = QueryBuilder::new(\"error recovery test\")",
        "            .with_timeout(1) // 1 second timeout",
        "            .build();",
        "",
        "        let engine_guard = engine.read().await;",
        "        let results = engine_guard.search(&query).await.unwrap();",
        "",
        "        // Should get results from reliable agents only",
        "        assert_eq!(results.len(), 2);",
        "        assert!(results.iter().all(|r| r.source.contains(\"reliable\")));",
        "    }"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/integration_tests.rs",
      "line": 207,
      "code": "let service = SynthexService::new(initial_config).await.unwrap();",
      "context": [
        "            max_retries: 3,",
        "            batch_size: 10,",
        "            memory_limit_mb: 512,",
        "        };",
        "",
        "        let service = SynthexService::new(initial_config).await.unwrap();",
        "",
        "        // Update configuration",
        "        let new_config = SynthexConfig {",
        "            max_concurrent_agents: 10,",
        "            cache_size: 200,"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/integration_tests.rs",
      "line": 221,
      "code": "service.update_config(new_config).await.unwrap();",
      "context": [
        "            max_retries: 5,",
        "            batch_size: 20,",
        "            memory_limit_mb: 1024,",
        "        };",
        "",
        "        service.update_config(new_config).await.unwrap();",
        "",
        "        let current_config = service.get_config().await;",
        "        assert_eq!(current_config.max_concurrent_agents, 10);",
        "        assert_eq!(current_config.cache_size, 200);",
        "        assert!(current_config.enable_ml_optimization);"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/integration_tests.rs",
      "line": 231,
      "code": "let service = SynthexService::new(test_config()).await.unwrap();",
      "context": [
        "        assert!(current_config.enable_ml_optimization);",
        "    }",
        "",
        "    #[tokio::test]",
        "    async fn test_graceful_shutdown() {",
        "        let service = SynthexService::new(test_config()).await.unwrap();",
        "",
        "        // Register agents",
        "        for i in 0..5 {",
        "            service.register_agent(",
        "                Box::new(MockTestAgent::new(format!(\"shutdown_test_{}\", i)))"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/integration_tests.rs",
      "line": 237,
      "code": ").await.unwrap();",
      "context": [
        "",
        "        // Register agents",
        "        for i in 0..5 {",
        "            service.register_agent(",
        "                Box::new(MockTestAgent::new(format!(\"shutdown_test_{}\", i)))",
        "            ).await.unwrap();",
        "        }",
        "",
        "        // Start some background queries",
        "        let service_clone = service.clone();",
        "        let query_handle = tokio::spawn(async move {"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/integration_tests.rs",
      "line": 269,
      "code": "let node1 = SynthexService::new(test_config()).await.unwrap();",
      "context": [
        "    }",
        "",
        "    #[tokio::test]",
        "    async fn test_distributed_search() {",
        "        // Simulate distributed SYNTHEX deployment",
        "        let node1 = SynthexService::new(test_config()).await.unwrap();",
        "        let node2 = SynthexService::new(test_config()).await.unwrap();",
        "        let node3 = SynthexService::new(test_config()).await.unwrap();",
        "",
        "        // Each node has different agents",
        "        node1.register_agent("
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/integration_tests.rs",
      "line": 270,
      "code": "let node2 = SynthexService::new(test_config()).await.unwrap();",
      "context": [
        "",
        "    #[tokio::test]",
        "    async fn test_distributed_search() {",
        "        // Simulate distributed SYNTHEX deployment",
        "        let node1 = SynthexService::new(test_config()).await.unwrap();",
        "        let node2 = SynthexService::new(test_config()).await.unwrap();",
        "        let node3 = SynthexService::new(test_config()).await.unwrap();",
        "",
        "        // Each node has different agents",
        "        node1.register_agent(",
        "            Box::new(MockTestAgent::new(\"node1_agent1\".to_string()))"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/integration_tests.rs",
      "line": 271,
      "code": "let node3 = SynthexService::new(test_config()).await.unwrap();",
      "context": [
        "    #[tokio::test]",
        "    async fn test_distributed_search() {",
        "        // Simulate distributed SYNTHEX deployment",
        "        let node1 = SynthexService::new(test_config()).await.unwrap();",
        "        let node2 = SynthexService::new(test_config()).await.unwrap();",
        "        let node3 = SynthexService::new(test_config()).await.unwrap();",
        "",
        "        // Each node has different agents",
        "        node1.register_agent(",
        "            Box::new(MockTestAgent::new(\"node1_agent1\".to_string()))",
        "        ).await.unwrap();"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/integration_tests.rs",
      "line": 276,
      "code": ").await.unwrap();",
      "context": [
        "        let node3 = SynthexService::new(test_config()).await.unwrap();",
        "",
        "        // Each node has different agents",
        "        node1.register_agent(",
        "            Box::new(MockTestAgent::new(\"node1_agent1\".to_string()))",
        "        ).await.unwrap();",
        "",
        "        node2.register_agent(",
        "            Box::new(MockTestAgent::new(\"node2_agent1\".to_string()))",
        "        ).await.unwrap();",
        ""
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/integration_tests.rs",
      "line": 280,
      "code": ").await.unwrap();",
      "context": [
        "            Box::new(MockTestAgent::new(\"node1_agent1\".to_string()))",
        "        ).await.unwrap();",
        "",
        "        node2.register_agent(",
        "            Box::new(MockTestAgent::new(\"node2_agent1\".to_string()))",
        "        ).await.unwrap();",
        "",
        "        node3.register_agent(",
        "            Box::new(MockTestAgent::new(\"node3_agent1\".to_string()))",
        "        ).await.unwrap();",
        ""
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/integration_tests.rs",
      "line": 284,
      "code": ").await.unwrap();",
      "context": [
        "            Box::new(MockTestAgent::new(\"node2_agent1\".to_string()))",
        "        ).await.unwrap();",
        "",
        "        node3.register_agent(",
        "            Box::new(MockTestAgent::new(\"node3_agent1\".to_string()))",
        "        ).await.unwrap();",
        "",
        "        // Coordinator collects results from all nodes",
        "        let query = QueryBuilder::new(\"distributed search\").build();",
        "",
        "        let mut all_results = vec![];"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/integration_tests.rs",
      "line": 297,
      "code": "all_results.extend(r1.unwrap());",
      "context": [
        "            node1.search(&query),",
        "            node2.search(&query),",
        "            node3.search(&query)",
        "        );",
        "",
        "        all_results.extend(r1.unwrap());",
        "        all_results.extend(r2.unwrap());",
        "        all_results.extend(r3.unwrap());",
        "",
        "        assert_eq!(all_results.len(), 3);",
        ""
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/integration_tests.rs",
      "line": 298,
      "code": "all_results.extend(r2.unwrap());",
      "context": [
        "            node2.search(&query),",
        "            node3.search(&query)",
        "        );",
        "",
        "        all_results.extend(r1.unwrap());",
        "        all_results.extend(r2.unwrap());",
        "        all_results.extend(r3.unwrap());",
        "",
        "        assert_eq!(all_results.len(), 3);",
        "",
        "        // Verify results from all nodes"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/integration_tests.rs",
      "line": 299,
      "code": "all_results.extend(r3.unwrap());",
      "context": [
        "            node3.search(&query)",
        "        );",
        "",
        "        all_results.extend(r1.unwrap());",
        "        all_results.extend(r2.unwrap());",
        "        all_results.extend(r3.unwrap());",
        "",
        "        assert_eq!(all_results.len(), 3);",
        "",
        "        // Verify results from all nodes",
        "        let sources: std::collections::HashSet<_> = all_results.iter()"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/integration_tests.rs",
      "line": 305,
      "code": ".map(|r| r.source.split('_').next().unwrap())",
      "context": [
        "",
        "        assert_eq!(all_results.len(), 3);",
        "",
        "        // Verify results from all nodes",
        "        let sources: std::collections::HashSet<_> = all_results.iter()",
        "            .map(|r| r.source.split('_').next().unwrap())",
        "            .collect();",
        "",
        "        assert!(sources.contains(\"node1\"));",
        "        assert!(sources.contains(\"node2\"));",
        "        assert!(sources.contains(\"node3\"));"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/integration_tests.rs",
      "line": 315,
      "code": "let service = SynthexService::new(test_config()).await.unwrap();",
      "context": [
        "        assert!(sources.contains(\"node3\"));",
        "    }",
        "",
        "    #[tokio::test]",
        "    async fn test_circuit_breaker() {",
        "        let service = SynthexService::new(test_config()).await.unwrap();",
        "",
        "        // Register a consistently failing agent",
        "        service.register_agent(",
        "            Box::new(MockTestAgent::new(\"failing_agent\".to_string()).with_failure())",
        "        ).await.unwrap();"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/integration_tests.rs",
      "line": 320,
      "code": ").await.unwrap();",
      "context": [
        "        let service = SynthexService::new(test_config()).await.unwrap();",
        "",
        "        // Register a consistently failing agent",
        "        service.register_agent(",
        "            Box::new(MockTestAgent::new(\"failing_agent\".to_string()).with_failure())",
        "        ).await.unwrap();",
        "",
        "        // Make multiple requests",
        "        for i in 0..10 {",
        "            let query = QueryBuilder::new(&format!(\"circuit test {}\", i)).build();",
        "            let _ = service.search(&query).await;"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/bashgod_tests.rs",
      "line": 116,
      "code": "ml_optimizer.train(&training_data).await.unwrap();",
      "context": [
        "",
        "            training_data.push((features, performance));",
        "        }",
        "",
        "        // Train model",
        "        ml_optimizer.train(&training_data).await.unwrap();",
        "",
        "        // Test predictions",
        "        let test_features = vec![0.5, 5.0, 1.0];",
        "        let prediction = ml_optimizer.predict(&test_features).await.unwrap();",
        ""
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/bashgod_tests.rs",
      "line": 120,
      "code": "let prediction = ml_optimizer.predict(&test_features).await.unwrap();",
      "context": [
        "        // Train model",
        "        ml_optimizer.train(&training_data).await.unwrap();",
        "",
        "        // Test predictions",
        "        let test_features = vec![0.5, 5.0, 1.0];",
        "        let prediction = ml_optimizer.predict(&test_features).await.unwrap();",
        "",
        "        assert!(prediction > 0.7); // Should predict good performance",
        "    }",
        "",
        "    #[tokio::test]"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/query_tests.rs",
      "line": 44,
      "code": "let tokens = parser.parse(\"hello world\").unwrap();",
      "context": [
        "    }",
        "",
        "    #[test]",
        "    fn test_query_parser_simple() {",
        "        let parser = QueryParser::new();",
        "        let tokens = parser.parse(\"hello world\").unwrap();",
        "",
        "        assert_eq!(tokens.len(), 2);",
        "        assert!(matches!(tokens[0], QueryToken::Term(ref s) if s == \"hello\"));",
        "        assert!(matches!(tokens[1], QueryToken::Term(ref s) if s == \"world\"));",
        "    }"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/query_tests.rs",
      "line": 55,
      "code": "let tokens = parser.parse(\"rust AND performance\").unwrap();",
      "context": [
        "",
        "    #[test]",
        "    fn test_query_parser_operators() {",
        "        let parser = QueryParser::new();",
        "",
        "        let tokens = parser.parse(\"rust AND performance\").unwrap();",
        "        assert_eq!(tokens.len(), 3);",
        "        assert!(matches!(tokens[1], QueryToken::Operator(QueryOperator::And)));",
        "",
        "        let tokens = parser.parse(\"error OR warning\").unwrap();",
        "        assert_eq!(tokens.len(), 3);"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/query_tests.rs",
      "line": 59,
      "code": "let tokens = parser.parse(\"error OR warning\").unwrap();",
      "context": [
        "",
        "        let tokens = parser.parse(\"rust AND performance\").unwrap();",
        "        assert_eq!(tokens.len(), 3);",
        "        assert!(matches!(tokens[1], QueryToken::Operator(QueryOperator::And)));",
        "",
        "        let tokens = parser.parse(\"error OR warning\").unwrap();",
        "        assert_eq!(tokens.len(), 3);",
        "        assert!(matches!(tokens[1], QueryToken::Operator(QueryOperator::Or)));",
        "",
        "        let tokens = parser.parse(\"security NOT vulnerability\").unwrap();",
        "        assert_eq!(tokens.len(), 3);"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/query_tests.rs",
      "line": 63,
      "code": "let tokens = parser.parse(\"security NOT vulnerability\").unwrap();",
      "context": [
        "",
        "        let tokens = parser.parse(\"error OR warning\").unwrap();",
        "        assert_eq!(tokens.len(), 3);",
        "        assert!(matches!(tokens[1], QueryToken::Operator(QueryOperator::Or)));",
        "",
        "        let tokens = parser.parse(\"security NOT vulnerability\").unwrap();",
        "        assert_eq!(tokens.len(), 3);",
        "        assert!(matches!(tokens[1], QueryToken::Operator(QueryOperator::Not)));",
        "    }",
        "",
        "    #[test]"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/query_tests.rs",
      "line": 71,
      "code": "let tokens = parser.parse(r#\"\"exact phrase\" search\"#).unwrap();",
      "context": [
        "    }",
        "",
        "    #[test]",
        "    fn test_query_parser_quoted_strings() {",
        "        let parser = QueryParser::new();",
        "        let tokens = parser.parse(r#\"\"exact phrase\" search\"#).unwrap();",
        "",
        "        assert_eq!(tokens.len(), 2);",
        "        assert!(matches!(tokens[0], QueryToken::Phrase(ref s) if s == \"exact phrase\"));",
        "        assert!(matches!(tokens[1], QueryToken::Term(ref s) if s == \"search\"));",
        "    }"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/query_tests.rs",
      "line": 81,
      "code": "let tokens = parser.parse(\"author:john title:\\\"rust programming\\\"\").unwrap();",
      "context": [
        "    }",
        "",
        "    #[test]",
        "    fn test_query_parser_field_search() {",
        "        let parser = QueryParser::new();",
        "        let tokens = parser.parse(\"author:john title:\\\"rust programming\\\"\").unwrap();",
        "",
        "        assert_eq!(tokens.len(), 2);",
        "        match &tokens[0] {",
        "            QueryToken::Field(field, value) => {",
        "                assert_eq!(field, \"author\");"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/query_tests.rs",
      "line": 104,
      "code": "let tokens = parser.parse(\"test* synth?x\").unwrap();",
      "context": [
        "    }",
        "",
        "    #[test]",
        "    fn test_query_parser_wildcards() {",
        "        let parser = QueryParser::new();",
        "        let tokens = parser.parse(\"test* synth?x\").unwrap();",
        "",
        "        assert_eq!(tokens.len(), 2);",
        "        assert!(matches!(tokens[0], QueryToken::Wildcard(ref s) if s == \"test*\"));",
        "        assert!(matches!(tokens[1], QueryToken::Wildcard(ref s) if s == \"synth?x\"));",
        "    }"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/query_tests.rs",
      "line": 114,
      "code": "let tokens = parser.parse(\"(rust OR go) AND performance\").unwrap();",
      "context": [
        "    }",
        "",
        "    #[test]",
        "    fn test_query_parser_parentheses() {",
        "        let parser = QueryParser::new();",
        "        let tokens = parser.parse(\"(rust OR go) AND performance\").unwrap();",
        "",
        "        assert!(tokens.iter().any(|t| matches!(t, QueryToken::LeftParen)));",
        "        assert!(tokens.iter().any(|t| matches!(t, QueryToken::RightParen)));",
        "    }",
        ""
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/query_tests.rs",
      "line": 124,
      "code": "let tokens = parser.parse(query).unwrap();",
      "context": [
        "",
        "    #[test]",
        "    fn test_query_parser_complex_expression() {",
        "        let parser = QueryParser::new();",
        "        let query = r#\"(type:documentation OR type:tutorial) AND \"rust programming\" NOT deprecated author:synthex*\"#;",
        "        let tokens = parser.parse(query).unwrap();",
        "",
        "        // Verify it parses without error and contains expected elements",
        "        assert!(tokens.len() > 5);",
        "        assert!(tokens.iter().any(|t| matches!(t, QueryToken::Phrase(ref s) if s == \"rust programming\")));",
        "        assert!(tokens.iter().any(|t| matches!(t, QueryToken::Operator(QueryOperator::Not))));"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/knowledge_graph_tests.rs",
      "line": 29,
      "code": "graph.add_node(node1.clone()).await.unwrap();",
      "context": [
        "            content: \"Systems programming\".to_string(),",
        "            node_type: \"concept\".to_string(),",
        "            metadata: HashMap::new(),",
        "        };",
        "",
        "        graph.add_node(node1.clone()).await.unwrap();",
        "        graph.add_node(node2.clone()).await.unwrap();",
        "",
        "        assert_eq!(graph.node_count(), 2);",
        "    }",
        ""
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/knowledge_graph_tests.rs",
      "line": 30,
      "code": "graph.add_node(node2.clone()).await.unwrap();",
      "context": [
        "            node_type: \"concept\".to_string(),",
        "            metadata: HashMap::new(),",
        "        };",
        "",
        "        graph.add_node(node1.clone()).await.unwrap();",
        "        graph.add_node(node2.clone()).await.unwrap();",
        "",
        "        assert_eq!(graph.node_count(), 2);",
        "    }",
        "",
        "    #[tokio::test]"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/knowledge_graph_tests.rs",
      "line": 45,
      "code": "}).await.unwrap();",
      "context": [
        "        graph.add_node(Node {",
        "            id: \"rust\".to_string(),",
        "            content: \"Rust language\".to_string(),",
        "            node_type: \"language\".to_string(),",
        "            metadata: HashMap::new(),",
        "        }).await.unwrap();",
        "",
        "        graph.add_node(Node {",
        "            id: \"memory_safety\".to_string(),",
        "            content: \"Memory safety concept\".to_string(),",
        "            node_type: \"concept\".to_string(),"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/knowledge_graph_tests.rs",
      "line": 52,
      "code": "}).await.unwrap();",
      "context": [
        "        graph.add_node(Node {",
        "            id: \"memory_safety\".to_string(),",
        "            content: \"Memory safety concept\".to_string(),",
        "            node_type: \"concept\".to_string(),",
        "            metadata: HashMap::new(),",
        "        }).await.unwrap();",
        "",
        "        // Create edge",
        "        let edge = Edge {",
        "            from: \"rust\".to_string(),",
        "            to: \"memory_safety\".to_string(),"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/knowledge_graph_tests.rs",
      "line": 63,
      "code": "graph.add_edge(edge).await.unwrap();",
      "context": [
        "            edge_type: \"provides\".to_string(),",
        "            weight: 0.9,",
        "            metadata: HashMap::new(),",
        "        };",
        "",
        "        graph.add_edge(edge).await.unwrap();",
        "",
        "        let edges = graph.get_edges_from(\"rust\").await;",
        "        assert_eq!(edges.len(), 1);",
        "        assert_eq!(edges[0].to, \"memory_safety\");",
        "    }"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/knowledge_graph_tests.rs",
      "line": 90,
      "code": "}).await.unwrap();",
      "context": [
        "            graph.add_node(Node {",
        "                id: id.to_string(),",
        "                content: content.to_string(),",
        "                node_type: node_type.to_string(),",
        "                metadata: HashMap::new(),",
        "            }).await.unwrap();",
        "        }",
        "",
        "        // Create relationships",
        "        let edges = vec![",
        "            (\"rust\", \"performance\", \"has\", 0.9),"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/knowledge_graph_tests.rs",
      "line": 109,
      "code": "}).await.unwrap();",
      "context": [
        "                from: from.to_string(),",
        "                to: to.to_string(),",
        "                edge_type: edge_type.to_string(),",
        "                weight,",
        "                metadata: HashMap::new(),",
        "            }).await.unwrap();",
        "        }",
        "",
        "        // Test BFS traversal",
        "        let traversal = GraphTraversal::bfs(&graph, \"rust\", 2).await;",
        "        assert!(traversal.visited.contains(\"performance\"));"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/knowledge_graph_tests.rs",
      "line": 138,
      "code": "let path = path.unwrap();",
      "context": [
        "        assert!(rust_connections.len() >= 2);",
        "",
        "        // Find path between nodes",
        "        let path = graph.find_shortest_path(\"rust\", \"ease\").await;",
        "        assert!(path.is_some());",
        "        let path = path.unwrap();",
        "        assert!(path.len() <= 4); // Should find indirect connection",
        "    }",
        "",
        "    #[tokio::test]",
        "    async fn test_semantic_search() {"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/knowledge_graph_tests.rs",
      "line": 147,
      "code": "graph.compute_embeddings().await.unwrap();",
      "context": [
        "    #[tokio::test]",
        "    async fn test_semantic_search() {",
        "        let mut graph = create_test_graph().await;",
        "",
        "        // Add embeddings to nodes (simplified)",
        "        graph.compute_embeddings().await.unwrap();",
        "",
        "        // Semantic search",
        "        let results = graph.semantic_search(\"memory safe systems programming\", 5).await;",
        "",
        "        assert!(!results.is_empty());"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/knowledge_graph_tests.rs",
      "line": 208,
      "code": "graph.add_node(node).await.unwrap();",
      "context": [
        "            content: \"Initial content\".to_string(),",
        "            node_type: \"test\".to_string(),",
        "            metadata: HashMap::new(),",
        "        };",
        "",
        "        graph.add_node(node).await.unwrap();",
        "",
        "        // Update node",
        "        let updated_node = Node {",
        "            id: \"test\".to_string(),",
        "            content: \"Updated content\".to_string(),"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/knowledge_graph_tests.rs",
      "line": 218,
      "code": "graph.update_node(updated_node).await.unwrap();",
      "context": [
        "            content: \"Updated content\".to_string(),",
        "            node_type: \"test\".to_string(),",
        "            metadata: HashMap::new(),",
        "        };",
        "",
        "        graph.update_node(updated_node).await.unwrap();",
        "",
        "        let retrieved = graph.get_node(\"test\").await.unwrap();",
        "        assert_eq!(retrieved.content, \"Updated content\");",
        "    }",
        ""
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/knowledge_graph_tests.rs",
      "line": 220,
      "code": "let retrieved = graph.get_node(\"test\").await.unwrap();",
      "context": [
        "            metadata: HashMap::new(),",
        "        };",
        "",
        "        graph.update_node(updated_node).await.unwrap();",
        "",
        "        let retrieved = graph.get_node(\"test\").await.unwrap();",
        "        assert_eq!(retrieved.content, \"Updated content\");",
        "    }",
        "",
        "    #[tokio::test]",
        "    async fn test_graph_persistence() {"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/knowledge_graph_tests.rs",
      "line": 229,
      "code": "let temp_file = tempfile::NamedTempFile::new().unwrap();",
      "context": [
        "    #[tokio::test]",
        "    async fn test_graph_persistence() {",
        "        let mut graph = create_test_graph().await;",
        "",
        "        // Save to file",
        "        let temp_file = tempfile::NamedTempFile::new().unwrap();",
        "        graph.save_to_file(temp_file.path()).await.unwrap();",
        "",
        "        // Load from file",
        "        let loaded_graph = KnowledgeGraph::load_from_file(temp_file.path()).await.unwrap();",
        ""
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/knowledge_graph_tests.rs",
      "line": 230,
      "code": "graph.save_to_file(temp_file.path()).await.unwrap();",
      "context": [
        "    async fn test_graph_persistence() {",
        "        let mut graph = create_test_graph().await;",
        "",
        "        // Save to file",
        "        let temp_file = tempfile::NamedTempFile::new().unwrap();",
        "        graph.save_to_file(temp_file.path()).await.unwrap();",
        "",
        "        // Load from file",
        "        let loaded_graph = KnowledgeGraph::load_from_file(temp_file.path()).await.unwrap();",
        "",
        "        assert_eq!(loaded_graph.node_count(), graph.node_count());"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/knowledge_graph_tests.rs",
      "line": 233,
      "code": "let loaded_graph = KnowledgeGraph::load_from_file(temp_file.path()).await.unwrap();",
      "context": [
        "        // Save to file",
        "        let temp_file = tempfile::NamedTempFile::new().unwrap();",
        "        graph.save_to_file(temp_file.path()).await.unwrap();",
        "",
        "        // Load from file",
        "        let loaded_graph = KnowledgeGraph::load_from_file(temp_file.path()).await.unwrap();",
        "",
        "        assert_eq!(loaded_graph.node_count(), graph.node_count());",
        "        assert_eq!(loaded_graph.edge_count(), graph.edge_count());",
        "    }",
        ""
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/knowledge_graph_tests.rs",
      "line": 250,
      "code": "}).await.unwrap();",
      "context": [
        "        graph1.add_node(Node {",
        "            id: \"node1\".to_string(),",
        "            content: \"Graph 1 node\".to_string(),",
        "            node_type: \"test\".to_string(),",
        "            metadata: HashMap::new(),",
        "        }).await.unwrap();",
        "",
        "        graph2.add_node(Node {",
        "            id: \"node2\".to_string(),",
        "            content: \"Graph 2 node\".to_string(),",
        "            node_type: \"test\".to_string(),"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/knowledge_graph_tests.rs",
      "line": 257,
      "code": "}).await.unwrap();",
      "context": [
        "        graph2.add_node(Node {",
        "            id: \"node2\".to_string(),",
        "            content: \"Graph 2 node\".to_string(),",
        "            node_type: \"test\".to_string(),",
        "            metadata: HashMap::new(),",
        "        }).await.unwrap();",
        "",
        "        // Merge graphs",
        "        graph1.merge(graph2).await.unwrap();",
        "",
        "        assert_eq!(graph1.node_count(), 2);"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/knowledge_graph_tests.rs",
      "line": 260,
      "code": "graph1.merge(graph2).await.unwrap();",
      "context": [
        "            node_type: \"test\".to_string(),",
        "            metadata: HashMap::new(),",
        "        }).await.unwrap();",
        "",
        "        // Merge graphs",
        "        graph1.merge(graph2).await.unwrap();",
        "",
        "        assert_eq!(graph1.node_count(), 2);",
        "        assert!(graph1.get_node(\"node1\").await.is_ok());",
        "        assert!(graph1.get_node(\"node2\").await.is_ok());",
        "    }"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/knowledge_graph_tests.rs",
      "line": 289,
      "code": "assert!(inference.unwrap() > 0.5);",
      "context": [
        "        }).await;",
        "",
        "        // Test inference",
        "        let inference = graph.infer_relationship(\"cpp\", \"performance\").await;",
        "        assert!(inference.is_some());",
        "        assert!(inference.unwrap() > 0.5);",
        "    }",
        "}",
        "",
        "// Helper function to create a test graph",
        "async fn create_test_graph() -> KnowledgeGraph {"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/knowledge_graph_tests.rs",
      "line": 319,
      "code": "}).await.unwrap();",
      "context": [
        "        graph.add_node(Node {",
        "            id: id.to_string(),",
        "            content: content.to_string(),",
        "            node_type: node_type.to_string(),",
        "            metadata: HashMap::new(),",
        "        }).await.unwrap();",
        "    }",
        "",
        "    // Create relationships",
        "    let relationships = vec![",
        "        (\"rust\", \"performance\", \"has\", 0.9),"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/knowledge_graph_tests.rs",
      "line": 340,
      "code": "}).await.unwrap();",
      "context": [
        "            from: from.to_string(),",
        "            to: to.to_string(),",
        "            edge_type: edge_type.to_string(),",
        "            weight,",
        "            metadata: HashMap::new(),",
        "        }).await.unwrap();",
        "    }",
        "",
        "    graph",
        "}"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/test_utils.rs",
      "line": 29,
      "code": "let engine = SynthexEngine::new(config).await.unwrap();",
      "context": [
        "}",
        "",
        "/// Create a test engine with mock agents",
        "pub async fn test_engine() -> Arc<RwLock<SynthexEngine>> {",
        "    let config = test_config();",
        "    let engine = SynthexEngine::new(config).await.unwrap();",
        "    Arc::new(RwLock::new(engine))",
        "}",
        "",
        "/// Generate test queries",
        "pub fn test_queries() -> Vec<Query> {"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/performance_tests.rs",
      "line": 21,
      "code": "engine_guard.register_agent(agent).await.unwrap();",
      "context": [
        "    async fn test_single_agent_throughput() {",
        "        let engine = test_engine().await;",
        "        let mut engine_guard = engine.write().await;",
        "",
        "        let agent = Box::new(MockTestAgent::new(\"perf_single\".to_string()));",
        "        engine_guard.register_agent(agent).await.unwrap();",
        "        drop(engine_guard);",
        "",
        "        let queries: Vec<_> = (0..100)",
        "            .map(|i| QueryBuilder::new(&format!(\"query {}\", i)).build())",
        "            .collect();"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/performance_tests.rs",
      "line": 32,
      "code": "let _ = engine_guard.search(query).await.unwrap();",
      "context": [
        "",
        "        let start = std::time::Instant::now();",
        "",
        "        for query in &queries {",
        "            let engine_guard = engine.read().await;",
        "            let _ = engine_guard.search(query).await.unwrap();",
        "        }",
        "",
        "        let elapsed = start.elapsed();",
        "        let qps = 100.0 / elapsed.as_secs_f64();",
        ""
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/performance_tests.rs",
      "line": 56,
      "code": "engine_guard.register_agent(agent).await.unwrap();",
      "context": [
        "            for i in 0..num_agents {",
        "                let agent = Box::new(",
        "                    MockTestAgent::new(format!(\"scale_{}\", i))",
        "                        .with_delay(10) // Simulate work",
        "                );",
        "                engine_guard.register_agent(agent).await.unwrap();",
        "            }",
        "",
        "            drop(engine_guard);",
        "",
        "            // Run queries"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/performance_tests.rs",
      "line": 70,
      "code": "let _ = engine_guard.search(&query).await.unwrap();",
      "context": [
        "",
        "            let start = std::time::Instant::now();",
        "            let engine_guard = engine.read().await;",
        "",
        "            for _ in 0..50 {",
        "                let _ = engine_guard.search(&query).await.unwrap();",
        "            }",
        "",
        "            let elapsed = start.elapsed().as_millis();",
        "            let throughput = 50000.0 / elapsed as f64; // queries per second",
        ""
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/performance_tests.rs",
      "line": 94,
      "code": "let engine = SynthexEngine::new(config).await.unwrap();",
      "context": [
        "    #[tokio::test]",
        "    async fn test_cache_performance() {",
        "        let mut config = test_config();",
        "        config.cache_size = 1000;",
        "",
        "        let engine = SynthexEngine::new(config).await.unwrap();",
        "        let engine = Arc::new(RwLock::new(engine));",
        "        let mut engine_guard = engine.write().await;",
        "",
        "        let agent = Box::new(",
        "            MockTestAgent::new(\"cache_perf\".to_string())"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/performance_tests.rs",
      "line": 102,
      "code": "engine_guard.register_agent(agent).await.unwrap();",
      "context": [
        "",
        "        let agent = Box::new(",
        "            MockTestAgent::new(\"cache_perf\".to_string())",
        "                .with_delay(50) // Simulate expensive operation",
        "        );",
        "        engine_guard.register_agent(agent).await.unwrap();",
        "",
        "        drop(engine_guard);",
        "",
        "        // Generate queries with some repetition",
        "        let unique_queries = 20;"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/performance_tests.rs",
      "line": 121,
      "code": "let _ = engine_guard.search(query).await.unwrap();",
      "context": [
        "",
        "        let start = std::time::Instant::now();",
        "",
        "        for query in &queries {",
        "            let engine_guard = engine.read().await;",
        "            let _ = engine_guard.search(query).await.unwrap();",
        "        }",
        "",
        "        let elapsed = start.elapsed().as_millis();",
        "",
        "        // With cache, should be much faster than without"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/performance_tests.rs",
      "line": 139,
      "code": "let engine = SynthexEngine::new(config).await.unwrap();",
      "context": [
        "    #[tokio::test]",
        "    async fn test_memory_efficiency() {",
        "        let mut config = test_config();",
        "        config.memory_limit_mb = 100;",
        "",
        "        let engine = SynthexEngine::new(config).await.unwrap();",
        "        let engine = Arc::new(RwLock::new(engine));",
        "",
        "        // Measure baseline memory",
        "        let baseline_memory = get_current_memory_usage();",
        ""
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/performance_tests.rs",
      "line": 150,
      "code": "engine_guard.register_agent(agent).await.unwrap();",
      "context": [
        "        let mut engine_guard = engine.write().await;",
        "",
        "        // Register many agents",
        "        for i in 0..50 {",
        "            let agent = Box::new(MockTestAgent::new(format!(\"mem_{}\", i)));",
        "            engine_guard.register_agent(agent).await.unwrap();",
        "        }",
        "",
        "        drop(engine_guard);",
        "",
        "        // Generate large dataset"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/performance_tests.rs",
      "line": 195,
      "code": "engine_guard.register_agent(agent).await.unwrap();",
      "context": [
        "            let delay = if i < 8 { 5 } else { 100 }; // 80% fast, 20% slow",
        "            let agent = Box::new(",
        "                MockTestAgent::new(format!(\"latency_{}\", i))",
        "                    .with_delay(delay)",
        "            );",
        "            engine_guard.register_agent(agent).await.unwrap();",
        "        }",
        "",
        "        drop(engine_guard);",
        "",
        "        let mut latencies = vec![];"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/performance_tests.rs",
      "line": 209,
      "code": "let _ = engine_guard.search(&query).await.unwrap();",
      "context": [
        "                .with_parallel_execution(true)",
        "                .build();",
        "",
        "            let start = std::time::Instant::now();",
        "            let engine_guard = engine.read().await;",
        "            let _ = engine_guard.search(&query).await.unwrap();",
        "            let latency = start.elapsed().as_millis();",
        "",
        "            latencies.push(latency);",
        "        }",
        ""
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/performance_tests.rs",
      "line": 236,
      "code": "engine_guard.register_agent(agent).await.unwrap();",
      "context": [
        "        let mut engine_guard = engine.write().await;",
        "",
        "        // Register agents",
        "        for i in 0..5 {",
        "            let agent = Box::new(MockTestAgent::new(format!(\"concurrent_{}\", i)));",
        "            engine_guard.register_agent(agent).await.unwrap();",
        "        }",
        "",
        "        drop(engine_guard);",
        "",
        "        // Simulate concurrent users"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/performance_tests.rs",
      "line": 266,
      "code": "handle.await.unwrap();",
      "context": [
        "            handles.push(handle);",
        "        }",
        "",
        "        // Wait for all to complete",
        "        for handle in handles {",
        "            handle.await.unwrap();",
        "        }",
        "",
        "        let elapsed = start.elapsed();",
        "        let total_queries = num_concurrent * queries_per_user;",
        "        let qps = total_queries as f64 / elapsed.as_secs_f64();"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/performance_tests.rs",
      "line": 309,
      "code": "let engine = SynthexEngine::new(config).await.unwrap();",
      "context": [
        "    #[tokio::test]",
        "    async fn test_resource_usage_under_stress() {",
        "        let mut config = test_config();",
        "        config.max_concurrent_agents = 20;",
        "",
        "        let engine = SynthexEngine::new(config).await.unwrap();",
        "        let engine = Arc::new(RwLock::new(engine));",
        "        let mut engine_guard = engine.write().await;",
        "",
        "        // Register resource-intensive agents",
        "        for i in 0..20 {"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/performance_tests.rs",
      "line": 319,
      "code": "engine_guard.register_agent(agent).await.unwrap();",
      "context": [
        "        for i in 0..20 {",
        "            let agent = Box::new(",
        "                MockTestAgent::new(format!(\"stress_{}\", i))",
        "                    .with_delay(50)",
        "            );",
        "            engine_guard.register_agent(agent).await.unwrap();",
        "        }",
        "",
        "        drop(engine_guard);",
        "",
        "        // Monitor resource usage during stress test"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/performance_tests.rs",
      "line": 362,
      "code": "handle.await.unwrap();",
      "context": [
        "                });",
        "                handles.push(handle);",
        "            }",
        "",
        "            for handle in handles {",
        "                handle.await.unwrap();",
        "            }",
        "        });",
        "",
        "        // Wait for both to complete",
        "        stress_handle.await.unwrap();"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/performance_tests.rs",
      "line": 367,
      "code": "stress_handle.await.unwrap();",
      "context": [
        "                handle.await.unwrap();",
        "            }",
        "        });",
        "",
        "        // Wait for both to complete",
        "        stress_handle.await.unwrap();",
        "        let (max_cpu, max_memory) = monitor_handle.await.unwrap();",
        "",
        "        println!(\"Peak resource usage - CPU: {:.1}%, Memory: {}MB\", max_cpu, max_memory);",
        "",
        "        assert!(max_cpu < 90.0, \"CPU usage too high: {:.1}%\", max_cpu);"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/performance_tests.rs",
      "line": 368,
      "code": "let (max_cpu, max_memory) = monitor_handle.await.unwrap();",
      "context": [
        "            }",
        "        });",
        "",
        "        // Wait for both to complete",
        "        stress_handle.await.unwrap();",
        "        let (max_cpu, max_memory) = monitor_handle.await.unwrap();",
        "",
        "        println!(\"Peak resource usage - CPU: {:.1}%, Memory: {}MB\", max_cpu, max_memory);",
        "",
        "        assert!(max_cpu < 90.0, \"CPU usage too high: {:.1}%\", max_cpu);",
        "        assert!(max_memory < 500, \"Memory usage too high: {}MB\", max_memory);"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/mcp_v2_tests.rs",
      "line": 15,
      "code": "let manager = McpV2Manager::new(config).await.unwrap();",
      "context": [
        "    use std::collections::HashMap;",
        "",
        "    #[tokio::test]",
        "    async fn test_mcp_manager_initialization() {",
        "        let config = SynthexConfig::default();",
        "        let manager = McpV2Manager::new(config).await.unwrap();",
        "",
        "        assert!(manager.is_ready());",
        "        assert_eq!(manager.server_count(), 0); // No servers registered yet",
        "    }",
        ""
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/mcp_v2_tests.rs",
      "line": 23,
      "code": "let manager = McpV2Manager::new(SynthexConfig::default()).await.unwrap();",
      "context": [
        "        assert_eq!(manager.server_count(), 0); // No servers registered yet",
        "    }",
        "",
        "    #[tokio::test]",
        "    async fn test_mcp_server_registration() {",
        "        let manager = McpV2Manager::new(SynthexConfig::default()).await.unwrap();",
        "",
        "        let server = McpServer {",
        "            id: \"test_server\".to_string(),",
        "            name: \"Test MCP Server\".to_string(),",
        "            version: \"1.0.0\".to_string(),"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/mcp_v2_tests.rs",
      "line": 34,
      "code": "manager.register_server(server).await.unwrap();",
      "context": [
        "            capabilities: vec![\"search\".to_string(), \"analyze\".to_string()],",
        "            endpoint: \"http://localhost:8080\".to_string(),",
        "            metadata: HashMap::new(),",
        "        };",
        "",
        "        manager.register_server(server).await.unwrap();",
        "        assert_eq!(manager.server_count(), 1);",
        "",
        "        // Duplicate registration should fail",
        "        let duplicate = McpServer {",
        "            id: \"test_server\".to_string(),"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/mcp_v2_tests.rs",
      "line": 53,
      "code": "let manager = McpV2Manager::new(SynthexConfig::default()).await.unwrap();",
      "context": [
        "        assert!(result.is_err());",
        "    }",
        "",
        "    #[tokio::test]",
        "    async fn test_mcp_tool_discovery() {",
        "        let manager = McpV2Manager::new(SynthexConfig::default()).await.unwrap();",
        "",
        "        // Register server with tools",
        "        let mut server = McpServer {",
        "            id: \"tool_server\".to_string(),",
        "            name: \"Tool Server\".to_string(),"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/mcp_v2_tests.rs",
      "line": 65,
      "code": "manager.register_server(server.clone()).await.unwrap();",
      "context": [
        "            capabilities: vec![\"tools\".to_string()],",
        "            endpoint: \"http://localhost:8080\".to_string(),",
        "            metadata: HashMap::new(),",
        "        };",
        "",
        "        manager.register_server(server.clone()).await.unwrap();",
        "",
        "        // Add tools to server",
        "        let tools = vec![",
        "            McpTool {",
        "                name: \"search\".to_string(),"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/mcp_v2_tests.rs",
      "line": 94,
      "code": "manager.register_tool(tool).await.unwrap();",
      "context": [
        "                server_id: \"tool_server\".to_string(),",
        "            },",
        "        ];",
        "",
        "        for tool in tools {",
        "            manager.register_tool(tool).await.unwrap();",
        "        }",
        "",
        "        // Discover tools",
        "        let discovered_tools = manager.discover_tools(\"search\").await;",
        "        assert_eq!(discovered_tools.len(), 1);"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/mcp_v2_tests.rs",
      "line": 108,
      "code": "let manager = McpV2Manager::new(SynthexConfig::default()).await.unwrap();",
      "context": [
        "        assert_eq!(all_tools.len(), 2);",
        "    }",
        "",
        "    #[tokio::test]",
        "    async fn test_mcp_resource_management() {",
        "        let manager = McpV2Manager::new(SynthexConfig::default()).await.unwrap();",
        "",
        "        // Register server",
        "        let server = McpServer {",
        "            id: \"resource_server\".to_string(),",
        "            name: \"Resource Server\".to_string(),"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/mcp_v2_tests.rs",
      "line": 120,
      "code": "manager.register_server(server).await.unwrap();",
      "context": [
        "            capabilities: vec![\"resources\".to_string()],",
        "            endpoint: \"http://localhost:8080\".to_string(),",
        "            metadata: HashMap::new(),",
        "        };",
        "",
        "        manager.register_server(server).await.unwrap();",
        "",
        "        // Add resources",
        "        let resources = vec![",
        "            McpResource {",
        "                uri: \"file:///docs/guide.md\".to_string(),"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/mcp_v2_tests.rs",
      "line": 141,
      "code": "manager.register_resource(resource).await.unwrap();",
      "context": [
        "                metadata: HashMap::new(),",
        "            },",
        "        ];",
        "",
        "        for resource in resources {",
        "            manager.register_resource(resource).await.unwrap();",
        "        }",
        "",
        "        // Query resources",
        "        let markdown_resources = manager.find_resources_by_type(\"text/markdown\").await;",
        "        assert_eq!(markdown_resources.len(), 1);"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/mcp_v2_tests.rs",
      "line": 148,
      "code": "let resource = manager.get_resource(\"file:///docs/guide.md\").await.unwrap();",
      "context": [
        "",
        "        // Query resources",
        "        let markdown_resources = manager.find_resources_by_type(\"text/markdown\").await;",
        "        assert_eq!(markdown_resources.len(), 1);",
        "",
        "        let resource = manager.get_resource(\"file:///docs/guide.md\").await.unwrap();",
        "        assert_eq!(resource.name, \"User Guide\");",
        "    }",
        "",
        "    #[tokio::test]",
        "    async fn test_mcp_tool_execution() {"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/mcp_v2_tests.rs",
      "line": 154,
      "code": "let manager = McpV2Manager::new(SynthexConfig::default()).await.unwrap();",
      "context": [
        "        assert_eq!(resource.name, \"User Guide\");",
        "    }",
        "",
        "    #[tokio::test]",
        "    async fn test_mcp_tool_execution() {",
        "        let manager = McpV2Manager::new(SynthexConfig::default()).await.unwrap();",
        "",
        "        // Setup mock server and tool",
        "        let server = McpServer {",
        "            id: \"exec_server\".to_string(),",
        "            name: \"Execution Server\".to_string(),"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/mcp_v2_tests.rs",
      "line": 166,
      "code": "manager.register_server(server).await.unwrap();",
      "context": [
        "            capabilities: vec![\"tools\".to_string()],",
        "            endpoint: \"http://localhost:8080\".to_string(),",
        "            metadata: HashMap::new(),",
        "        };",
        "",
        "        manager.register_server(server).await.unwrap();",
        "",
        "        let tool = McpTool {",
        "            name: \"calculate\".to_string(),",
        "            description: \"Perform calculation\".to_string(),",
        "            input_schema: serde_json::json!({"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/mcp_v2_tests.rs",
      "line": 181,
      "code": "manager.register_tool(tool).await.unwrap();",
      "context": [
        "                \"required\": [\"expression\"]",
        "            }),",
        "            server_id: \"exec_server\".to_string(),",
        "        };",
        "",
        "        manager.register_tool(tool).await.unwrap();",
        "",
        "        // Execute tool",
        "        let input = serde_json::json!({",
        "            \"expression\": \"2 + 2\"",
        "        });"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/mcp_v2_tests.rs",
      "line": 202,
      "code": "let manager = McpV2Manager::new(SynthexConfig::default()).await.unwrap();",
      "context": [
        "        assert!(result.is_err());",
        "    }",
        "",
        "    #[tokio::test]",
        "    async fn test_mcp_server_health_monitoring() {",
        "        let manager = McpV2Manager::new(SynthexConfig::default()).await.unwrap();",
        "",
        "        // Register multiple servers",
        "        for i in 0..3 {",
        "            let server = McpServer {",
        "                id: format!(\"health_server_{}\", i),"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/mcp_v2_tests.rs",
      "line": 215,
      "code": "manager.register_server(server).await.unwrap();",
      "context": [
        "                capabilities: vec![\"health\".to_string()],",
        "                endpoint: format!(\"http://localhost:808{}\", i),",
        "                metadata: HashMap::new(),",
        "            };",
        "",
        "            manager.register_server(server).await.unwrap();",
        "        }",
        "",
        "        // Check health status",
        "        let health_report = manager.check_all_servers_health().await;",
        ""
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/mcp_v2_tests.rs",
      "line": 232,
      "code": "let manager = McpV2Manager::new(SynthexConfig::default()).await.unwrap();",
      "context": [
        "        assert!(server_health.is_ok());",
        "    }",
        "",
        "    #[tokio::test]",
        "    async fn test_mcp_capability_matching() {",
        "        let manager = McpV2Manager::new(SynthexConfig::default()).await.unwrap();",
        "",
        "        // Register servers with different capabilities",
        "        let servers = vec![",
        "            (\"search_server\", vec![\"search\", \"index\"]),",
        "            (\"analyze_server\", vec![\"analyze\", \"nlp\"]),"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/mcp_v2_tests.rs",
      "line": 251,
      "code": "manager.register_server(server).await.unwrap();",
      "context": [
        "                capabilities: capabilities.iter().map(|s| s.to_string()).collect(),",
        "                endpoint: format!(\"http://{}.local\", id),",
        "                metadata: HashMap::new(),",
        "            };",
        "",
        "            manager.register_server(server).await.unwrap();",
        "        }",
        "",
        "        // Find servers by capability",
        "        let search_servers = manager.find_servers_by_capability(\"search\").await;",
        "        assert_eq!(search_servers.len(), 1);"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/mcp_v2_tests.rs",
      "line": 266,
      "code": "let manager = McpV2Manager::new(SynthexConfig::default()).await.unwrap();",
      "context": [
        "        assert_eq!(nlp_servers[0].id, \"analyze_server\");",
        "    }",
        "",
        "    #[tokio::test]",
        "    async fn test_mcp_query_routing() {",
        "        let manager = McpV2Manager::new(SynthexConfig::default()).await.unwrap();",
        "",
        "        // Setup specialized servers",
        "        setup_specialized_servers(&manager).await;",
        "",
        "        // Route different query types"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/mcp_v2_tests.rs",
      "line": 289,
      "code": "let manager = McpV2Manager::new(SynthexConfig::default()).await.unwrap();",
      "context": [
        "        assert!(routed_servers.iter().any(|s| s.capabilities.contains(&\"nlp\".to_string())));",
        "    }",
        "",
        "    #[tokio::test]",
        "    async fn test_mcp_load_balancing() {",
        "        let manager = McpV2Manager::new(SynthexConfig::default()).await.unwrap();",
        "",
        "        // Register multiple identical servers",
        "        for i in 0..3 {",
        "            let server = McpServer {",
        "                id: format!(\"lb_server_{}\", i),"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/mcp_v2_tests.rs",
      "line": 302,
      "code": "manager.register_server(server).await.unwrap();",
      "context": [
        "                capabilities: vec![\"search\".to_string()],",
        "                endpoint: format!(\"http://lb{}.local\", i),",
        "                metadata: HashMap::new(),",
        "            };",
        "",
        "            manager.register_server(server).await.unwrap();",
        "        }",
        "",
        "        // Make multiple requests and verify load distribution",
        "        let mut server_hits = HashMap::new();",
        ""
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/mcp_v2_tests.rs",
      "line": 309,
      "code": "let selected = manager.select_server_for_capability(\"search\").await.unwrap();",
      "context": [
        "",
        "        // Make multiple requests and verify load distribution",
        "        let mut server_hits = HashMap::new();",
        "",
        "        for _ in 0..30 {",
        "            let selected = manager.select_server_for_capability(\"search\").await.unwrap();",
        "            *server_hits.entry(selected.id.clone()).or_insert(0) += 1;",
        "        }",
        "",
        "        // Verify relatively even distribution",
        "        for (_, hits) in server_hits {"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/mcp_v2_tests.rs",
      "line": 321,
      "code": "let manager = McpV2Manager::new(SynthexConfig::default()).await.unwrap();",
      "context": [
        "        }",
        "    }",
        "",
        "    #[tokio::test]",
        "    async fn test_mcp_error_handling() {",
        "        let manager = McpV2Manager::new(SynthexConfig::default()).await.unwrap();",
        "",
        "        // Test various error scenarios",
        "",
        "        // 1. Execute tool on non-existent server",
        "        let result = manager.execute_tool(\"non_existent_tool\", serde_json::json!({})).await;"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/mcp_v2_tests.rs",
      "line": 349,
      "code": "let manager = McpV2Manager::new(SynthexConfig::default()).await.unwrap();",
      "context": [
        "        assert!(result.is_err());",
        "    }",
        "",
        "    #[tokio::test]",
        "    async fn test_mcp_performance_metrics() {",
        "        let manager = McpV2Manager::new(SynthexConfig::default()).await.unwrap();",
        "",
        "        // Setup server and execute operations",
        "        let server = McpServer {",
        "            id: \"perf_server\".to_string(),",
        "            name: \"Performance Server\".to_string(),"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/mcp_v2_tests.rs",
      "line": 361,
      "code": "manager.register_server(server).await.unwrap();",
      "context": [
        "            capabilities: vec![\"metrics\".to_string()],",
        "            endpoint: \"http://localhost:8080\".to_string(),",
        "            metadata: HashMap::new(),",
        "        };",
        "",
        "        manager.register_server(server).await.unwrap();",
        "",
        "        // Simulate operations",
        "        for i in 0..10 {",
        "            manager.record_operation_metric(\"perf_server\", \"latency\", 50.0 + i as f64).await;",
        "            manager.record_operation_metric(\"perf_server\", \"throughput\", 1000.0 - i as f64 * 10.0).await;"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/mcp_v2_tests.rs",
      "line": 370,
      "code": "let metrics = manager.get_server_metrics(\"perf_server\").await.unwrap();",
      "context": [
        "            manager.record_operation_metric(\"perf_server\", \"latency\", 50.0 + i as f64).await;",
        "            manager.record_operation_metric(\"perf_server\", \"throughput\", 1000.0 - i as f64 * 10.0).await;",
        "        }",
        "",
        "        // Get metrics",
        "        let metrics = manager.get_server_metrics(\"perf_server\").await.unwrap();",
        "",
        "        assert_eq!(metrics.operation_count, 20);",
        "        assert!(metrics.average_latency > 50.0);",
        "        assert!(metrics.average_throughput < 1000.0);",
        "        assert!(metrics.error_rate == 0.0);"
      ],
      "suggestion": "Safe in test context - no action needed"
    },
    {
      "file": "src/synthex/tests/mcp_v2_tests.rs",
      "line": 398,
      "code": "manager.register_server(server).await.unwrap();",
      "context": [
        "            capabilities: capabilities.iter().map(|s| s.to_string()).collect(),",
        "            endpoint: format!(\"http://{}.local\", id),",
        "            metadata: HashMap::new(),",
        "        };",
        "",
        "        manager.register_server(server).await.unwrap();",
        "    }",
        "}"
      ],
      "suggestion": "Safe in test context - no action needed"
    }
  ],
  "fixable_unwraps": [
    {
      "file": "src/infrastructure.rs",
      "line": 128,
      "code": "let _permit = semaphore.acquire().await.unwrap();",
      "context": [
        "                    .map(|(host, port)| {",
        "                        let cache = cache.clone();",
        "                        let semaphore = semaphore.clone();",
        "",
        "                        tokio::spawn(async move {",
        "                            let _permit = semaphore.acquire().await.unwrap();",
        "                            let key = format!(\"{}:{}\", host, port);",
        "",
        "                            // Check cache first",
        "                            if let Some(cached) = cache.get(&key) {",
        "                                return *cached.value();"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/infrastructure.rs",
      "line": 555,
      "code": "let results = analyzer.analyze_logs(py, logs).unwrap();",
      "context": [
        "        let logs = \"2024-01-01 10:00:00 ERROR: Something failed\\n\\",
        "                   2024-01-01 10:01:00 WARNING: Deprecated function\\n\\",
        "                   2024-01-01 10:02:00 INFO: All good\";",
        "",
        "        Python::with_gil(|py| {",
        "            let results = analyzer.analyze_logs(py, logs).unwrap();",
        "            assert_eq!(results[\"errors\"], 1);",
        "            assert_eq!(results[\"warnings\"], 1);",
        "            assert_eq!(results[\"total_lines\"], 3);",
        "        });",
        "    }"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/security_enhanced.rs",
      "line": 331,
      "code": ".unwrap()",
      "context": [
        "        let mut limiter = self.rate_limiter.lock()",
        "            .map_err(|e| CoreError::Security(format!(\"Rate limiter lock failed: {}\", e)))?;",
        "",
        "        let now = SystemTime::now()",
        "            .duration_since(UNIX_EPOCH)",
        "            .unwrap()",
        "            .as_secs();",
        "",
        "        let user_requests = limiter.entry(user_id.to_string()).or_insert_with(Vec::new);",
        "",
        "        // Remove old entries (older than 1 minute)"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/security_enhanced.rs",
      "line": 483,
      "code": ".unwrap()",
      "context": [
        "    ) -> PyResult<String> {",
        "        let entry = AuditEntry {",
        "            id: Uuid::new_v4().to_string(),",
        "            timestamp: SystemTime::now()",
        "                .duration_since(UNIX_EPOCH)",
        "                .unwrap()",
        "                .as_secs(),",
        "            user_id: context.user_id.clone(),",
        "            session_id: context.session_id.clone(),",
        "            action: action.to_string(),",
        "            resource: resource.to_string(),"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/security_enhanced.rs",
      "line": 1153,
      "code": "\"timestamp\": SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs(),",
      "context": [
        "",
        "        // Generate audit report",
        "        let audit_report = self.audit_logger.generate_report()?;",
        "",
        "        let comprehensive_report = serde_json::json!({",
        "            \"timestamp\": SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs(),",
        "            \"security_tests\": audit_results,",
        "            \"audit_summary\": serde_json::from_str::<serde_json::Value>(&audit_report).unwrap(),",
        "        });",
        "",
        "        serde_json::to_string_pretty(&comprehensive_report)"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/security_enhanced.rs",
      "line": 1155,
      "code": "\"audit_summary\": serde_json::from_str::<serde_json::Value>(&audit_report).unwrap(),",
      "context": [
        "        let audit_report = self.audit_logger.generate_report()?;",
        "",
        "        let comprehensive_report = serde_json::json!({",
        "            \"timestamp\": SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs(),",
        "            \"security_tests\": audit_results,",
        "            \"audit_summary\": serde_json::from_str::<serde_json::Value>(&audit_report).unwrap(),",
        "        });",
        "",
        "        serde_json::to_string_pretty(&comprehensive_report)",
        "            .map_err(|e| CoreError::Serialization(e.to_string()).into())",
        "    }"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/security_enhanced.rs",
      "line": 1195,
      "code": "assert!(validator.validate_command(\"ls -la\", &context).unwrap());",
      "context": [
        "            sandbox_level: SandboxLevel::Basic,",
        "            encryption_enabled: true,",
        "        };",
        "",
        "        // Test safe command",
        "        assert!(validator.validate_command(\"ls -la\", &context).unwrap());",
        "",
        "        // Test dangerous command",
        "        assert!(!validator.validate_command(\"rm -rf /; echo hacked\", &context).unwrap());",
        "    }",
        ""
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/security_enhanced.rs",
      "line": 1221,
      "code": "let encrypted = manager.encrypt_data(plaintext, &key_id).unwrap();",
      "context": [
        "        // Generate key",
        "        let key_id = manager.generate_key(\"test-key\", \"aes256\").unwrap();",
        "",
        "        // Encrypt data",
        "        let plaintext = b\"Secret data\";",
        "        let encrypted = manager.encrypt_data(plaintext, &key_id).unwrap();",
        "",
        "        // Decrypt data",
        "        let decrypted = manager.decrypt_data(&encrypted, &key_id).unwrap();",
        "",
        "        assert_eq!(plaintext, &decrypted[..]);"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/security_enhanced.rs",
      "line": 1248,
      "code": ").unwrap();",
      "context": [
        "            &context,",
        "            \"test_action\",",
        "            \"test_resource\",",
        "            \"success\".to_string(),",
        "            None,",
        "        ).unwrap();",
        "",
        "        assert!(!entry_id.is_empty());",
        "",
        "        // Query logs",
        "        let logs = logger.query_logs("
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/security_enhanced.rs",
      "line": 1258,
      "code": ").unwrap();",
      "context": [
        "        let logs = logger.query_logs(",
        "            Some(\"test_user\".to_string()),",
        "            None,",
        "            None,",
        "            None,",
        "        ).unwrap();",
        "",
        "        assert_eq!(logs.len(), 1);",
        "    }",
        "}"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/memory_mapped.rs",
      "line": 431,
      "code": "let mmap_file = MemoryMappedFile::new(test_file.to_string(), None).unwrap();",
      "context": [
        "        let test_content = b\"Hello World\\nThis is a test\\nAnother line\\n\";",
        "        let test_file = \"/tmp/test_mmap.txt\";",
        "        fs::write(test_file, test_content).unwrap();",
        "",
        "        Python::with_gil(|py| {",
        "            let mmap_file = MemoryMappedFile::new(test_file.to_string(), None).unwrap();",
        "",
        "            assert_eq!(mmap_file.size(), test_content.len());",
        "",
        "            let slice = mmap_file.read_slice(0, 5).unwrap();",
        "            assert_eq!(slice, b\"Hello\");"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/memory_mapped.rs",
      "line": 435,
      "code": "let slice = mmap_file.read_slice(0, 5).unwrap();",
      "context": [
        "        Python::with_gil(|py| {",
        "            let mmap_file = MemoryMappedFile::new(test_file.to_string(), None).unwrap();",
        "",
        "            assert_eq!(mmap_file.size(), test_content.len());",
        "",
        "            let slice = mmap_file.read_slice(0, 5).unwrap();",
        "            assert_eq!(slice, b\"Hello\");",
        "",
        "            let line_count = mmap_file.count_lines().unwrap();",
        "            assert_eq!(line_count, 3);",
        "        });"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/memory_mapped.rs",
      "line": 438,
      "code": "let line_count = mmap_file.count_lines().unwrap();",
      "context": [
        "            assert_eq!(mmap_file.size(), test_content.len());",
        "",
        "            let slice = mmap_file.read_slice(0, 5).unwrap();",
        "            assert_eq!(slice, b\"Hello\");",
        "",
        "            let line_count = mmap_file.count_lines().unwrap();",
        "            assert_eq!(line_count, 3);",
        "        });",
        "",
        "        // Cleanup",
        "        fs::remove_file(test_file).ok();"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/lockfree_collections.rs",
      "line": 720,
      "code": "assert!(stack.push(\"item2\".to_string()).unwrap());",
      "context": [
        "    fn test_concurrent_stack() {",
        "        Python::with_gil(|_py| {",
        "            let stack = ConcurrentStack::new(Some(10));",
        "",
        "            assert!(stack.push(\"item1\".to_string()).unwrap());",
        "            assert!(stack.push(\"item2\".to_string()).unwrap());",
        "            assert_eq!(stack.size(), 2);",
        "",
        "            assert_eq!(stack.pop().unwrap(), Some(\"item2\".to_string()));",
        "            assert_eq!(stack.pop().unwrap(), Some(\"item1\".to_string()));",
        "            assert!(stack.is_empty());"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/lockfree_collections.rs",
      "line": 723,
      "code": "assert_eq!(stack.pop().unwrap(), Some(\"item2\".to_string()));",
      "context": [
        "",
        "            assert!(stack.push(\"item1\".to_string()).unwrap());",
        "            assert!(stack.push(\"item2\".to_string()).unwrap());",
        "            assert_eq!(stack.size(), 2);",
        "",
        "            assert_eq!(stack.pop().unwrap(), Some(\"item2\".to_string()));",
        "            assert_eq!(stack.pop().unwrap(), Some(\"item1\".to_string()));",
        "            assert!(stack.is_empty());",
        "        });",
        "    }",
        ""
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/lockfree_collections.rs",
      "line": 735,
      "code": "assert!(queue.enqueue(\"item2\".to_string()).unwrap());",
      "context": [
        "    fn test_concurrent_queue() {",
        "        Python::with_gil(|_py| {",
        "            let queue = ConcurrentQueue::new(Some(5));",
        "",
        "            assert!(queue.enqueue(\"item1\".to_string()).unwrap());",
        "            assert!(queue.enqueue(\"item2\".to_string()).unwrap());",
        "            assert_eq!(queue.size(), 2);",
        "",
        "            assert_eq!(queue.dequeue().unwrap(), Some(\"item1\".to_string()));",
        "            assert_eq!(queue.dequeue().unwrap(), Some(\"item2\".to_string()));",
        "            assert!(queue.is_empty());"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/lockfree_collections.rs",
      "line": 738,
      "code": "assert_eq!(queue.dequeue().unwrap(), Some(\"item1\".to_string()));",
      "context": [
        "",
        "            assert!(queue.enqueue(\"item1\".to_string()).unwrap());",
        "            assert!(queue.enqueue(\"item2\".to_string()).unwrap());",
        "            assert_eq!(queue.size(), 2);",
        "",
        "            assert_eq!(queue.dequeue().unwrap(), Some(\"item1\".to_string()));",
        "            assert_eq!(queue.dequeue().unwrap(), Some(\"item2\".to_string()));",
        "            assert!(queue.is_empty());",
        "        });",
        "    }",
        ""
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/lockfree_collections.rs",
      "line": 764,
      "code": "collector.add_to_counter(\"requests\".to_string(), 5).unwrap();",
      "context": [
        "    fn test_metrics_collector() {",
        "        Python::with_gil(|_py| {",
        "            let collector = MetricsCollector::new();",
        "",
        "            collector.increment_counter(\"requests\".to_string()).unwrap();",
        "            collector.add_to_counter(\"requests\".to_string(), 5).unwrap();",
        "            assert_eq!(collector.get_counter(\"requests\".to_string()).unwrap(), 6);",
        "",
        "            collector.set_gauge(\"memory_usage\".to_string(), 1024).unwrap();",
        "            assert_eq!(collector.get_gauge(\"memory_usage\".to_string()).unwrap(), 1024);",
        ""
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/lockfree_collections.rs",
      "line": 765,
      "code": "assert_eq!(collector.get_counter(\"requests\".to_string()).unwrap(), 6);",
      "context": [
        "        Python::with_gil(|_py| {",
        "            let collector = MetricsCollector::new();",
        "",
        "            collector.increment_counter(\"requests\".to_string()).unwrap();",
        "            collector.add_to_counter(\"requests\".to_string(), 5).unwrap();",
        "            assert_eq!(collector.get_counter(\"requests\".to_string()).unwrap(), 6);",
        "",
        "            collector.set_gauge(\"memory_usage\".to_string(), 1024).unwrap();",
        "            assert_eq!(collector.get_gauge(\"memory_usage\".to_string()).unwrap(), 1024);",
        "",
        "            collector.record_histogram(\"latency\".to_string(), 123.45).unwrap();"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/lockfree_collections.rs",
      "line": 767,
      "code": "collector.set_gauge(\"memory_usage\".to_string(), 1024).unwrap();",
      "context": [
        "",
        "            collector.increment_counter(\"requests\".to_string()).unwrap();",
        "            collector.add_to_counter(\"requests\".to_string(), 5).unwrap();",
        "            assert_eq!(collector.get_counter(\"requests\".to_string()).unwrap(), 6);",
        "",
        "            collector.set_gauge(\"memory_usage\".to_string(), 1024).unwrap();",
        "            assert_eq!(collector.get_gauge(\"memory_usage\".to_string()).unwrap(), 1024);",
        "",
        "            collector.record_histogram(\"latency\".to_string(), 123.45).unwrap();",
        "            let stats = collector.get_histogram_stats(\"latency\".to_string()).unwrap();",
        "            assert_eq!(stats.get(\"count\").unwrap(), &1.0);"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/lockfree_collections.rs",
      "line": 768,
      "code": "assert_eq!(collector.get_gauge(\"memory_usage\".to_string()).unwrap(), 1024);",
      "context": [
        "            collector.increment_counter(\"requests\".to_string()).unwrap();",
        "            collector.add_to_counter(\"requests\".to_string(), 5).unwrap();",
        "            assert_eq!(collector.get_counter(\"requests\".to_string()).unwrap(), 6);",
        "",
        "            collector.set_gauge(\"memory_usage\".to_string(), 1024).unwrap();",
        "            assert_eq!(collector.get_gauge(\"memory_usage\".to_string()).unwrap(), 1024);",
        "",
        "            collector.record_histogram(\"latency\".to_string(), 123.45).unwrap();",
        "            let stats = collector.get_histogram_stats(\"latency\".to_string()).unwrap();",
        "            assert_eq!(stats.get(\"count\").unwrap(), &1.0);",
        "        });"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/lockfree_collections.rs",
      "line": 770,
      "code": "collector.record_histogram(\"latency\".to_string(), 123.45).unwrap();",
      "context": [
        "            assert_eq!(collector.get_counter(\"requests\".to_string()).unwrap(), 6);",
        "",
        "            collector.set_gauge(\"memory_usage\".to_string(), 1024).unwrap();",
        "            assert_eq!(collector.get_gauge(\"memory_usage\".to_string()).unwrap(), 1024);",
        "",
        "            collector.record_histogram(\"latency\".to_string(), 123.45).unwrap();",
        "            let stats = collector.get_histogram_stats(\"latency\".to_string()).unwrap();",
        "            assert_eq!(stats.get(\"count\").unwrap(), &1.0);",
        "        });",
        "    }",
        "}"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/lockfree_collections.rs",
      "line": 771,
      "code": "let stats = collector.get_histogram_stats(\"latency\".to_string()).unwrap();",
      "context": [
        "",
        "            collector.set_gauge(\"memory_usage\".to_string(), 1024).unwrap();",
        "            assert_eq!(collector.get_gauge(\"memory_usage\".to_string()).unwrap(), 1024);",
        "",
        "            collector.record_histogram(\"latency\".to_string(), 123.45).unwrap();",
        "            let stats = collector.get_histogram_stats(\"latency\".to_string()).unwrap();",
        "            assert_eq!(stats.get(\"count\").unwrap(), &1.0);",
        "        });",
        "    }",
        "}"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/adaptive_learning.rs",
      "line": 211,
      "code": "self.process_single_pattern_optimized(pattern.to_slice().unwrap())",
      "context": [
        "        // Parallel batch processing",
        "        let results: Vec<f64> = (0..num_patterns)",
        "            .into_par_iter()",
        "            .map(|i| {",
        "                let pattern = patterns.row(i);",
        "                self.process_single_pattern_optimized(pattern.to_slice().unwrap())",
        "            })",
        "            .collect::<Vec<f64>>();",
        "",
        "        // Convert results to Python",
        "        let py_results = PyList::new(py, results);"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/adaptive_learning.rs",
      "line": 295,
      "code": ".unwrap()",
      "context": [
        "",
        "        ProcessedPattern {",
        "            pattern_id: format!(\"pattern_{}\",",
        "                std::time::SystemTime::now()",
        "                    .duration_since(std::time::UNIX_EPOCH)",
        "                    .unwrap()",
        "                    .as_nanos()",
        "            ),",
        "            features: PatternFeatures {",
        "                frequency: frequency_features,",
        "                statistical: statistical_features,"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/adaptive_learning.rs",
      "line": 735,
      "code": "dict.set_item(\"pattern_id\", &pattern.pattern_id).unwrap();",
      "context": [
        "",
        "    // Conversion helpers",
        "    fn convert_patterns_to_python(&self, py: Python<'_>, patterns: &[ProcessedPattern]) -> PyResult<PyObject> {",
        "        let py_list = PyList::new(py, patterns.iter().map(|pattern| {",
        "            let dict = PyDict::new(py);",
        "            dict.set_item(\"pattern_id\", &pattern.pattern_id).unwrap();",
        "            dict.set_item(\"confidence\", pattern.confidence).unwrap();",
        "            dict.set_item(\"enhancement_score\", pattern.enhancement_score).unwrap();",
        "            dict",
        "        }));",
        ""
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/adaptive_learning.rs",
      "line": 736,
      "code": "dict.set_item(\"confidence\", pattern.confidence).unwrap();",
      "context": [
        "    // Conversion helpers",
        "    fn convert_patterns_to_python(&self, py: Python<'_>, patterns: &[ProcessedPattern]) -> PyResult<PyObject> {",
        "        let py_list = PyList::new(py, patterns.iter().map(|pattern| {",
        "            let dict = PyDict::new(py);",
        "            dict.set_item(\"pattern_id\", &pattern.pattern_id).unwrap();",
        "            dict.set_item(\"confidence\", pattern.confidence).unwrap();",
        "            dict.set_item(\"enhancement_score\", pattern.enhancement_score).unwrap();",
        "            dict",
        "        }));",
        "",
        "        Ok(py_list.into())"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/adaptive_learning.rs",
      "line": 737,
      "code": "dict.set_item(\"enhancement_score\", pattern.enhancement_score).unwrap();",
      "context": [
        "    fn convert_patterns_to_python(&self, py: Python<'_>, patterns: &[ProcessedPattern]) -> PyResult<PyObject> {",
        "        let py_list = PyList::new(py, patterns.iter().map(|pattern| {",
        "            let dict = PyDict::new(py);",
        "            dict.set_item(\"pattern_id\", &pattern.pattern_id).unwrap();",
        "            dict.set_item(\"confidence\", pattern.confidence).unwrap();",
        "            dict.set_item(\"enhancement_score\", pattern.enhancement_score).unwrap();",
        "            dict",
        "        }));",
        "",
        "        Ok(py_list.into())",
        "    }"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/zero_copy_net.rs",
      "line": 260,
      "code": "let runtime = tokio::runtime::Runtime::new().unwrap();",
      "context": [
        "    }",
        "",
        "    /// Connect to a server",
        "    fn connect(&self, py: Python, address: String, port: u16) -> PyResult<String> {",
        "        py.allow_threads(|| {",
        "            let runtime = tokio::runtime::Runtime::new().unwrap();",
        "            runtime.block_on(async {",
        "                let addr = format!(\"{}:{}\", address, port);",
        "                match TcpStream::connect(&addr).await {",
        "                    Ok(stream) => {",
        "                        let connection_id = format!(\"{}_{}\", addr, Instant::now().elapsed().as_nanos());"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/zero_copy_net.rs",
      "line": 392,
      "code": "let runtime = tokio::runtime::Runtime::new().unwrap();",
      "context": [
        "                    return Ok(connection_id);",
        "                }",
        "            }",
        "",
        "            // Create new connection",
        "            let runtime = tokio::runtime::Runtime::new().unwrap();",
        "            runtime.block_on(async {",
        "                match TcpStream::connect(&address).await {",
        "                    Ok(stream) => {",
        "                        let connection_id = format!(\"new_{}_{}\", address, Instant::now().elapsed().as_nanos());",
        ""
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/zero_copy_net.rs",
      "line": 618,
      "code": "let read_result = buffer.read_data(3).unwrap();",
      "context": [
        "        let mut buffer = NetworkBuffer::new(1024);",
        "",
        "        let write_result = buffer.write_data(vec![1, 2, 3, 4, 5]).unwrap();",
        "        assert_eq!(write_result, 5);",
        "",
        "        let read_result = buffer.read_data(3).unwrap();",
        "        assert_eq!(read_result, vec![1, 2, 3]);",
        "",
        "        let stats = buffer.get_stats().unwrap();",
        "        assert_eq!(stats[\"used\"], 2); // 5 written, 3 read",
        "    }"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/performance.rs",
      "line": 159,
      "code": "tx_io.send((task.id.clone(), duration.as_secs_f64())).unwrap();",
      "context": [
        "                io_tasks.par_iter().for_each(|task| {",
        "                    let start = Instant::now();",
        "                    // Simulate I/O operation",
        "                    std::thread::sleep(Duration::from_millis(10));",
        "                    let duration = start.elapsed();",
        "                    tx_io.send((task.id.clone(), duration.as_secs_f64())).unwrap();",
        "                });",
        "            });",
        "        }",
        "",
        "        // CPU tasks - use compute pool"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/performance.rs",
      "line": 176,
      "code": "tx_cpu.send((task.id.clone(), duration.as_secs_f64())).unwrap();",
      "context": [
        "                    let mut sum = 0u64;",
        "                    for i in 0..1_000_000 {",
        "                        sum = sum.wrapping_add(i);",
        "                    }",
        "                    let duration = start.elapsed();",
        "                    tx_cpu.send((task.id.clone(), duration.as_secs_f64())).unwrap();",
        "                });",
        "            });",
        "        }",
        "",
        "        // Async tasks - use tokio runtime"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/performance.rs",
      "line": 184,
      "code": "let runtime = tokio::runtime::Runtime::new().unwrap();",
      "context": [
        "        }",
        "",
        "        // Async tasks - use tokio runtime",
        "        if !async_tasks.is_empty() {",
        "            py.allow_threads(|| {",
        "                let runtime = tokio::runtime::Runtime::new().unwrap();",
        "                runtime.block_on(async {",
        "                    for task in async_tasks {",
        "                        let tx_async = tx.clone();",
        "                        tokio::spawn(async move {",
        "                            let start = Instant::now();"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/performance.rs",
      "line": 192,
      "code": "tx_async.send((task.id.clone(), duration.as_secs_f64())).unwrap();",
      "context": [
        "                        let tx_async = tx.clone();",
        "                        tokio::spawn(async move {",
        "                            let start = Instant::now();",
        "                            tokio::time::sleep(Duration::from_millis(5)).await;",
        "                            let duration = start.elapsed();",
        "                            tx_async.send((task.id.clone(), duration.as_secs_f64())).unwrap();",
        "                        });",
        "                    }",
        "                });",
        "            });",
        "        }"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/performance.rs",
      "line": 267,
      "code": "sorted.sort_by(|a, b| a.partial_cmp(b).unwrap());",
      "context": [
        "                let sum: f64 = values.iter().sum();",
        "                let count = values.len() as f64;",
        "                let mean = sum / count;",
        "",
        "                let mut sorted = values.clone();",
        "                sorted.sort_by(|a, b| a.partial_cmp(b).unwrap());",
        "",
        "                stats.insert(\"count\".to_string(), count);",
        "                stats.insert(\"mean\".to_string(), mean);",
        "                stats.insert(\"min\".to_string(), *sorted.first().unwrap());",
        "                stats.insert(\"max\".to_string(), *sorted.last().unwrap());"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/performance.rs",
      "line": 271,
      "code": "stats.insert(\"min\".to_string(), *sorted.first().unwrap());",
      "context": [
        "                let mut sorted = values.clone();",
        "                sorted.sort_by(|a, b| a.partial_cmp(b).unwrap());",
        "",
        "                stats.insert(\"count\".to_string(), count);",
        "                stats.insert(\"mean\".to_string(), mean);",
        "                stats.insert(\"min\".to_string(), *sorted.first().unwrap());",
        "                stats.insert(\"max\".to_string(), *sorted.last().unwrap());",
        "                stats.insert(\"p50\".to_string(), sorted[sorted.len() / 2]);",
        "                stats.insert(\"p95\".to_string(), sorted[(sorted.len() as f64 * 0.95) as usize]);",
        "                stats.insert(\"p99\".to_string(), sorted[(sorted.len() as f64 * 0.99) as usize]);",
        "            }"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/performance.rs",
      "line": 272,
      "code": "stats.insert(\"max\".to_string(), *sorted.last().unwrap());",
      "context": [
        "                sorted.sort_by(|a, b| a.partial_cmp(b).unwrap());",
        "",
        "                stats.insert(\"count\".to_string(), count);",
        "                stats.insert(\"mean\".to_string(), mean);",
        "                stats.insert(\"min\".to_string(), *sorted.first().unwrap());",
        "                stats.insert(\"max\".to_string(), *sorted.last().unwrap());",
        "                stats.insert(\"p50\".to_string(), sorted[sorted.len() / 2]);",
        "                stats.insert(\"p95\".to_string(), sorted[(sorted.len() as f64 * 0.95) as usize]);",
        "                stats.insert(\"p99\".to_string(), sorted[(sorted.len() as f64 * 0.99) as usize]);",
        "            }",
        "        }"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/performance.rs",
      "line": 398,
      "code": "let _json = serde_json::to_string(&vec![1, 2, 3, 4, 5]).unwrap();",
      "context": [
        "                }",
        "                \"compute\" => {",
        "                    let _sum: i64 = (0..10000).sum();",
        "                }",
        "                \"serialize\" => {",
        "                    let _json = serde_json::to_string(&vec![1, 2, 3, 4, 5]).unwrap();",
        "                }",
        "                _ => {}",
        "            }",
        "",
        "            monitor.end_operation(op.to_string())?;"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/performance.rs",
      "line": 470,
      "code": "let duration = monitor.end_operation(\"test_op\".to_string()).unwrap();",
      "context": [
        "    fn test_performance_monitor() {",
        "        let monitor = PerformanceMonitor::new();",
        "",
        "        monitor.start_operation(\"test_op\".to_string());",
        "        std::thread::sleep(Duration::from_millis(10));",
        "        let duration = monitor.end_operation(\"test_op\".to_string()).unwrap();",
        "",
        "        assert!(duration > 0.01);",
        "",
        "        let stats = monitor.get_operation_stats(\"test_op\").unwrap();",
        "        assert_eq!(stats[\"count\"], 1.0);"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/performance.rs",
      "line": 484,
      "code": "let r2 = pool.acquire().unwrap().unwrap();",
      "context": [
        "    fn test_resource_pool() {",
        "        let pool = ResourcePool::new(3);",
        "",
        "        // Acquire resources",
        "        let r1 = pool.acquire().unwrap().unwrap();",
        "        let r2 = pool.acquire().unwrap().unwrap();",
        "        let r3 = pool.acquire().unwrap().unwrap();",
        "",
        "        // Pool should be exhausted",
        "        assert!(pool.acquire().unwrap().is_none());",
        ""
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/performance.rs",
      "line": 485,
      "code": "let r3 = pool.acquire().unwrap().unwrap();",
      "context": [
        "        let pool = ResourcePool::new(3);",
        "",
        "        // Acquire resources",
        "        let r1 = pool.acquire().unwrap().unwrap();",
        "        let r2 = pool.acquire().unwrap().unwrap();",
        "        let r3 = pool.acquire().unwrap().unwrap();",
        "",
        "        // Pool should be exhausted",
        "        assert!(pool.acquire().unwrap().is_none());",
        "",
        "        // Release one"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/performance.rs",
      "line": 488,
      "code": "assert!(pool.acquire().unwrap().is_none());",
      "context": [
        "        let r1 = pool.acquire().unwrap().unwrap();",
        "        let r2 = pool.acquire().unwrap().unwrap();",
        "        let r3 = pool.acquire().unwrap().unwrap();",
        "",
        "        // Pool should be exhausted",
        "        assert!(pool.acquire().unwrap().is_none());",
        "",
        "        // Release one",
        "        pool.release(r1).unwrap();",
        "",
        "        // Should be able to acquire again"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/performance.rs",
      "line": 491,
      "code": "pool.release(r1).unwrap();",
      "context": [
        "",
        "        // Pool should be exhausted",
        "        assert!(pool.acquire().unwrap().is_none());",
        "",
        "        // Release one",
        "        pool.release(r1).unwrap();",
        "",
        "        // Should be able to acquire again",
        "        let r4 = pool.acquire().unwrap().unwrap();",
        "        assert!(!r4.is_empty());",
        "    }"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/performance.rs",
      "line": 494,
      "code": "let r4 = pool.acquire().unwrap().unwrap();",
      "context": [
        "",
        "        // Release one",
        "        pool.release(r1).unwrap();",
        "",
        "        // Should be able to acquire again",
        "        let r4 = pool.acquire().unwrap().unwrap();",
        "        assert!(!r4.is_empty());",
        "    }",
        "}"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/security.rs",
      "line": 208,
      "code": "serde_json::Value::Number(serde_json::Number::from_f64(security_score).unwrap())",
      "context": [
        "            0.0",
        "        };",
        "",
        "        report.insert(",
        "            \"security_score\".to_string(),",
        "            serde_json::Value::Number(serde_json::Number::from_f64(security_score).unwrap())",
        "        );",
        "",
        "        // Convert report to JSON string",
        "        serde_json::to_string_pretty(&report)",
        "            .map_err(|e| PyErr::new::<pyo3::exceptions::PyValueError, _>(format!(\"JSON serialization error: {}\", e)))"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/security.rs",
      "line": 319,
      "code": "let ciphertext = vault.encrypt(plaintext).unwrap();",
      "context": [
        "    fn test_secure_vault() {",
        "        let key = generate_key(32);",
        "        let vault = SecureVault::new(&key).unwrap();",
        "",
        "        let plaintext = b\"Hello, World!\";",
        "        let ciphertext = vault.encrypt(plaintext).unwrap();",
        "        let decrypted = vault.decrypt(&ciphertext).unwrap();",
        "",
        "        assert_eq!(plaintext, &decrypted[..]);",
        "    }",
        ""
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/security.rs",
      "line": 343,
      "code": "assert!(auditor.check_password_strength(\"Str0ng!P@ssw0rd\").unwrap());",
      "context": [
        "    fn test_security_auditor() {",
        "        let mut auditor = SecurityAuditor::new();",
        "",
        "        // Test password strength",
        "        assert!(!auditor.check_password_strength(\"weak\").unwrap());",
        "        assert!(auditor.check_password_strength(\"Str0ng!P@ssw0rd\").unwrap());",
        "",
        "        // Test vulnerability scanning",
        "        let mut config = HashMap::new();",
        "        config.insert(\"api_url\".to_string(), \"http://api.example.com\".to_string());",
        "        config.insert(\"db_password\".to_string(), \"hardcoded123\".to_string());"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/services/lifecycle.rs",
      "line": 483,
      "code": "manager.register_service(service_id, vec![]).await.unwrap();",
      "context": [
        "        let manager = LifecycleManager::new(config);",
        "",
        "        let service_id = Uuid::new_v4();",
        "",
        "        // Register service",
        "        manager.register_service(service_id, vec![]).await.unwrap();",
        "",
        "        // Check initial state",
        "        let state = manager.get_service_state(service_id).await.unwrap();",
        "        assert_eq!(state, DeploymentState::Pending);",
        ""
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/services/lifecycle.rs",
      "line": 486,
      "code": "let state = manager.get_service_state(service_id).await.unwrap();",
      "context": [
        "",
        "        // Register service",
        "        manager.register_service(service_id, vec![]).await.unwrap();",
        "",
        "        // Check initial state",
        "        let state = manager.get_service_state(service_id).await.unwrap();",
        "        assert_eq!(state, DeploymentState::Pending);",
        "",
        "        // Start service",
        "        manager.start_service(service_id).await.unwrap();",
        ""
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/services/lifecycle.rs",
      "line": 490,
      "code": "manager.start_service(service_id).await.unwrap();",
      "context": [
        "        // Check initial state",
        "        let state = manager.get_service_state(service_id).await.unwrap();",
        "        assert_eq!(state, DeploymentState::Pending);",
        "",
        "        // Start service",
        "        manager.start_service(service_id).await.unwrap();",
        "",
        "        let state = manager.get_service_state(service_id).await.unwrap();",
        "        assert_eq!(state, DeploymentState::Running);",
        "",
        "        // Stop service"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/services/lifecycle.rs",
      "line": 492,
      "code": "let state = manager.get_service_state(service_id).await.unwrap();",
      "context": [
        "        assert_eq!(state, DeploymentState::Pending);",
        "",
        "        // Start service",
        "        manager.start_service(service_id).await.unwrap();",
        "",
        "        let state = manager.get_service_state(service_id).await.unwrap();",
        "        assert_eq!(state, DeploymentState::Running);",
        "",
        "        // Stop service",
        "        manager.stop_service(service_id).await.unwrap();",
        ""
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/services/lifecycle.rs",
      "line": 496,
      "code": "manager.stop_service(service_id).await.unwrap();",
      "context": [
        "",
        "        let state = manager.get_service_state(service_id).await.unwrap();",
        "        assert_eq!(state, DeploymentState::Running);",
        "",
        "        // Stop service",
        "        manager.stop_service(service_id).await.unwrap();",
        "",
        "        let state = manager.get_service_state(service_id).await.unwrap();",
        "        assert_eq!(state, DeploymentState::Stopped);",
        "    }",
        ""
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/services/lifecycle.rs",
      "line": 498,
      "code": "let state = manager.get_service_state(service_id).await.unwrap();",
      "context": [
        "        assert_eq!(state, DeploymentState::Running);",
        "",
        "        // Stop service",
        "        manager.stop_service(service_id).await.unwrap();",
        "",
        "        let state = manager.get_service_state(service_id).await.unwrap();",
        "        assert_eq!(state, DeploymentState::Stopped);",
        "    }",
        "",
        "    #[tokio::test]",
        "    async fn test_state_transitions() {"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/services/registry.rs",
      "line": 342,
      "code": "registry.register_service(metadata.clone()).await.unwrap();",
      "context": [
        "                service_mesh_enabled: false,",
        "                load_balancer_config: None,",
        "            },",
        "        };",
        "",
        "        registry.register_service(metadata.clone()).await.unwrap();",
        "",
        "        let retrieved = registry.get_service(metadata.id).await.unwrap();",
        "        assert_eq!(retrieved.name, metadata.name);",
        "        assert_eq!(retrieved.version, metadata.version);",
        "    }"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/services/registry.rs",
      "line": 344,
      "code": "let retrieved = registry.get_service(metadata.id).await.unwrap();",
      "context": [
        "            },",
        "        };",
        "",
        "        registry.register_service(metadata.clone()).await.unwrap();",
        "",
        "        let retrieved = registry.get_service(metadata.id).await.unwrap();",
        "        assert_eq!(retrieved.name, metadata.name);",
        "        assert_eq!(retrieved.version, metadata.version);",
        "    }",
        "",
        "    #[tokio::test]"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/services/registry.rs",
      "line": 381,
      "code": "handle.await.unwrap().unwrap();",
      "context": [
        "            });",
        "            handles.push(handle);",
        "        }",
        "",
        "        for handle in handles {",
        "            handle.await.unwrap().unwrap();",
        "        }",
        "",
        "        let services = registry.list_services().await.unwrap();",
        "        assert_eq!(services.len(), 100);",
        "    }"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/services/registry.rs",
      "line": 384,
      "code": "let services = registry.list_services().await.unwrap();",
      "context": [
        "",
        "        for handle in handles {",
        "            handle.await.unwrap().unwrap();",
        "        }",
        "",
        "        let services = registry.list_services().await.unwrap();",
        "        assert_eq!(services.len(), 100);",
        "    }",
        "",
        "    #[tokio::test]",
        "    async fn test_service_state_updates() {"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/services/registry.rs",
      "line": 410,
      "code": "registry.register_service(metadata.clone()).await.unwrap();",
      "context": [
        "                service_mesh_enabled: false,",
        "                load_balancer_config: None,",
        "            },",
        "        };",
        "",
        "        registry.register_service(metadata.clone()).await.unwrap();",
        "",
        "        // Update state",
        "        registry.update_service_state(metadata.id, DeploymentState::Running).await.unwrap();",
        "",
        "        let updated = registry.get_service(metadata.id).await.unwrap();"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/services/registry.rs",
      "line": 413,
      "code": "registry.update_service_state(metadata.id, DeploymentState::Running).await.unwrap();",
      "context": [
        "        };",
        "",
        "        registry.register_service(metadata.clone()).await.unwrap();",
        "",
        "        // Update state",
        "        registry.update_service_state(metadata.id, DeploymentState::Running).await.unwrap();",
        "",
        "        let updated = registry.get_service(metadata.id).await.unwrap();",
        "        assert_eq!(updated.state, DeploymentState::Running);",
        "    }",
        "}"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/services/registry.rs",
      "line": 415,
      "code": "let updated = registry.get_service(metadata.id).await.unwrap();",
      "context": [
        "        registry.register_service(metadata.clone()).await.unwrap();",
        "",
        "        // Update state",
        "        registry.update_service_state(metadata.id, DeploymentState::Running).await.unwrap();",
        "",
        "        let updated = registry.get_service(metadata.id).await.unwrap();",
        "        assert_eq!(updated.state, DeploymentState::Running);",
        "    }",
        "}"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/services/health_check.rs",
      "line": 131,
      "code": "(now - task.last_check.unwrap()).num_seconds() >= task.current_interval_secs as i64",
      "context": [
        "                        let now = chrono::Utc::now();",
        "                        let tasks_to_check: Vec<_> = tasks.iter()",
        "                            .filter(|entry| {",
        "                                let task = entry.value();",
        "                                task.last_check.is_none() ||",
        "                                (now - task.last_check.unwrap()).num_seconds() >= task.current_interval_secs as i64",
        "                            })",
        "                            .map(|entry| (*entry.key(), entry.value().clone()))",
        "                            .collect::<Vec<(Uuid, HealthCheckTask)>>();",
        "",
        "                        for (service_id, mut task) in tasks_to_check {"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/services/health_check.rs",
      "line": 147,
      "code": "let _permit = permit.unwrap();",
      "context": [
        "                            let config = config.clone();",
        "                            let results = results.clone();",
        "                            let tasks = tasks.clone();",
        "",
        "                            tokio::spawn(async move {",
        "                                let _permit = permit.unwrap();",
        "",
        "                                let result = Self::perform_health_check(",
        "                                    service_id,",
        "                                    &task.config,",
        "                                    config.timeout_secs"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/services/health_check.rs",
      "line": 435,
      "code": "checker.start().await.unwrap();",
      "context": [
        "    #[tokio::test]",
        "    async fn test_health_checker_creation() {",
        "        let config = HealthCheckConfig::default();",
        "        let checker = HealthChecker::new(config);",
        "",
        "        checker.start().await.unwrap();",
        "",
        "        // Register a service",
        "        checker.register_service(",
        "            Uuid::new_v4(),",
        "            \"http://localhost:8080/health\".to_string(),"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/services/health_check.rs",
      "line": 442,
      "code": ").await.unwrap();",
      "context": [
        "        // Register a service",
        "        checker.register_service(",
        "            Uuid::new_v4(),",
        "            \"http://localhost:8080/health\".to_string(),",
        "            HealthCheckType::Http,",
        "        ).await.unwrap();",
        "",
        "        checker.stop().await.unwrap();",
        "    }",
        "",
        "    #[tokio::test]"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/services/health_check.rs",
      "line": 444,
      "code": "checker.stop().await.unwrap();",
      "context": [
        "            Uuid::new_v4(),",
        "            \"http://localhost:8080/health\".to_string(),",
        "            HealthCheckType::Http,",
        "        ).await.unwrap();",
        "",
        "        checker.stop().await.unwrap();",
        "    }",
        "",
        "    #[tokio::test]",
        "    async fn test_health_check_results() {",
        "        let config = HealthCheckConfig {"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/orchestrator/scheduler.rs",
      "line": 413,
      "code": "scheduler.schedule_deployment(task.clone()).await.unwrap();",
      "context": [
        "                disk_mb: 2048,",
        "            },",
        "            priority: 100,",
        "        };",
        "",
        "        scheduler.schedule_deployment(task.clone()).await.unwrap();",
        "",
        "        let stats = scheduler.get_stats().await;",
        "        assert_eq!(stats.queued_tasks, 1);",
        "",
        "        let next_task = scheduler.get_next_task().await;"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/orchestrator/scheduler.rs",
      "line": 420,
      "code": "assert_eq!(next_task.unwrap().service_id, task.service_id);",
      "context": [
        "        let stats = scheduler.get_stats().await;",
        "        assert_eq!(stats.queued_tasks, 1);",
        "",
        "        let next_task = scheduler.get_next_task().await;",
        "        assert!(next_task.is_some());",
        "        assert_eq!(next_task.unwrap().service_id, task.service_id);",
        "    }",
        "",
        "    #[tokio::test]",
        "    async fn test_priority_scheduling() {",
        "        let config = SchedulerConfig::default();"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/orchestrator/scheduler.rs",
      "line": 456,
      "code": "scheduler.schedule_deployment(low_priority.clone()).await.unwrap();",
      "context": [
        "                disk_mb: 1024,",
        "            },",
        "            priority: 150,",
        "        };",
        "",
        "        scheduler.schedule_deployment(low_priority.clone()).await.unwrap();",
        "        scheduler.schedule_deployment(high_priority.clone()).await.unwrap();",
        "",
        "        // High priority should be scheduled first",
        "        let next = scheduler.get_next_task().await.unwrap();",
        "        assert_eq!(next.service_id, high_priority.service_id);"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/orchestrator/scheduler.rs",
      "line": 457,
      "code": "scheduler.schedule_deployment(high_priority.clone()).await.unwrap();",
      "context": [
        "            },",
        "            priority: 150,",
        "        };",
        "",
        "        scheduler.schedule_deployment(low_priority.clone()).await.unwrap();",
        "        scheduler.schedule_deployment(high_priority.clone()).await.unwrap();",
        "",
        "        // High priority should be scheduled first",
        "        let next = scheduler.get_next_task().await.unwrap();",
        "        assert_eq!(next.service_id, high_priority.service_id);",
        "    }"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/orchestrator/scheduler.rs",
      "line": 460,
      "code": "let next = scheduler.get_next_task().await.unwrap();",
      "context": [
        "",
        "        scheduler.schedule_deployment(low_priority.clone()).await.unwrap();",
        "        scheduler.schedule_deployment(high_priority.clone()).await.unwrap();",
        "",
        "        // High priority should be scheduled first",
        "        let next = scheduler.get_next_task().await.unwrap();",
        "        assert_eq!(next.service_id, high_priority.service_id);",
        "    }",
        "}"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/orchestrator/executor.rs",
      "line": 402,
      "code": "let result = executor.execute_deployment(service_id).await.unwrap();",
      "context": [
        "            ..Default::default()",
        "        };",
        "        let executor = Executor::new(config);",
        "",
        "        let service_id = Uuid::new_v4();",
        "        let result = executor.execute_deployment(service_id).await.unwrap();",
        "",
        "        assert!(result.success);",
        "        assert_eq!(result.service_id, service_id);",
        "        assert!(result.duration_ms > 0);",
        "        assert!(result.error.is_none());"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/orchestrator/executor.rs",
      "line": 430,
      "code": "executor_clone.cancel_execution(service_id).await.unwrap();",
      "context": [
        "",
        "        // Give it time to start",
        "        sleep(Duration::from_millis(50)).await;",
        "",
        "        // Cancel it",
        "        executor_clone.cancel_execution(service_id).await.unwrap();",
        "",
        "        // Wait for result",
        "        let result = exec_handle.await.unwrap();",
        "        assert!(result.is_err() || !result.unwrap().success);",
        "    }"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/orchestrator/executor.rs",
      "line": 433,
      "code": "let result = exec_handle.await.unwrap();",
      "context": [
        "",
        "        // Cancel it",
        "        executor_clone.cancel_execution(service_id).await.unwrap();",
        "",
        "        // Wait for result",
        "        let result = exec_handle.await.unwrap();",
        "        assert!(result.is_err() || !result.unwrap().success);",
        "    }",
        "}"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/orchestrator/executor.rs",
      "line": 434,
      "code": "assert!(result.is_err() || !result.unwrap().success);",
      "context": [
        "        // Cancel it",
        "        executor_clone.cancel_execution(service_id).await.unwrap();",
        "",
        "        // Wait for result",
        "        let result = exec_handle.await.unwrap();",
        "        assert!(result.is_err() || !result.unwrap().success);",
        "    }",
        "}"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/orchestrator/engine.rs",
      "line": 397,
      "code": "let engine = OrchestrationEngine::new(config).await.unwrap();",
      "context": [
        "    use super::*;",
        "",
        "    #[tokio::test]",
        "    async fn test_engine_creation() {",
        "        let config = EngineConfig::default();",
        "        let engine = OrchestrationEngine::new(config).await.unwrap();",
        "        assert!(engine.list_services().await.unwrap().is_empty());",
        "    }",
        "",
        "    #[tokio::test]",
        "    async fn test_service_deployment() {"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/orchestrator/engine.rs",
      "line": 398,
      "code": "assert!(engine.list_services().await.unwrap().is_empty());",
      "context": [
        "",
        "    #[tokio::test]",
        "    async fn test_engine_creation() {",
        "        let config = EngineConfig::default();",
        "        let engine = OrchestrationEngine::new(config).await.unwrap();",
        "        assert!(engine.list_services().await.unwrap().is_empty());",
        "    }",
        "",
        "    #[tokio::test]",
        "    async fn test_service_deployment() {",
        "        let config = EngineConfig::default();"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/orchestrator/engine.rs",
      "line": 404,
      "code": "let engine = OrchestrationEngine::new(config).await.unwrap();",
      "context": [
        "    }",
        "",
        "    #[tokio::test]",
        "    async fn test_service_deployment() {",
        "        let config = EngineConfig::default();",
        "        let engine = OrchestrationEngine::new(config).await.unwrap();",
        "",
        "        let resources = ResResourceRequest {",
        "            cpu_cores: 1.0,",
        "            memory_mb: 512,",
        "            disk_mb: 1024,"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/orchestrator/engine.rs",
      "line": 416,
      "code": ").await.unwrap();",
      "context": [
        "",
        "        let metadata = engine.deploy_service(",
        "            \"test-service\".to_string(),",
        "            \"1.0.0\".to_string(),",
        "            resources,",
        "        ).await.unwrap();",
        "",
        "        assert_eq!(metadata.name, \"test-service\");",
        "        assert_eq!(metadata.version, \"1.0.0\");",
        "        assert_eq!(metadata.state, DeploymentState::Pending);",
        "    }"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/server.rs",
      "line": 305,
      "code": "let server = McpServer::new(\"test-1\".to_string(), config).unwrap();",
      "context": [
        "    }",
        "",
        "    #[tokio::test]",
        "    async fn test_server_creation() {",
        "        let config = create_test_config();",
        "        let server = McpServer::new(\"test-1\".to_string(), config).unwrap();",
        "",
        "        assert_eq!(server.id(), \"test-1\");",
        "        assert_eq!(server.name(), \"test-server\");",
        "        assert_eq!(server.priority(), 10);",
        "        assert_eq!(server.state().await, ServerState::Initializing);"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/server.rs",
      "line": 316,
      "code": "let server = McpServer::new(\"test-1\".to_string(), config).unwrap();",
      "context": [
        "    }",
        "",
        "    #[tokio::test]",
        "    async fn test_server_state_transitions() {",
        "        let config = create_test_config();",
        "        let server = McpServer::new(\"test-1\".to_string(), config).unwrap();",
        "",
        "        assert_eq!(server.state().await, ServerState::Initializing);",
        "",
        "        server.set_state(ServerState::Healthy).await;",
        "        assert_eq!(server.state().await, ServerState::Healthy);"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/server.rs",
      "line": 330,
      "code": "let server = McpServer::new(\"test-1\".to_string(), config).unwrap();",
      "context": [
        "    }",
        "",
        "    #[tokio::test]",
        "    async fn test_server_tags() {",
        "        let config = create_test_config();",
        "        let server = McpServer::new(\"test-1\".to_string(), config).unwrap();",
        "",
        "        assert!(server.matches_tags(&[\"test\".to_string()]));",
        "        assert!(!server.matches_tags(&[\"prod\".to_string()]));",
        "        assert!(!server.matches_tags(&[\"test\".to_string(), \"prod\".to_string()]));",
        "    }"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/deployment.rs",
      "line": 425,
      "code": "let server = manager.deploy_server(\"test-1\".to_string(), server_config).await.unwrap();",
      "context": [
        "        let registry = Arc::new(RwLock::new(ServerRegistry::new()));",
        "        let config = Arc::new(McpConfig::default());",
        "        let manager = DeploymentManager::new(registry.clone(), config);",
        "",
        "        let server_config = create_test_config();",
        "        let server = manager.deploy_server(\"test-1\".to_string(), server_config).await.unwrap();",
        "",
        "        assert_eq!(server.id(), \"test-1\");",
        "",
        "        // Verify server is in registry",
        "        let reg = registry.read().await;"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/deployment.rs",
      "line": 441,
      "code": "manager.deploy_server(\"test-1\".to_string(), server_config).await.unwrap();",
      "context": [
        "        let registry = Arc::new(RwLock::new(ServerRegistry::new()));",
        "        let config = Arc::new(McpConfig::default());",
        "        let manager = DeploymentManager::new(registry, config);",
        "",
        "        let server_config = create_test_config();",
        "        manager.deploy_server(\"test-1\".to_string(), server_config).await.unwrap();",
        "",
        "        let info = manager.get_deployment(\"test-1\").await.unwrap();",
        "        assert_eq!(info.state, DeploymentState::Deployed);",
        "        assert_eq!(info.instances, 1);",
        "    }"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/deployment.rs",
      "line": 443,
      "code": "let info = manager.get_deployment(\"test-1\").await.unwrap();",
      "context": [
        "        let manager = DeploymentManager::new(registry, config);",
        "",
        "        let server_config = create_test_config();",
        "        manager.deploy_server(\"test-1\".to_string(), server_config).await.unwrap();",
        "",
        "        let info = manager.get_deployment(\"test-1\").await.unwrap();",
        "        assert_eq!(info.state, DeploymentState::Deployed);",
        "        assert_eq!(info.instances, 1);",
        "    }",
        "}"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/registry.rs",
      "line": 103,
      "code": "let server = Arc::new(McpServer::new(\"test\".to_string(), config).unwrap());",
      "context": [
        "            retry_policy: Default::default(),",
        "            priority: 5,",
        "            tags: vec![\"test\".to_string()],",
        "        };",
        "",
        "        let server = Arc::new(McpServer::new(\"test\".to_string(), config).unwrap());",
        "",
        "        // Register",
        "        registry.register(\"test\".to_string(), server.clone()).await.unwrap();",
        "        assert_eq!(registry.count(), 1);",
        ""
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/registry.rs",
      "line": 106,
      "code": "registry.register(\"test\".to_string(), server.clone()).await.unwrap();",
      "context": [
        "        };",
        "",
        "        let server = Arc::new(McpServer::new(\"test\".to_string(), config).unwrap());",
        "",
        "        // Register",
        "        registry.register(\"test\".to_string(), server.clone()).await.unwrap();",
        "        assert_eq!(registry.count(), 1);",
        "",
        "        // Get",
        "        let retrieved = registry.get(\"test\");",
        "        assert!(retrieved.is_some());"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/registry.rs",
      "line": 119,
      "code": "registry.unregister(\"test\").await.unwrap();",
      "context": [
        "        let servers = registry.list_servers();",
        "        assert_eq!(servers.len(), 1);",
        "        assert!(servers.contains(&\"test\".to_string()));",
        "",
        "        // Unregister",
        "        registry.unregister(\"test\").await.unwrap();",
        "        assert_eq!(registry.count(), 0);",
        "    }",
        "}"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/actor.rs",
      "line": 442,
      "code": "let servers = runtime.list_servers().await.unwrap();",
      "context": [
        "    async fn test_runtime_lifecycle() {",
        "        let config = McpManagerConfig::default();",
        "        let runtime = McpRuntime::new(config);",
        "",
        "        // List servers (should be empty)",
        "        let servers = runtime.list_servers().await.unwrap();",
        "        assert!(servers.is_empty());",
        "",
        "        // Deploy a server",
        "        let server_config = ServerConfig {",
        "            name: \"test-server\".to_string(),"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/actor.rs",
      "line": 460,
      "code": "let server_id = runtime.deploy(server_config).await.unwrap();",
      "context": [
        "            retry_policy: RetryPolicy::default(),",
        "            priority: 5,",
        "            tags: vec![\"test\".to_string()],",
        "        };",
        "",
        "        let server_id = runtime.deploy(server_config).await.unwrap();",
        "        assert_eq!(server_id, \"test-server\");",
        "",
        "        // List servers (should have one)",
        "        let servers = runtime.list_servers().await.unwrap();",
        "        assert_eq!(servers.len(), 1);"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/actor.rs",
      "line": 464,
      "code": "let servers = runtime.list_servers().await.unwrap();",
      "context": [
        "",
        "        let server_id = runtime.deploy(server_config).await.unwrap();",
        "        assert_eq!(server_id, \"test-server\");",
        "",
        "        // List servers (should have one)",
        "        let servers = runtime.list_servers().await.unwrap();",
        "        assert_eq!(servers.len(), 1);",
        "        assert_eq!(servers[0], \"test-server\");",
        "",
        "        // Get metrics",
        "        let metrics = runtime.get_metrics(None).await.unwrap();"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/actor.rs",
      "line": 469,
      "code": "let metrics = runtime.get_metrics(None).await.unwrap();",
      "context": [
        "        let servers = runtime.list_servers().await.unwrap();",
        "        assert_eq!(servers.len(), 1);",
        "        assert_eq!(servers[0], \"test-server\");",
        "",
        "        // Get metrics",
        "        let metrics = runtime.get_metrics(None).await.unwrap();",
        "        assert_eq!(metrics.active_servers, 1);",
        "        assert!(metrics.total_commands > 0);",
        "",
        "        // Undeploy",
        "        runtime.undeploy(&server_id).await.unwrap();"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/actor.rs",
      "line": 474,
      "code": "runtime.undeploy(&server_id).await.unwrap();",
      "context": [
        "        let metrics = runtime.get_metrics(None).await.unwrap();",
        "        assert_eq!(metrics.active_servers, 1);",
        "        assert!(metrics.total_commands > 0);",
        "",
        "        // Undeploy",
        "        runtime.undeploy(&server_id).await.unwrap();",
        "",
        "        // List servers (should be empty again)",
        "        let servers = runtime.list_servers().await.unwrap();",
        "        assert!(servers.is_empty());",
        ""
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/actor.rs",
      "line": 477,
      "code": "let servers = runtime.list_servers().await.unwrap();",
      "context": [
        "",
        "        // Undeploy",
        "        runtime.undeploy(&server_id).await.unwrap();",
        "",
        "        // List servers (should be empty again)",
        "        let servers = runtime.list_servers().await.unwrap();",
        "        assert!(servers.is_empty());",
        "",
        "        // Shutdown",
        "        runtime.shutdown().await.unwrap();",
        "    }"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/actor.rs",
      "line": 481,
      "code": "runtime.shutdown().await.unwrap();",
      "context": [
        "        // List servers (should be empty again)",
        "        let servers = runtime.list_servers().await.unwrap();",
        "        assert!(servers.is_empty());",
        "",
        "        // Shutdown",
        "        runtime.shutdown().await.unwrap();",
        "    }",
        "}"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/connection_pool.rs",
      "line": 474,
      "code": ").unwrap();",
      "context": [
        "    #[tokio::test]",
        "    async fn test_connection_pool_creation() {",
        "        let pool = ConnectionPool::new(",
        "            \"http://localhost:8080\".to_string(),",
        "            None,",
        "        ).unwrap();",
        "",
        "        assert_eq!(pool.min_connections, 5);",
        "        assert_eq!(pool.max_lifetime, Duration::from_secs(3600));",
        "    }",
        ""
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/connection_pool.rs",
      "line": 485,
      "code": ").unwrap();",
      "context": [
        "    #[tokio::test]",
        "    async fn test_pool_metrics() {",
        "        let pool = ConnectionPool::new(",
        "            \"http://localhost:8080\".to_string(),",
        "            None,",
        "        ).unwrap();",
        "",
        "        let metrics = pool.metrics().await;",
        "        assert_eq!(metrics.active_connections, 0);",
        "        assert_eq!(metrics.idle_connections, 0);",
        "        assert_eq!(metrics.total_created, 0);"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/circuit_breaker.rs",
      "line": 384,
      "code": "assert_eq!(result.unwrap(), 42);",
      "context": [
        "        // Successful execution",
        "        let result = breaker.execute(|| {",
        "            Box::pin(async { Ok::<_, McpError>(42) })",
        "        }).await;",
        "        assert!(result.is_ok());",
        "        assert_eq!(result.unwrap(), 42);",
        "",
        "        // Failed executions to open circuit",
        "        for _ in 0..3 {",
        "            let _ = breaker.execute(|| {",
        "                Box::pin(async { Err::<i32, _>(McpError::Other(\"test error\".to_string())) })"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/async_traits.rs",
      "line": 133,
      "code": "assert!(op.validate().await.unwrap());",
      "context": [
        "",
        "    #[tokio::test]",
        "    async fn test_async_operation() {",
        "        let op = AsyncOperationImpl;",
        "        assert!(op.execute().await.is_ok());",
        "        assert!(op.validate().await.unwrap());",
        "    }",
        "",
        "    #[tokio::test]",
        "    async fn test_box_future_operation() {",
        "        let op = BoxFutureOperationImpl;"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/async_traits.rs",
      "line": 140,
      "code": "assert!(op.validate().await.unwrap());",
      "context": [
        "",
        "    #[tokio::test]",
        "    async fn test_box_future_operation() {",
        "        let op = BoxFutureOperationImpl;",
        "        assert!(op.execute().await.is_ok());",
        "        assert!(op.validate().await.unwrap());",
        "    }",
        "",
        "    #[tokio::test]",
        "    async fn test_send_async_closure() {",
        "        let closure = SendAsyncClosure::new(|| async {"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/manager_v2.rs",
      "line": 246,
      "code": "manager.initialize().await.unwrap();",
      "context": [
        "    async fn test_manager_v2_lifecycle() {",
        "        let config = McpManagerConfig::default();",
        "        let manager = McpManagerV2::new(config);",
        "",
        "        // Initialize (should deploy default servers)",
        "        manager.initialize().await.unwrap();",
        "",
        "        // List servers",
        "        let servers = manager.list_servers().await.unwrap();",
        "        assert!(!servers.is_empty());",
        ""
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/manager_v2.rs",
      "line": 249,
      "code": "let servers = manager.list_servers().await.unwrap();",
      "context": [
        "",
        "        // Initialize (should deploy default servers)",
        "        manager.initialize().await.unwrap();",
        "",
        "        // List servers",
        "        let servers = manager.list_servers().await.unwrap();",
        "        assert!(!servers.is_empty());",
        "",
        "        // Get metrics",
        "        let metrics = manager.get_metrics(None).await.unwrap();",
        "        assert_eq!(metrics.active_servers, servers.len());"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/manager_v2.rs",
      "line": 253,
      "code": "let metrics = manager.get_metrics(None).await.unwrap();",
      "context": [
        "        // List servers",
        "        let servers = manager.list_servers().await.unwrap();",
        "        assert!(!servers.is_empty());",
        "",
        "        // Get metrics",
        "        let metrics = manager.get_metrics(None).await.unwrap();",
        "        assert_eq!(metrics.active_servers, servers.len());",
        "",
        "        // Shutdown",
        "        manager.shutdown().await.unwrap();",
        "    }"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/manager_v2.rs",
      "line": 257,
      "code": "manager.shutdown().await.unwrap();",
      "context": [
        "        // Get metrics",
        "        let metrics = manager.get_metrics(None).await.unwrap();",
        "        assert_eq!(metrics.active_servers, servers.len());",
        "",
        "        // Shutdown",
        "        manager.shutdown().await.unwrap();",
        "    }",
        "",
        "    #[tokio::test]",
        "    async fn test_manager_v2_execute_tool() {",
        "        let mut config = McpManagerConfig::default();"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/manager_v2.rs",
      "line": 280,
      "code": "let server_id = manager.deploy_server(manager.config.servers[0].clone()).await.unwrap();",
      "context": [
        "        });",
        "",
        "        let manager = McpManagerV2::new(config);",
        "",
        "        // Deploy server",
        "        let server_id = manager.deploy_server(manager.config.servers[0].clone()).await.unwrap();",
        "",
        "        // Execute tool (this would fail in tests without actual server)",
        "        let params = serde_json::json!({});",
        "        let result = manager.execute_tool(&server_id, \"docker.ps\", params).await;",
        ""
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/manager_v2.rs",
      "line": 290,
      "code": "manager.shutdown().await.unwrap();",
      "context": [
        "",
        "        // In tests, this might fail, but the structure should work",
        "        assert!(result.is_err() || result.is_ok());",
        "",
        "        // Shutdown",
        "        manager.shutdown().await.unwrap();",
        "    }",
        "}"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/python_bindings.rs",
      "line": 128,
      "code": "Ok(serde_json::to_string(&response).unwrap())",
      "context": [
        "                    .map_err(|e| PyValueError::new_err(format!(\"Invalid request: {}\", e)))?;",
        "",
        "                let response: serde_json::Value = server.execute(request).await",
        "                    .map_err(|e| PyRuntimeError::new_err(format!(\"Execution failed: {}\", e)))?;",
        "",
        "                Ok(serde_json::to_string(&response).unwrap())",
        "            } else {",
        "                Err(PyValueError::new_err(format!(\"Server {} not found\", server_id)))",
        "            }",
        "        })",
        "    }"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/python_bindings.rs",
      "line": 196,
      "code": "Ok(serde_json::to_string(&response).unwrap())",
      "context": [
        "                    .map_err(|e| PyValueError::new_err(format!(\"Invalid request: {}\", e)))?;",
        "",
        "                let response: serde_json::Value = server.execute(request).await",
        "                    .map_err(|e| PyRuntimeError::new_err(format!(\"Execution failed: {}\", e)))?;",
        "",
        "                Ok(serde_json::to_string(&response).unwrap())",
        "            } else {",
        "                Err(PyValueError::new_err(format!(\"Server {} not found\", server_id)))",
        "            }",
        "        })",
        "    }"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/launcher.rs",
      "line": 300,
      "code": "let launcher = McpLauncher::new().unwrap();",
      "context": [
        "        assert!(launcher.is_ok());",
        "    }",
        "",
        "    #[tokio::test]",
        "    async fn test_server_launch() {",
        "        let launcher = McpLauncher::new().unwrap();",
        "        let result = launcher.launch_all().await;",
        "        assert!(result.is_ok());",
        "",
        "        let active = launcher.get_active_servers().await;",
        "        assert!(!active.is_empty());"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/migration.rs",
      "line": 219,
      "code": "let servers = adapter.v2().list_servers().await.unwrap();",
      "context": [
        "        // Test compatibility methods",
        "        assert!(adapter.start().await.is_ok());",
        "        assert!(adapter.stop().await.is_ok());",
        "",
        "        // Can access v2 directly",
        "        let servers = adapter.v2().list_servers().await.unwrap();",
        "        assert!(servers.is_empty() || !servers.is_empty());",
        "    }",
        "",
        "    #[tokio::test]",
        "    async fn test_hybrid_manager() {"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/metrics.rs",
      "line": 25,
      "code": ").unwrap();",
      "context": [
        "",
        "    /// Response time histogram",
        "    static ref RESPONSE_TIME: HistogramVec = HistogramVec::new(",
        "        HistogramOpts::new(\"mcp_response_time_seconds\", \"Response time in seconds\"),",
        "        &[\"server_id\", \"method\"]",
        "    ).unwrap();",
        "",
        "    /// Active connections gauge",
        "    static ref ACTIVE_CONNECTIONS: IntGaugeVec = IntGaugeVec::new(",
        "        Opts::new(\"mcp_active_connections\", \"Number of active connections\"),",
        "        &[\"server_id\"]"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/metrics.rs",
      "line": 31,
      "code": ").unwrap();",
      "context": [
        "",
        "    /// Active connections gauge",
        "    static ref ACTIVE_CONNECTIONS: IntGaugeVec = IntGaugeVec::new(",
        "        Opts::new(\"mcp_active_connections\", \"Number of active connections\"),",
        "        &[\"server_id\"]",
        "    ).unwrap();",
        "",
        "    /// Health check results",
        "    static ref HEALTH_CHECK_RESULTS: IntCounterVec = IntCounterVec::new(",
        "        Opts::new(\"mcp_health_checks_total\", \"Total health check results\"),",
        "        &[\"server_id\", \"result\"]"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/metrics.rs",
      "line": 37,
      "code": ").unwrap();",
      "context": [
        "",
        "    /// Health check results",
        "    static ref HEALTH_CHECK_RESULTS: IntCounterVec = IntCounterVec::new(",
        "        Opts::new(\"mcp_health_checks_total\", \"Total health check results\"),",
        "        &[\"server_id\", \"result\"]",
        "    ).unwrap();",
        "",
        "    /// Circuit breaker state",
        "    static ref CIRCUIT_BREAKER_STATE: IntGaugeVec = IntGaugeVec::new(",
        "        Opts::new(\"mcp_circuit_breaker_state\", \"Circuit breaker state (0=closed, 1=open, 2=half-open)\"),",
        "        &[\"server_id\"]"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/metrics.rs",
      "line": 43,
      "code": ").unwrap();",
      "context": [
        "",
        "    /// Circuit breaker state",
        "    static ref CIRCUIT_BREAKER_STATE: IntGaugeVec = IntGaugeVec::new(",
        "        Opts::new(\"mcp_circuit_breaker_state\", \"Circuit breaker state (0=closed, 1=open, 2=half-open)\"),",
        "        &[\"server_id\"]",
        "    ).unwrap();",
        "",
        "    /// Connection pool metrics",
        "    static ref CONNECTION_POOL_SIZE: IntGaugeVec = IntGaugeVec::new(",
        "        Opts::new(\"mcp_connection_pool_size\", \"Connection pool size\"),",
        "        &[\"server_id\", \"state\"]"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/metrics.rs",
      "line": 49,
      "code": ").unwrap();",
      "context": [
        "",
        "    /// Connection pool metrics",
        "    static ref CONNECTION_POOL_SIZE: IntGaugeVec = IntGaugeVec::new(",
        "        Opts::new(\"mcp_connection_pool_size\", \"Connection pool size\"),",
        "        &[\"server_id\", \"state\"]",
        "    ).unwrap();",
        "",
        "    /// Server availability",
        "    static ref SERVER_AVAILABILITY: GaugeVec = GaugeVec::new(",
        "        Opts::new(\"mcp_server_availability\", \"Server availability percentage\"),",
        "        &[\"server_id\"]"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/metrics.rs",
      "line": 55,
      "code": ").unwrap();",
      "context": [
        "",
        "    /// Server availability",
        "    static ref SERVER_AVAILABILITY: GaugeVec = GaugeVec::new(",
        "        Opts::new(\"mcp_server_availability\", \"Server availability percentage\"),",
        "        &[\"server_id\"]",
        "    ).unwrap();",
        "",
        "    /// Error rate",
        "    static ref ERROR_RATE: GaugeVec = GaugeVec::new(",
        "        Opts::new(\"mcp_error_rate\", \"Error rate per minute\"),",
        "        &[\"server_id\"]"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/metrics.rs",
      "line": 61,
      "code": ").unwrap();",
      "context": [
        "",
        "    /// Error rate",
        "    static ref ERROR_RATE: GaugeVec = GaugeVec::new(",
        "        Opts::new(\"mcp_error_rate\", \"Error rate per minute\"),",
        "        &[\"server_id\"]",
        "    ).unwrap();",
        "}",
        "",
        "/// Metrics collector for MCP operations",
        "pub struct MetricsCollector {",
        "    /// Prometheus registry"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/metrics.rs",
      "line": 80,
      "code": "registry.register(Box::new(REQUEST_COUNTER.clone())).unwrap();",
      "context": [
        "    /// Create a new metrics collector",
        "    pub fn new() -> Self {",
        "        let registry = Registry::new();",
        "",
        "        // Register metrics",
        "        registry.register(Box::new(REQUEST_COUNTER.clone())).unwrap();",
        "        registry.register(Box::new(RESPONSE_TIME.clone())).unwrap();",
        "        registry.register(Box::new(ACTIVE_CONNECTIONS.clone())).unwrap();",
        "        registry.register(Box::new(HEALTH_CHECK_RESULTS.clone())).unwrap();",
        "        registry.register(Box::new(CIRCUIT_BREAKER_STATE.clone())).unwrap();",
        "        registry.register(Box::new(CONNECTION_POOL_SIZE.clone())).unwrap();"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/metrics.rs",
      "line": 81,
      "code": "registry.register(Box::new(RESPONSE_TIME.clone())).unwrap();",
      "context": [
        "    pub fn new() -> Self {",
        "        let registry = Registry::new();",
        "",
        "        // Register metrics",
        "        registry.register(Box::new(REQUEST_COUNTER.clone())).unwrap();",
        "        registry.register(Box::new(RESPONSE_TIME.clone())).unwrap();",
        "        registry.register(Box::new(ACTIVE_CONNECTIONS.clone())).unwrap();",
        "        registry.register(Box::new(HEALTH_CHECK_RESULTS.clone())).unwrap();",
        "        registry.register(Box::new(CIRCUIT_BREAKER_STATE.clone())).unwrap();",
        "        registry.register(Box::new(CONNECTION_POOL_SIZE.clone())).unwrap();",
        "        registry.register(Box::new(SERVER_AVAILABILITY.clone())).unwrap();"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/metrics.rs",
      "line": 82,
      "code": "registry.register(Box::new(ACTIVE_CONNECTIONS.clone())).unwrap();",
      "context": [
        "        let registry = Registry::new();",
        "",
        "        // Register metrics",
        "        registry.register(Box::new(REQUEST_COUNTER.clone())).unwrap();",
        "        registry.register(Box::new(RESPONSE_TIME.clone())).unwrap();",
        "        registry.register(Box::new(ACTIVE_CONNECTIONS.clone())).unwrap();",
        "        registry.register(Box::new(HEALTH_CHECK_RESULTS.clone())).unwrap();",
        "        registry.register(Box::new(CIRCUIT_BREAKER_STATE.clone())).unwrap();",
        "        registry.register(Box::new(CONNECTION_POOL_SIZE.clone())).unwrap();",
        "        registry.register(Box::new(SERVER_AVAILABILITY.clone())).unwrap();",
        "        registry.register(Box::new(ERROR_RATE.clone())).unwrap();"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/metrics.rs",
      "line": 83,
      "code": "registry.register(Box::new(HEALTH_CHECK_RESULTS.clone())).unwrap();",
      "context": [
        "",
        "        // Register metrics",
        "        registry.register(Box::new(REQUEST_COUNTER.clone())).unwrap();",
        "        registry.register(Box::new(RESPONSE_TIME.clone())).unwrap();",
        "        registry.register(Box::new(ACTIVE_CONNECTIONS.clone())).unwrap();",
        "        registry.register(Box::new(HEALTH_CHECK_RESULTS.clone())).unwrap();",
        "        registry.register(Box::new(CIRCUIT_BREAKER_STATE.clone())).unwrap();",
        "        registry.register(Box::new(CONNECTION_POOL_SIZE.clone())).unwrap();",
        "        registry.register(Box::new(SERVER_AVAILABILITY.clone())).unwrap();",
        "        registry.register(Box::new(ERROR_RATE.clone())).unwrap();",
        ""
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/metrics.rs",
      "line": 84,
      "code": "registry.register(Box::new(CIRCUIT_BREAKER_STATE.clone())).unwrap();",
      "context": [
        "        // Register metrics",
        "        registry.register(Box::new(REQUEST_COUNTER.clone())).unwrap();",
        "        registry.register(Box::new(RESPONSE_TIME.clone())).unwrap();",
        "        registry.register(Box::new(ACTIVE_CONNECTIONS.clone())).unwrap();",
        "        registry.register(Box::new(HEALTH_CHECK_RESULTS.clone())).unwrap();",
        "        registry.register(Box::new(CIRCUIT_BREAKER_STATE.clone())).unwrap();",
        "        registry.register(Box::new(CONNECTION_POOL_SIZE.clone())).unwrap();",
        "        registry.register(Box::new(SERVER_AVAILABILITY.clone())).unwrap();",
        "        registry.register(Box::new(ERROR_RATE.clone())).unwrap();",
        "",
        "        Self {"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/metrics.rs",
      "line": 85,
      "code": "registry.register(Box::new(CONNECTION_POOL_SIZE.clone())).unwrap();",
      "context": [
        "        registry.register(Box::new(REQUEST_COUNTER.clone())).unwrap();",
        "        registry.register(Box::new(RESPONSE_TIME.clone())).unwrap();",
        "        registry.register(Box::new(ACTIVE_CONNECTIONS.clone())).unwrap();",
        "        registry.register(Box::new(HEALTH_CHECK_RESULTS.clone())).unwrap();",
        "        registry.register(Box::new(CIRCUIT_BREAKER_STATE.clone())).unwrap();",
        "        registry.register(Box::new(CONNECTION_POOL_SIZE.clone())).unwrap();",
        "        registry.register(Box::new(SERVER_AVAILABILITY.clone())).unwrap();",
        "        registry.register(Box::new(ERROR_RATE.clone())).unwrap();",
        "",
        "        Self {",
        "            registry,"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/metrics.rs",
      "line": 86,
      "code": "registry.register(Box::new(SERVER_AVAILABILITY.clone())).unwrap();",
      "context": [
        "        registry.register(Box::new(RESPONSE_TIME.clone())).unwrap();",
        "        registry.register(Box::new(ACTIVE_CONNECTIONS.clone())).unwrap();",
        "        registry.register(Box::new(HEALTH_CHECK_RESULTS.clone())).unwrap();",
        "        registry.register(Box::new(CIRCUIT_BREAKER_STATE.clone())).unwrap();",
        "        registry.register(Box::new(CONNECTION_POOL_SIZE.clone())).unwrap();",
        "        registry.register(Box::new(SERVER_AVAILABILITY.clone())).unwrap();",
        "        registry.register(Box::new(ERROR_RATE.clone())).unwrap();",
        "",
        "        Self {",
        "            registry,",
        "            custom_metrics: Arc::new(Mutex::new(HashMap::new())),"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/metrics.rs",
      "line": 87,
      "code": "registry.register(Box::new(ERROR_RATE.clone())).unwrap();",
      "context": [
        "        registry.register(Box::new(ACTIVE_CONNECTIONS.clone())).unwrap();",
        "        registry.register(Box::new(HEALTH_CHECK_RESULTS.clone())).unwrap();",
        "        registry.register(Box::new(CIRCUIT_BREAKER_STATE.clone())).unwrap();",
        "        registry.register(Box::new(CONNECTION_POOL_SIZE.clone())).unwrap();",
        "        registry.register(Box::new(SERVER_AVAILABILITY.clone())).unwrap();",
        "        registry.register(Box::new(ERROR_RATE.clone())).unwrap();",
        "",
        "        Self {",
        "            registry,",
        "            custom_metrics: Arc::new(Mutex::new(HashMap::new())),",
        "            running: Arc::new(Mutex::new(false)),"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/metrics.rs",
      "line": 190,
      "code": "encoder.encode(&metric_families, &mut buffer).unwrap();",
      "context": [
        "    pub fn export_prometheus(&self) -> String {",
        "        use prometheus::Encoder;",
        "        let encoder = prometheus::TextEncoder::new();",
        "        let metric_families = self.registry.gather();",
        "        let mut buffer = Vec::new();",
        "        encoder.encode(&metric_families, &mut buffer).unwrap();",
        "        String::from_utf8(buffer).unwrap()",
        "    }",
        "",
        "    /// Record custom metric",
        "    pub async fn record_custom(&self, name: &str, value: f64) {"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/metrics.rs",
      "line": 191,
      "code": "String::from_utf8(buffer).unwrap()",
      "context": [
        "        use prometheus::Encoder;",
        "        let encoder = prometheus::TextEncoder::new();",
        "        let metric_families = self.registry.gather();",
        "        let mut buffer = Vec::new();",
        "        encoder.encode(&metric_families, &mut buffer).unwrap();",
        "        String::from_utf8(buffer).unwrap()",
        "    }",
        "",
        "    /// Record custom metric",
        "    pub async fn record_custom(&self, name: &str, value: f64) {",
        "        self.custom_metrics.lock().await.insert(name.to_string(), value);"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/metrics.rs",
      "line": 295,
      "code": "encoder.encode(&all_metrics, &mut buffer).unwrap();",
      "context": [
        "        }",
        "",
        "        use prometheus::Encoder;",
        "        let encoder = prometheus::TextEncoder::new();",
        "        let mut buffer = Vec::new();",
        "        encoder.encode(&all_metrics, &mut buffer).unwrap();",
        "        String::from_utf8(buffer).unwrap()",
        "    }",
        "}",
        "",
        "/// Metrics dashboard data"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/metrics.rs",
      "line": 296,
      "code": "String::from_utf8(buffer).unwrap()",
      "context": [
        "",
        "        use prometheus::Encoder;",
        "        let encoder = prometheus::TextEncoder::new();",
        "        let mut buffer = Vec::new();",
        "        encoder.encode(&all_metrics, &mut buffer).unwrap();",
        "        String::from_utf8(buffer).unwrap()",
        "    }",
        "}",
        "",
        "/// Metrics dashboard data",
        "#[derive(Debug, Clone, serde::Serialize)]"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/protocol.rs",
      "line": 109,
      "code": ".unwrap();",
      "context": [
        "impl HttpMCPConnection {",
        "    pub fn new(server_url: String) -> Self {",
        "        let client = reqwest::Client::builder()",
        "            .timeout(Duration::from_secs(30))",
        "            .build()",
        "            .unwrap();",
        "",
        "        Self {",
        "            server_url,",
        "            client,",
        "            connected: Arc::new(tokio::sync::RwLock::new(false)),"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/reliability/circuit_breaker.rs",
      "line": 388,
      "code": "assert_eq!(result.unwrap(), 42);",
      "context": [
        "        // Successful operation",
        "        let result: Result<i32, ReliabilityError> = with_circuit_breaker(&breaker, async {",
        "            Ok(42)",
        "        }).await;",
        "",
        "        assert_eq!(result.unwrap(), 42);",
        "        assert_eq!(breaker.stats().total_requests, 1);",
        "        assert_eq!(breaker.stats().failed_requests, 0);",
        "",
        "        // Failed operation",
        "        let result: Result<i32, ReliabilityError> = with_circuit_breaker(&breaker, async {"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/reliability/retry_policy.rs",
      "line": 334,
      "code": "assert_eq!(result.unwrap(), 42);",
      "context": [
        "            } else {",
        "                Ok(42)",
        "            }",
        "        }).await;",
        "",
        "        assert_eq!(result.unwrap(), 42);",
        "        assert_eq!(attempts, 3);",
        "    }",
        "",
        "    #[tokio::test]",
        "    async fn test_retry_max_attempts() {"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/reliability/recovery.rs",
      "line": 418,
      "code": ").await.unwrap();",
      "context": [
        "        let service_id = Uuid::new_v4();",
        "        manager.recover_service(",
        "            service_id,",
        "            \"test-service\".to_string(),",
        "            Some(RecoveryStrategy::Restart)",
        "        ).await.unwrap();",
        "",
        "        let status = manager.get_recovery_status(service_id).await;",
        "        assert!(status.is_some());",
        "        assert_eq!(status.unwrap().strategy, RecoveryStrategy::Restart);",
        "    }"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/reliability/recovery.rs",
      "line": 422,
      "code": "assert_eq!(status.unwrap().strategy, RecoveryStrategy::Restart);",
      "context": [
        "            Some(RecoveryStrategy::Restart)",
        "        ).await.unwrap();",
        "",
        "        let status = manager.get_recovery_status(service_id).await;",
        "        assert!(status.is_some());",
        "        assert_eq!(status.unwrap().strategy, RecoveryStrategy::Restart);",
        "    }",
        "",
        "    #[tokio::test]",
        "    async fn test_recovery_cancellation() {",
        "        let manager = RecoveryManager::new(RecoveryConfig::default());"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/reliability/recovery.rs",
      "line": 434,
      "code": ").await.unwrap();",
      "context": [
        "        let service_id = Uuid::new_v4();",
        "        manager.recover_service(",
        "            service_id,",
        "            \"test-service\".to_string(),",
        "            None",
        "        ).await.unwrap();",
        "",
        "        manager.cancel_recovery(service_id).await.unwrap();",
        "",
        "        let status = manager.get_recovery_status(service_id).await;",
        "        assert!(status.is_none());"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/reliability/recovery.rs",
      "line": 436,
      "code": "manager.cancel_recovery(service_id).await.unwrap();",
      "context": [
        "            service_id,",
        "            \"test-service\".to_string(),",
        "            None",
        "        ).await.unwrap();",
        "",
        "        manager.cancel_recovery(service_id).await.unwrap();",
        "",
        "        let status = manager.get_recovery_status(service_id).await;",
        "        assert!(status.is_none());",
        "    }",
        ""
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/reliability/recovery.rs",
      "line": 452,
      "code": ").await.unwrap();",
      "context": [
        "            let service_id = Uuid::new_v4();",
        "            manager.recover_service(",
        "                service_id,",
        "                format!(\"service-{}\", i),",
        "                Some(RecoveryStrategy::RestartWithBackoff)",
        "            ).await.unwrap();",
        "        }",
        "",
        "        let recoveries = manager.list_recoveries().await;",
        "        assert_eq!(recoveries.len(), 3);",
        "    }"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/memory/hybrid.rs",
      "line": 408,
      "code": ").await.unwrap();",
      "context": [
        "",
        "        memory.store(",
        "            build_pattern.clone(),",
        "            HashSet::from([\"docker.sock\".to_string()]),",
        "            vec![],",
        "        ).await.unwrap();",
        "",
        "        memory.store(",
        "            test_pattern.clone(),",
        "            HashSet::new(),",
        "            vec![(\"build\".to_string(), DependencyType::Sequential, 1.0)],"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/memory/hybrid.rs",
      "line": 414,
      "code": ").await.unwrap();",
      "context": [
        "",
        "        memory.store(",
        "            test_pattern.clone(),",
        "            HashSet::new(),",
        "            vec![(\"build\".to_string(), DependencyType::Sequential, 1.0)],",
        "        ).await.unwrap();",
        "",
        "        memory.store(",
        "            deploy_pattern.clone(),",
        "            HashSet::from([\"kubeconfig\".to_string()]),",
        "            vec![(\"test\".to_string(), DependencyType::Sequential, 1.0)],"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/memory/hybrid.rs",
      "line": 420,
      "code": ").await.unwrap();",
      "context": [
        "",
        "        memory.store(",
        "            deploy_pattern.clone(),",
        "            HashSet::from([\"kubeconfig\".to_string()]),",
        "            vec![(\"test\".to_string(), DependencyType::Sequential, 1.0)],",
        "        ).await.unwrap();",
        "",
        "        // Query for similar patterns and dependencies",
        "        let query = HybridQuery {",
        "            pattern: Some(create_test_pattern(\"query\", \"docker\")),",
        "            command_ids: Some(vec![\"build\".to_string(), \"test\".to_string(), \"deploy\".to_string()]),"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/memory/hybrid.rs",
      "line": 432,
      "code": "let result = memory.query(query).await.unwrap();",
      "context": [
        "            limit: 10,",
        "            include_dependencies: true,",
        "            include_conflicts: true,",
        "        };",
        "",
        "        let result = memory.query(query).await.unwrap();",
        "",
        "        // Check results",
        "        assert!(!result.similar_patterns.is_empty());",
        "        assert_eq!(result.execution_order, Some(vec![\"build\".to_string(), \"test\".to_string(), \"deploy\".to_string()]));",
        "        assert!(!result.correlations.is_empty());"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/memory/hybrid.rs",
      "line": 453,
      "code": ").await.unwrap();",
      "context": [
        "",
        "        memory.store(",
        "            app1,",
        "            HashSet::from([\"port:8080\".to_string()]),",
        "            vec![],",
        "        ).await.unwrap();",
        "",
        "        memory.store(",
        "            app2,",
        "            HashSet::from([\"port:8080\".to_string()]),",
        "            vec![],"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/memory/hybrid.rs",
      "line": 459,
      "code": ").await.unwrap();",
      "context": [
        "",
        "        memory.store(",
        "            app2,",
        "            HashSet::from([\"port:8080\".to_string()]),",
        "            vec![],",
        "        ).await.unwrap();",
        "",
        "        // Query for conflicts",
        "        let query = HybridQuery {",
        "            pattern: None,",
        "            command_ids: Some(vec![\"app1\".to_string(), \"app2\".to_string()]),"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/memory/hybrid.rs",
      "line": 471,
      "code": "let result = memory.query(query).await.unwrap();",
      "context": [
        "            limit: 10,",
        "            include_dependencies: false,",
        "            include_conflicts: true,",
        "        };",
        "",
        "        let result = memory.query(query).await.unwrap();",
        "        assert_eq!(result.conflicts.len(), 1);",
        "        assert_eq!(result.conflicts[0].2, vec![\"port:8080\"]);",
        "    }",
        "}"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/memory/index.rs",
      "line": 335,
      "code": "index.add_entry(\"docker-build-123\", node_idx).unwrap();",
      "context": [
        "    fn test_basic_index_operations() {",
        "        let index = MemoryIndex::new();",
        "        let node_idx = NodeIndex::new(0);",
        "",
        "        // Add entry",
        "        index.add_entry(\"docker-build-123\", node_idx).unwrap();",
        "",
        "        // Lookup",
        "        assert_eq!(index.lookup(\"docker-build-123\"), Some(node_idx));",
        "        assert_eq!(index.lookup(\"nonexistent\"), None);",
        ""
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/memory/index.rs",
      "line": 353,
      "code": "index.add_entry(\"docker-run\", NodeIndex::new(1)).unwrap();",
      "context": [
        "    fn test_prefix_search() {",
        "        let index = MemoryIndex::new();",
        "",
        "        // Add multiple entries",
        "        index.add_entry(\"docker-build\", NodeIndex::new(0)).unwrap();",
        "        index.add_entry(\"docker-run\", NodeIndex::new(1)).unwrap();",
        "        index.add_entry(\"kubectl-apply\", NodeIndex::new(2)).unwrap();",
        "",
        "        // Search by prefix",
        "        let docker_results = index.find_by_prefix(\"docker\");",
        "        assert_eq!(docker_results.len(), 2);"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/memory/index.rs",
      "line": 354,
      "code": "index.add_entry(\"kubectl-apply\", NodeIndex::new(2)).unwrap();",
      "context": [
        "        let index = MemoryIndex::new();",
        "",
        "        // Add multiple entries",
        "        index.add_entry(\"docker-build\", NodeIndex::new(0)).unwrap();",
        "        index.add_entry(\"docker-run\", NodeIndex::new(1)).unwrap();",
        "        index.add_entry(\"kubectl-apply\", NodeIndex::new(2)).unwrap();",
        "",
        "        // Search by prefix",
        "        let docker_results = index.find_by_prefix(\"docker\");",
        "        assert_eq!(docker_results.len(), 2);",
        ""
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/memory/index.rs",
      "line": 373,
      "code": "index.update_resources(\"app1\", &HashSet::from([\"port:8080\".to_string()])).unwrap();",
      "context": [
        "    fn test_resource_index() {",
        "        let index = MemoryIndex::new();",
        "",
        "        // Add entries with resources",
        "        index.add_entry(\"app1\", NodeIndex::new(0)).unwrap();",
        "        index.update_resources(\"app1\", &HashSet::from([\"port:8080\".to_string()])).unwrap();",
        "",
        "        index.add_entry(\"app2\", NodeIndex::new(1)).unwrap();",
        "        index.update_resources(\"app2\", &HashSet::from([\"port:8080\".to_string(), \"db:postgres\".to_string()])).unwrap();",
        "",
        "        // Find by resource"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/memory/index.rs",
      "line": 375,
      "code": "index.add_entry(\"app2\", NodeIndex::new(1)).unwrap();",
      "context": [
        "",
        "        // Add entries with resources",
        "        index.add_entry(\"app1\", NodeIndex::new(0)).unwrap();",
        "        index.update_resources(\"app1\", &HashSet::from([\"port:8080\".to_string()])).unwrap();",
        "",
        "        index.add_entry(\"app2\", NodeIndex::new(1)).unwrap();",
        "        index.update_resources(\"app2\", &HashSet::from([\"port:8080\".to_string(), \"db:postgres\".to_string()])).unwrap();",
        "",
        "        // Find by resource",
        "        let port_results = index.find_by_resource(\"port:8080\");",
        "        assert_eq!(port_results.len(), 2);"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/memory/index.rs",
      "line": 376,
      "code": "index.update_resources(\"app2\", &HashSet::from([\"port:8080\".to_string(), \"db:postgres\".to_string()])).unwrap();",
      "context": [
        "        // Add entries with resources",
        "        index.add_entry(\"app1\", NodeIndex::new(0)).unwrap();",
        "        index.update_resources(\"app1\", &HashSet::from([\"port:8080\".to_string()])).unwrap();",
        "",
        "        index.add_entry(\"app2\", NodeIndex::new(1)).unwrap();",
        "        index.update_resources(\"app2\", &HashSet::from([\"port:8080\".to_string(), \"db:postgres\".to_string()])).unwrap();",
        "",
        "        // Find by resource",
        "        let port_results = index.find_by_resource(\"port:8080\");",
        "        assert_eq!(port_results.len(), 2);",
        ""
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/memory/index.rs",
      "line": 393,
      "code": "index.add_entry(\"cmd1\", NodeIndex::new(0)).unwrap();",
      "context": [
        "    fn test_time_range_search() {",
        "        let index = MemoryIndex::new();",
        "        let now = Utc::now();",
        "",
        "        // Add entries",
        "        index.add_entry(\"cmd1\", NodeIndex::new(0)).unwrap();",
        "        std::thread::sleep(std::time::Duration::from_millis(10));",
        "        index.add_entry(\"cmd2\", NodeIndex::new(1)).unwrap();",
        "",
        "        // Search by time range",
        "        let results = index.find_by_time_range(now - chrono::Duration::seconds(1), now + chrono::Duration::seconds(1));"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/memory/index.rs",
      "line": 395,
      "code": "index.add_entry(\"cmd2\", NodeIndex::new(1)).unwrap();",
      "context": [
        "        let now = Utc::now();",
        "",
        "        // Add entries",
        "        index.add_entry(\"cmd1\", NodeIndex::new(0)).unwrap();",
        "        std::thread::sleep(std::time::Duration::from_millis(10));",
        "        index.add_entry(\"cmd2\", NodeIndex::new(1)).unwrap();",
        "",
        "        // Search by time range",
        "        let results = index.find_by_time_range(now - chrono::Duration::seconds(1), now + chrono::Duration::seconds(1));",
        "        assert_eq!(results.len(), 2);",
        "    }"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/memory/tensor.rs",
      "line": 66,
      "code": "let cache_size = NonZeroUsize::new(cache_size).unwrap_or(NonZeroUsize::new(1000).unwrap());",
      "context": [
        "}",
        "",
        "impl TensorMemory {",
        "    /// Create a new tensor memory instance",
        "    pub fn new(cache_size: usize) -> Self {",
        "        let cache_size = NonZeroUsize::new(cache_size).unwrap_or(NonZeroUsize::new(1000).unwrap());",
        "",
        "        Self {",
        "            config: FeatureConfig::default(),",
        "            patterns: Arc::new(RwLock::new(HashMap::new())),",
        "            metadata: Arc::new(RwLock::new(HashMap::new())),"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/memory/tensor.rs",
      "line": 239,
      "code": "results.sort_by(|a, b| b.similarity_score.partial_cmp(&a.similarity_score).unwrap());",
      "context": [
        "                }",
        "            }",
        "        }",
        "",
        "        // Sort by similarity score (descending)",
        "        results.sort_by(|a, b| b.similarity_score.partial_cmp(&a.similarity_score).unwrap());",
        "",
        "        // Limit results",
        "        results.truncate(limit);",
        "",
        "        Ok(results)"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/memory/tensor.rs",
      "line": 330,
      "code": "let results = memory.find_similar(&pattern, 0.9, 10).unwrap();",
      "context": [
        "        let memory = TensorMemory::new(100);",
        "",
        "        let pattern = create_test_pattern(\"test-1\", \"docker\");",
        "        memory.store_pattern(pattern.clone()).unwrap();",
        "",
        "        let results = memory.find_similar(&pattern, 0.9, 10).unwrap();",
        "        assert_eq!(results.len(), 1);",
        "        assert_eq!(results[0].pattern_id, \"test-1\");",
        "        assert!(results[0].similarity_score >= 0.99);",
        "    }",
        ""
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/memory/tensor.rs",
      "line": 342,
      "code": "memory.store_pattern(create_test_pattern(\"docker-2\", \"docker\")).unwrap();",
      "context": [
        "    fn test_similarity_search() {",
        "        let memory = TensorMemory::new(100);",
        "",
        "        // Store multiple patterns",
        "        memory.store_pattern(create_test_pattern(\"docker-1\", \"docker\")).unwrap();",
        "        memory.store_pattern(create_test_pattern(\"docker-2\", \"docker\")).unwrap();",
        "        memory.store_pattern(create_test_pattern(\"kubectl-1\", \"kubectl\")).unwrap();",
        "",
        "        // Search for similar docker commands",
        "        let query = create_test_pattern(\"query\", \"docker\");",
        "        let results = memory.find_similar(&query, 0.7, 10).unwrap();"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/memory/tensor.rs",
      "line": 343,
      "code": "memory.store_pattern(create_test_pattern(\"kubectl-1\", \"kubectl\")).unwrap();",
      "context": [
        "        let memory = TensorMemory::new(100);",
        "",
        "        // Store multiple patterns",
        "        memory.store_pattern(create_test_pattern(\"docker-1\", \"docker\")).unwrap();",
        "        memory.store_pattern(create_test_pattern(\"docker-2\", \"docker\")).unwrap();",
        "        memory.store_pattern(create_test_pattern(\"kubectl-1\", \"kubectl\")).unwrap();",
        "",
        "        // Search for similar docker commands",
        "        let query = create_test_pattern(\"query\", \"docker\");",
        "        let results = memory.find_similar(&query, 0.7, 10).unwrap();",
        ""
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/memory/tensor.rs",
      "line": 347,
      "code": "let results = memory.find_similar(&query, 0.7, 10).unwrap();",
      "context": [
        "        memory.store_pattern(create_test_pattern(\"docker-2\", \"docker\")).unwrap();",
        "        memory.store_pattern(create_test_pattern(\"kubectl-1\", \"kubectl\")).unwrap();",
        "",
        "        // Search for similar docker commands",
        "        let query = create_test_pattern(\"query\", \"docker\");",
        "        let results = memory.find_similar(&query, 0.7, 10).unwrap();",
        "",
        "        // Should find the docker commands as most similar",
        "        assert!(results.len() >= 2);",
        "        assert!(results[0].pattern.command == \"docker\");",
        "        assert!(results[1].pattern.command == \"docker\");"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/memory/graph.rs",
      "line": 401,
      "code": "let node_idx = graph.add_node(pattern, resources).unwrap();",
      "context": [
        "    fn test_node_addition() {",
        "        let graph = GraphMemory::new(86400);",
        "        let pattern = create_test_pattern(\"test-1\", \"docker\");",
        "        let resources = HashSet::from([\"docker.sock\".to_string()]);",
        "",
        "        let node_idx = graph.add_node(pattern, resources).unwrap();",
        "        assert!(node_idx.index() >= 0);",
        "",
        "        let (nodes, edges, _) = graph.get_stats();",
        "        assert_eq!(nodes, 1);",
        "        assert_eq!(edges, 0);"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/memory/graph.rs",
      "line": 417,
      "code": "graph.add_node(pattern1, HashSet::new()).unwrap();",
      "context": [
        "",
        "        // Add nodes",
        "        let pattern1 = create_test_pattern(\"build\", \"docker build\");",
        "        let pattern2 = create_test_pattern(\"push\", \"docker push\");",
        "",
        "        graph.add_node(pattern1, HashSet::new()).unwrap();",
        "        graph.add_node(pattern2, HashSet::new()).unwrap();",
        "",
        "        // Add dependency",
        "        graph.add_dependency(\"build\", \"push\", DependencyType::Sequential, 0.9).unwrap();",
        ""
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/memory/graph.rs",
      "line": 418,
      "code": "graph.add_node(pattern2, HashSet::new()).unwrap();",
      "context": [
        "        // Add nodes",
        "        let pattern1 = create_test_pattern(\"build\", \"docker build\");",
        "        let pattern2 = create_test_pattern(\"push\", \"docker push\");",
        "",
        "        graph.add_node(pattern1, HashSet::new()).unwrap();",
        "        graph.add_node(pattern2, HashSet::new()).unwrap();",
        "",
        "        // Add dependency",
        "        graph.add_dependency(\"build\", \"push\", DependencyType::Sequential, 0.9).unwrap();",
        "",
        "        // Check dependencies"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/memory/graph.rs",
      "line": 421,
      "code": "graph.add_dependency(\"build\", \"push\", DependencyType::Sequential, 0.9).unwrap();",
      "context": [
        "",
        "        graph.add_node(pattern1, HashSet::new()).unwrap();",
        "        graph.add_node(pattern2, HashSet::new()).unwrap();",
        "",
        "        // Add dependency",
        "        graph.add_dependency(\"build\", \"push\", DependencyType::Sequential, 0.9).unwrap();",
        "",
        "        // Check dependencies",
        "        let deps = graph.find_dependencies(\"push\").unwrap();",
        "        assert_eq!(deps.len(), 1);",
        "        assert_eq!(deps[0].0, \"build\");"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/memory/graph.rs",
      "line": 424,
      "code": "let deps = graph.find_dependencies(\"push\").unwrap();",
      "context": [
        "",
        "        // Add dependency",
        "        graph.add_dependency(\"build\", \"push\", DependencyType::Sequential, 0.9).unwrap();",
        "",
        "        // Check dependencies",
        "        let deps = graph.find_dependencies(\"push\").unwrap();",
        "        assert_eq!(deps.len(), 1);",
        "        assert_eq!(deps[0].0, \"build\");",
        "",
        "        let dependents = graph.find_dependents(\"build\").unwrap();",
        "        assert_eq!(dependents.len(), 1);"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/memory/graph.rs",
      "line": 441,
      "code": "graph.add_node(pattern, HashSet::new()).unwrap();",
      "context": [
        "",
        "        // Create a dependency chain: build -> test -> deploy",
        "        let commands = vec![\"build\", \"test\", \"deploy\"];",
        "        for cmd in &commands {",
        "            let pattern = create_test_pattern(cmd, cmd);",
        "            graph.add_node(pattern, HashSet::new()).unwrap();",
        "        }",
        "",
        "        graph.add_dependency(\"build\", \"test\", DependencyType::Sequential, 1.0).unwrap();",
        "        graph.add_dependency(\"test\", \"deploy\", DependencyType::Sequential, 1.0).unwrap();",
        ""
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/memory/graph.rs",
      "line": 444,
      "code": "graph.add_dependency(\"build\", \"test\", DependencyType::Sequential, 1.0).unwrap();",
      "context": [
        "        for cmd in &commands {",
        "            let pattern = create_test_pattern(cmd, cmd);",
        "            graph.add_node(pattern, HashSet::new()).unwrap();",
        "        }",
        "",
        "        graph.add_dependency(\"build\", \"test\", DependencyType::Sequential, 1.0).unwrap();",
        "        graph.add_dependency(\"test\", \"deploy\", DependencyType::Sequential, 1.0).unwrap();",
        "",
        "        let order = graph.find_execution_order(&commands.iter().map(|s| s.to_string()).collect::<Vec<_>>()).unwrap();",
        "        assert_eq!(order, vec![\"build\", \"test\", \"deploy\"]);",
        "    }"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/memory/graph.rs",
      "line": 445,
      "code": "graph.add_dependency(\"test\", \"deploy\", DependencyType::Sequential, 1.0).unwrap();",
      "context": [
        "            let pattern = create_test_pattern(cmd, cmd);",
        "            graph.add_node(pattern, HashSet::new()).unwrap();",
        "        }",
        "",
        "        graph.add_dependency(\"build\", \"test\", DependencyType::Sequential, 1.0).unwrap();",
        "        graph.add_dependency(\"test\", \"deploy\", DependencyType::Sequential, 1.0).unwrap();",
        "",
        "        let order = graph.find_execution_order(&commands.iter().map(|s| s.to_string()).collect::<Vec<_>>()).unwrap();",
        "        assert_eq!(order, vec![\"build\", \"test\", \"deploy\"]);",
        "    }",
        ""
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/memory/graph.rs",
      "line": 462,
      "code": "graph.add_node(pattern1, resources1).unwrap();",
      "context": [
        "        let pattern2 = create_test_pattern(\"app2\", \"docker run app2\");",
        "",
        "        let resources1 = HashSet::from([\"port:8080\".to_string(), \"db:postgres\".to_string()]);",
        "        let resources2 = HashSet::from([\"port:8080\".to_string(), \"cache:redis\".to_string()]);",
        "",
        "        graph.add_node(pattern1, resources1).unwrap();",
        "        graph.add_node(pattern2, resources2).unwrap();",
        "",
        "        let conflicts = graph.detect_conflicts(&vec![\"app1\".to_string(), \"app2\".to_string()]).unwrap();",
        "        assert_eq!(conflicts.len(), 1);",
        "        assert_eq!(conflicts[0].2, vec![\"port:8080\"]);"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/memory/graph.rs",
      "line": 463,
      "code": "graph.add_node(pattern2, resources2).unwrap();",
      "context": [
        "",
        "        let resources1 = HashSet::from([\"port:8080\".to_string(), \"db:postgres\".to_string()]);",
        "        let resources2 = HashSet::from([\"port:8080\".to_string(), \"cache:redis\".to_string()]);",
        "",
        "        graph.add_node(pattern1, resources1).unwrap();",
        "        graph.add_node(pattern2, resources2).unwrap();",
        "",
        "        let conflicts = graph.detect_conflicts(&vec![\"app1\".to_string(), \"app2\".to_string()]).unwrap();",
        "        assert_eq!(conflicts.len(), 1);",
        "        assert_eq!(conflicts[0].2, vec![\"port:8080\"]);",
        "    }"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/memory/graph.rs",
      "line": 465,
      "code": "let conflicts = graph.detect_conflicts(&vec![\"app1\".to_string(), \"app2\".to_string()]).unwrap();",
      "context": [
        "        let resources2 = HashSet::from([\"port:8080\".to_string(), \"cache:redis\".to_string()]);",
        "",
        "        graph.add_node(pattern1, resources1).unwrap();",
        "        graph.add_node(pattern2, resources2).unwrap();",
        "",
        "        let conflicts = graph.detect_conflicts(&vec![\"app1\".to_string(), \"app2\".to_string()]).unwrap();",
        "        assert_eq!(conflicts.len(), 1);",
        "        assert_eq!(conflicts[0].2, vec![\"port:8080\"]);",
        "    }",
        "}"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/testing/performance.rs",
      "line": 794,
      "code": "let metrics = tester.run_benchmark(operation.clone()).await.unwrap();",
      "context": [
        "        let operation = Arc::new(MockOperation::new(",
        "            \"test_op\".to_string(),",
        "            Duration::from_millis(10),",
        "        ));",
        "",
        "        let metrics = tester.run_benchmark(operation.clone()).await.unwrap();",
        "",
        "        assert_eq!(metrics.successful_operations, 10);",
        "        assert_eq!(metrics.failed_operations, 0);",
        "        assert!(metrics.avg_response_time >= Duration::from_millis(10));",
        "        assert!(metrics.throughput_ops_per_sec > 0.0);"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/testing/performance.rs",
      "line": 848,
      "code": "let metrics = tester.run_stress_test(operation).await.unwrap();",
      "context": [
        "        let operation = Arc::new(MockOperation::new(",
        "            \"stress_test\".to_string(),",
        "            Duration::from_millis(5),",
        "        ));",
        "",
        "        let metrics = tester.run_stress_test(operation).await.unwrap();",
        "        assert!(metrics.successful_operations > 0);",
        "    }",
        "}"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/testing/ffi.rs",
      "line": 108,
      "code": "input_data: serde_json::Number::from_f64(3.14159).map(Value::Number).unwrap(),",
      "context": [
        "        });",
        "",
        "        // Float type tests",
        "        self.add_test_case(FFITestCase {",
        "            name: \"float_positive\".to_string(),",
        "            input_data: serde_json::Number::from_f64(3.14159).map(Value::Number).unwrap(),",
        "            expected_output: serde_json::Number::from_f64(3.14159).map(Value::Number).unwrap(),",
        "            data_type: DataType::Float,",
        "            should_error: false,",
        "        });",
        ""
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/testing/ffi.rs",
      "line": 109,
      "code": "expected_output: serde_json::Number::from_f64(3.14159).map(Value::Number).unwrap(),",
      "context": [
        "",
        "        // Float type tests",
        "        self.add_test_case(FFITestCase {",
        "            name: \"float_positive\".to_string(),",
        "            input_data: serde_json::Number::from_f64(3.14159).map(Value::Number).unwrap(),",
        "            expected_output: serde_json::Number::from_f64(3.14159).map(Value::Number).unwrap(),",
        "            data_type: DataType::Float,",
        "            should_error: false,",
        "        });",
        "",
        "        self.add_test_case(FFITestCase {"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/testing/ffi.rs",
      "line": 346,
      "code": "(\"invalid_large_number\", serde_json::Number::from_f64(f64::MAX).map(Value::Number).unwrap()),",
      "context": [
        "        let mut assertions = Vec::new();",
        "",
        "        // Test with invalid inputs",
        "        let error_test_cases = vec![",
        "            (\"null_input\", Value::Null),",
        "            (\"invalid_large_number\", serde_json::Number::from_f64(f64::MAX).map(Value::Number).unwrap()),",
        "            (\"very_large_string\", Value::String(\"x\".repeat(1_000_000))),",
        "            (\"deeply_nested_object\", self.create_deeply_nested_object(100)),",
        "        ];",
        "",
        "        for (name, input) in error_test_cases {"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/testing/ffi.rs",
      "line": 720,
      "code": "assert_eq!(result.unwrap(), input);",
      "context": [
        "",
        "        let input = Value::Number(42.into());",
        "        let result = tester.simulate_ffi_call(&input, &DataType::Integer).await;",
        "",
        "        assert!(result.is_ok());",
        "        assert_eq!(result.unwrap(), input);",
        "    }",
        "}"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/testing/mod.rs",
      "line": 198,
      "code": ".max_by(|a, b| a.memory_mb.partial_cmp(&b.memory_mb).unwrap())",
      "context": [
        "        })",
        "    }",
        "",
        "    pub fn get_peak_usage(&self) -> Option<ResourceUsage> {",
        "        self.usage_history.iter()",
        "            .max_by(|a, b| a.memory_mb.partial_cmp(&b.memory_mb).unwrap())",
        "            .cloned()",
        "    }",
        "}",
        "",
        "/// Advanced assertion framework"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/network/load_balancer.rs",
      "line": 449,
      "code": "let selected1 = lb.select_backend(None).unwrap();",
      "context": [
        "",
        "        let id1 = lb.add_backend(addr1, 100);",
        "        let id2 = lb.add_backend(addr2, 100);",
        "",
        "        // Select first backend",
        "        let selected1 = lb.select_backend(None).unwrap();",
        "        assert_eq!(selected1.connections(), 1);",
        "",
        "        // Next selection should go to the other backend",
        "        let selected2 = lb.select_backend(None).unwrap();",
        "        assert_ne!(selected1.id, selected2.id);"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/network/load_balancer.rs",
      "line": 453,
      "code": "let selected2 = lb.select_backend(None).unwrap();",
      "context": [
        "        // Select first backend",
        "        let selected1 = lb.select_backend(None).unwrap();",
        "        assert_eq!(selected1.connections(), 1);",
        "",
        "        // Next selection should go to the other backend",
        "        let selected2 = lb.select_backend(None).unwrap();",
        "        assert_ne!(selected1.id, selected2.id);",
        "",
        "        // Release one connection",
        "        lb.release_connection(selected1.id, true);",
        ""
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/network/port_allocator.rs",
      "line": 314,
      "code": "let allocation = allocator.allocate_port(&service_id, Protocol::Http).await.unwrap();",
      "context": [
        "        };",
        "",
        "        let allocator = PortAllocator::with_config(config);",
        "",
        "        let service_id = Uuid::new_v4();",
        "        let allocation = allocator.allocate_port(&service_id, Protocol::Http).await.unwrap();",
        "",
        "        assert!(allocation.port >= 30000 && allocation.port <= 30010);",
        "        assert_eq!(allocation.protocol, Protocol::Http);",
        "",
        "        // Verify port is marked as allocated"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/network/port_allocator.rs",
      "line": 323,
      "code": "allocator.release_port(&service_id).await.unwrap();",
      "context": [
        "",
        "        // Verify port is marked as allocated",
        "        assert!(!allocator.is_port_available(allocation.port).await);",
        "",
        "        // Release port",
        "        allocator.release_port(&service_id).await.unwrap();",
        "        assert!(allocator.is_port_available(allocation.port).await);",
        "    }",
        "",
        "    #[tokio::test]",
        "    async fn test_port_exhaustion() {"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/network/port_allocator.rs",
      "line": 343,
      "code": "allocator.allocate_port(&service_id, Protocol::Tcp).await.unwrap();",
      "context": [
        "        // Allocate all available ports",
        "        let mut service_ids = vec![];",
        "        for i in 0..3 {",
        "            let service_id = Uuid::new_v4();",
        "            service_ids.push(service_id);",
        "            allocator.allocate_port(&service_id, Protocol::Tcp).await.unwrap();",
        "        }",
        "",
        "        // Try to allocate one more",
        "        let service_id = Uuid::new_v4();",
        "        let result = allocator.allocate_port(&service_id, Protocol::Tcp).await;"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/network/port_allocator.rs",
      "line": 352,
      "code": "allocator.release_port(&service_ids[0]).await.unwrap();",
      "context": [
        "        let service_id = Uuid::new_v4();",
        "        let result = allocator.allocate_port(&service_id, Protocol::Tcp).await;",
        "        assert!(result.is_err());",
        "",
        "        // Release one port and try again",
        "        allocator.release_port(&service_ids[0]).await.unwrap();",
        "        let result = allocator.allocate_port(&service_id, Protocol::Tcp).await;",
        "        assert!(result.is_ok());",
        "    }",
        "",
        "    #[tokio::test]"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/network/port_allocator.rs",
      "line": 368,
      "code": ").await.unwrap();",
      "context": [
        "",
        "        let allocation = allocator.allocate_specific_port(",
        "            &service_id,",
        "            port,",
        "            Protocol::Http",
        "        ).await.unwrap();",
        "",
        "        assert_eq!(allocation.port, port);",
        "",
        "        // Try to allocate same port again",
        "        let service_id2 = Uuid::new_v4();"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/network/service_mesh.rs",
      "line": 384,
      "code": "mesh.register_service(&service_id, \"test-service\".to_string()).await.unwrap();",
      "context": [
        "    #[tokio::test]",
        "    async fn test_service_registration() {",
        "        let mesh = ServiceMesh::new(MeshConfig::default());",
        "",
        "        let service_id = Uuid::new_v4();",
        "        mesh.register_service(&service_id, \"test-service\".to_string()).await.unwrap();",
        "",
        "        // Add endpoint",
        "        let endpoint = EndpointAddress {",
        "            ip: IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)),",
        "            port: 8080,"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/network/service_mesh.rs",
      "line": 394,
      "code": "mesh.add_endpoint(&service_id, endpoint).await.unwrap();",
      "context": [
        "            port: 8080,",
        "            protocol: Protocol::Http,",
        "            weight: 100,",
        "        };",
        "",
        "        mesh.add_endpoint(&service_id, endpoint).await.unwrap();",
        "",
        "        // Discover service",
        "        let endpoints = mesh.discover_service(\"test-service\").await.unwrap();",
        "        assert_eq!(endpoints.len(), 1);",
        "    }"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/network/service_mesh.rs",
      "line": 397,
      "code": "let endpoints = mesh.discover_service(\"test-service\").await.unwrap();",
      "context": [
        "        };",
        "",
        "        mesh.add_endpoint(&service_id, endpoint).await.unwrap();",
        "",
        "        // Discover service",
        "        let endpoints = mesh.discover_service(\"test-service\").await.unwrap();",
        "        assert_eq!(endpoints.len(), 1);",
        "    }",
        "",
        "    #[tokio::test]",
        "    async fn test_traffic_policy() {"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/network/service_mesh.rs",
      "line": 406,
      "code": "mesh.register_service(&service_id, \"policy-test\".to_string()).await.unwrap();",
      "context": [
        "    #[tokio::test]",
        "    async fn test_traffic_policy() {",
        "        let mesh = ServiceMesh::new(MeshConfig::default());",
        "",
        "        let service_id = Uuid::new_v4();",
        "        mesh.register_service(&service_id, \"policy-test\".to_string()).await.unwrap();",
        "",
        "        // Get default policy",
        "        let policy = mesh.get_traffic_policy(\"policy-test\").await.unwrap();",
        "        assert_eq!(policy.load_balancing, LoadBalancingPolicy::RoundRobin);",
        ""
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/network/service_mesh.rs",
      "line": 409,
      "code": "let policy = mesh.get_traffic_policy(\"policy-test\").await.unwrap();",
      "context": [
        "",
        "        let service_id = Uuid::new_v4();",
        "        mesh.register_service(&service_id, \"policy-test\".to_string()).await.unwrap();",
        "",
        "        // Get default policy",
        "        let policy = mesh.get_traffic_policy(\"policy-test\").await.unwrap();",
        "        assert_eq!(policy.load_balancing, LoadBalancingPolicy::RoundRobin);",
        "",
        "        // Update policy",
        "        let mut new_policy = policy.clone();",
        "        new_policy.load_balancing = LoadBalancingPolicy::LeastRequest;"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/network/service_mesh.rs",
      "line": 416,
      "code": "mesh.update_traffic_policy(\"policy-test\", new_policy).await.unwrap();",
      "context": [
        "",
        "        // Update policy",
        "        let mut new_policy = policy.clone();",
        "        new_policy.load_balancing = LoadBalancingPolicy::LeastRequest;",
        "",
        "        mesh.update_traffic_policy(\"policy-test\", new_policy).await.unwrap();",
        "",
        "        let updated = mesh.get_traffic_policy(\"policy-test\").await.unwrap();",
        "        assert_eq!(updated.load_balancing, LoadBalancingPolicy::LeastRequest);",
        "    }",
        "}"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/network/service_mesh.rs",
      "line": 418,
      "code": "let updated = mesh.get_traffic_policy(\"policy-test\").await.unwrap();",
      "context": [
        "        let mut new_policy = policy.clone();",
        "        new_policy.load_balancing = LoadBalancingPolicy::LeastRequest;",
        "",
        "        mesh.update_traffic_policy(\"policy-test\", new_policy).await.unwrap();",
        "",
        "        let updated = mesh.get_traffic_policy(\"policy-test\").await.unwrap();",
        "        assert_eq!(updated.load_balancing, LoadBalancingPolicy::LeastRequest);",
        "    }",
        "}"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/synthex_bash_god/learning_system.rs",
      "line": 575,
      "code": "let first = self.values.front().unwrap();",
      "context": [
        "    fn calculate_change_percent(&self) -> f64 {",
        "        if self.values.len() < 2 {",
        "            return 0.0;",
        "        }",
        "",
        "        let first = self.values.front().unwrap();",
        "        let last = self.values.back().unwrap();",
        "",
        "        if *first == 0.0 {",
        "            return 0.0;",
        "        }"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/synthex_bash_god/learning_system.rs",
      "line": 576,
      "code": "let last = self.values.back().unwrap();",
      "context": [
        "        if self.values.len() < 2 {",
        "            return 0.0;",
        "        }",
        "",
        "        let first = self.values.front().unwrap();",
        "        let last = self.values.back().unwrap();",
        "",
        "        if *first == 0.0 {",
        "            return 0.0;",
        "        }",
        ""
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/synthex_bash_god/learning_system.rs",
      "line": 715,
      "code": ").unwrap();",
      "context": [
        "    fn test_pattern_extraction() {",
        "        let system = LearningSystem::new(LearningConfig::default()).unwrap();",
        "",
        "        let patterns = futures::executor::block_on(",
        "            system.extract_patterns(\"ls -la | grep test && echo 'Done'\")",
        "        ).unwrap();",
        "",
        "        assert!(patterns.len() > 0);",
        "        assert!(patterns.iter().any(|p| p.contains(\"LIST_CMD | FILTER_CMD\")));",
        "    }",
        ""
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/synthex_bash_god/command_chain.rs",
      "line": 277,
      "code": "let first_char = self.input.chars().nth(self.position).unwrap();",
      "context": [
        "",
        "        if self.position >= self.input.len() {",
        "            return Ok(String::new());",
        "        }",
        "",
        "        let first_char = self.input.chars().nth(self.position).unwrap();",
        "",
        "        if first_char == '\\'' {",
        "            // Single quoted string",
        "            self.parse_single_quoted()",
        "        } else if first_char == '\"' {"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/synthex_bash_god/command_chain.rs",
      "line": 475,
      "code": "let ch = self.input.chars().nth(self.position).unwrap();",
      "context": [
        "",
        "    fn parse_command(&mut self, chain: &mut CommandChain) -> Result<()> {",
        "        let mut command = String::new();",
        "",
        "        while self.position < self.input.len() {",
        "            let ch = self.input.chars().nth(self.position).unwrap();",
        "",
        "            if \"|&;<>()\".contains(ch) || (ch == '2' && self.input[self.position..].starts_with(\"2>&1\")) {",
        "                break;",
        "            }",
        ""
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/synthex_bash_god/command_chain.rs",
      "line": 506,
      "code": "if !self.input.chars().nth(self.position).unwrap().is_whitespace() {",
      "context": [
        "        Ok(())",
        "    }",
        "",
        "    fn skip_whitespace(&mut self) {",
        "        while self.position < self.input.len() {",
        "            if !self.input.chars().nth(self.position).unwrap().is_whitespace() {",
        "                break;",
        "            }",
        "            self.position += 1;",
        "        }",
        "    }"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/synthex_bash_god/command_chain.rs",
      "line": 530,
      "code": "let ch = self.input.chars().nth(self.position).unwrap();",
      "context": [
        "    fn skip_double_quoted(&mut self) -> Result<()> {",
        "        self.position += 1;",
        "        let mut escaped = false;",
        "",
        "        while self.position < self.input.len() {",
        "            let ch = self.input.chars().nth(self.position).unwrap();",
        "",
        "            if escaped {",
        "                escaped = false;",
        "            } else if ch == '\\\\' {",
        "                escaped = true;"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/synthex_bash_god/execution_engine.rs",
      "line": 376,
      "code": "let engine = ExecutionEngine::new(config).unwrap();",
      "context": [
        "    use super::*;",
        "",
        "    #[tokio::test]",
        "    async fn test_simple_execution() {",
        "        let config = ExecutionConfig::default();",
        "        let engine = ExecutionEngine::new(config).unwrap();",
        "",
        "        let mut chain = CommandChain::new();",
        "        chain.add_command(\"echo 'Hello, World!'\".to_string());",
        "",
        "        let result = engine.execute(chain).await.unwrap();"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/synthex_bash_god/execution_engine.rs",
      "line": 381,
      "code": "let result = engine.execute(chain).await.unwrap();",
      "context": [
        "        let engine = ExecutionEngine::new(config).unwrap();",
        "",
        "        let mut chain = CommandChain::new();",
        "        chain.add_command(\"echo 'Hello, World!'\".to_string());",
        "",
        "        let result = engine.execute(chain).await.unwrap();",
        "        assert_eq!(result.exit_code, 0);",
        "        assert!(result.output.contains(\"Hello, World!\"));",
        "    }",
        "",
        "    #[tokio::test]"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/synthex_bash_god/execution_engine.rs",
      "line": 389,
      "code": "let engine = ExecutionEngine::new(config).unwrap();",
      "context": [
        "    }",
        "",
        "    #[tokio::test]",
        "    async fn test_parallel_execution() {",
        "        let config = ExecutionConfig::default();",
        "        let engine = ExecutionEngine::new(config).unwrap();",
        "",
        "        let chains: Vec<_> = (0..5).map(|i| {",
        "            let mut chain = CommandChain::new();",
        "            chain.add_command(format!(\"echo 'Task {}'\", i));",
        "            chain"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/synthex_bash_god/execution_engine.rs",
      "line": 397,
      "code": "let results = engine.execute_parallel(chains).await.unwrap();",
      "context": [
        "            let mut chain = CommandChain::new();",
        "            chain.add_command(format!(\"echo 'Task {}'\", i));",
        "            chain",
        "        }).collect();",
        "",
        "        let results = engine.execute_parallel(chains).await.unwrap();",
        "        assert_eq!(results.len(), 5);",
        "",
        "        for (i, result) in results.iter().enumerate() {",
        "            assert_eq!(result.exit_code, 0);",
        "            assert!(result.output.contains(&format!(\"Task {}\", i)));"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/circle_of_experts/test_module.rs",
      "line": 72,
      "code": "let matrix = consensus::compute_similarity_matrix(&responses, &config).unwrap();",
      "context": [
        "                timestamp: 1,",
        "            },",
        "        ];",
        "",
        "        let config = CircleConfig::default();",
        "        let matrix = consensus::compute_similarity_matrix(&responses, &config).unwrap();",
        "",
        "        assert_eq!(matrix.len(), 2);",
        "        assert_eq!(matrix[0].len(), 2);",
        "        assert_eq!(matrix[0][0], 1.0); // Self-similarity",
        "        assert!(matrix[0][1] > 0.0 && matrix[0][1] < 1.0); // Partial similarity"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/circle_of_experts/analyzer.rs",
      "line": 233,
      "code": "let min_time = *timestamps.iter().min().unwrap();",
      "context": [
        "    if responses.len() < 2 {",
        "        return false;",
        "    }",
        "",
        "    let timestamps: Vec<u64> = responses.iter().map(|r| r.timestamp).collect();",
        "    let min_time = *timestamps.iter().min().unwrap();",
        "    let max_time = *timestamps.iter().max().unwrap();",
        "",
        "    // Consider temporal if spread is more than 1 minute",
        "    max_time - min_time > 60",
        "}"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/circle_of_experts/analyzer.rs",
      "line": 234,
      "code": "let max_time = *timestamps.iter().max().unwrap();",
      "context": [
        "        return false;",
        "    }",
        "",
        "    let timestamps: Vec<u64> = responses.iter().map(|r| r.timestamp).collect();",
        "    let min_time = *timestamps.iter().min().unwrap();",
        "    let max_time = *timestamps.iter().max().unwrap();",
        "",
        "    // Consider temporal if spread is more than 1 minute",
        "    max_time - min_time > 60",
        "}",
        ""
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/circle_of_experts/consensus.rs",
      "line": 656,
      "code": "let clusters = find_consensus_clusters(&matrix, 0.7).unwrap();",
      "context": [
        "            vec![0.9, 1.0, 0.1, 0.2],",
        "            vec![0.2, 0.1, 1.0, 0.8],",
        "            vec![0.1, 0.2, 0.8, 1.0],",
        "        ];",
        "",
        "        let clusters = find_consensus_clusters(&matrix, 0.7).unwrap();",
        "        assert_eq!(clusters.len(), 2);",
        "        assert_eq!(clusters[0].len(), 2);",
        "        assert_eq!(clusters[1].len(), 2);",
        "    }",
        "}"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/learning_engine/optimizer.rs",
      "line": 670,
      "code": "let (src, dst) = graph.edge_endpoints(e).unwrap();",
      "context": [
        "        commands: &[String],",
        "        graph: &DiGraph<CommandNode, ()>,",
        "    ) -> DependencyGraph {",
        "        let edges: Vec<(usize, usize)> = graph.edge_indices()",
        "            .map(|e| {",
        "                let (src, dst) = graph.edge_endpoints(e).unwrap();",
        "                (graph[src].id, graph[dst].id)",
        "            })",
        "            .collect();",
        "",
        "        // Find critical path (longest path in DAG)"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/learning_engine/optimizer.rs",
      "line": 748,
      "code": "let result = optimizer.optimize_chain(&commands).unwrap();",
      "context": [
        "            \"npm install\".to_string(),",
        "            \"npm run build\".to_string(),",
        "            \"npm test\".to_string(),",
        "        ];",
        "",
        "        let result = optimizer.optimize_chain(&commands).unwrap();",
        "",
        "        assert!(result.estimated_improvement >= 0.0);",
        "        assert!(!result.optimized_chain.stages.is_empty());",
        "    }",
        ""
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/learning_engine/optimizer.rs",
      "line": 765,
      "code": "let result = optimizer.optimize_chain(&commands).unwrap();",
      "context": [
        "            \"curl -o file1.txt https://example.com/1\".to_string(),",
        "            \"curl -o file2.txt https://example.com/2\".to_string(),",
        "            \"curl -o file3.txt https://example.com/3\".to_string(),",
        "        ];",
        "",
        "        let result = optimizer.optimize_chain(&commands).unwrap();",
        "",
        "        // These commands should be parallelized",
        "        assert_eq!(result.optimized_chain.stages.len(), 1);",
        "        assert_eq!(result.optimized_chain.stages[0].commands.len(), 3);",
        "        assert!(result.optimized_chain.stages[0].can_parallelize);"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/learning_engine/pattern_detector.rs",
      "line": 270,
      "code": "if best_match.is_none() || similarity > best_match.as_ref().unwrap().1 {",
      "context": [
        "        // Find similar patterns",
        "        for (pattern_id, pattern) in patterns.iter() {",
        "            let similarity = self.calculate_similarity(sequence, &pattern.commands)?;",
        "",
        "            if similarity > self.config.similarity_threshold {",
        "                if best_match.is_none() || similarity > best_match.as_ref().unwrap().1 {",
        "                    best_match = Some((pattern_id.clone(), similarity));",
        "                }",
        "            }",
        "        }",
        ""
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/learning_engine/pattern_detector.rs",
      "line": 631,
      "code": "detector.record_pattern(pattern).unwrap();",
      "context": [
        "                task_type: \"build\".to_string(),",
        "                tags: vec![\"ci\".to_string()],",
        "            },",
        "        };",
        "",
        "        detector.record_pattern(pattern).unwrap();",
        "",
        "        let commands = vec![\"make build\".to_string(), \"make test\".to_string()];",
        "        let detected = detector.detect_patterns(&commands).unwrap();",
        "",
        "        assert!(!detected.is_empty());"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/learning_engine/pattern_detector.rs",
      "line": 650,
      "code": "let groups = detector.identify_parallel_groups(&commands).unwrap();",
      "context": [
        "            \"npm install\".to_string(),",
        "            \"pip install -r requirements.txt\".to_string(),",
        "            \"cargo build\".to_string(),",
        "        ];",
        "",
        "        let groups = detector.identify_parallel_groups(&commands).unwrap();",
        "        assert_eq!(groups.len(), 1); // All can run in parallel",
        "        assert_eq!(groups[0].len(), 3);",
        "    }",
        "}"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/learning_engine/predictor.rs",
      "line": 575,
      "code": "predictions.sort_by(|a, b| b.1.partial_cmp(&a.1).unwrap());",
      "context": [
        "                predictions.push((FailureType::PermissionDenied, base_probability * 0.8));",
        "            }",
        "        }",
        "",
        "        // Sort by probability",
        "        predictions.sort_by(|a, b| b.1.partial_cmp(&a.1).unwrap());",
        "        predictions.truncate(3); // Top 3 risks",
        "",
        "        if predictions.is_empty() {",
        "            predictions.push((FailureType::Unknown, base_probability));",
        "        }"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/learning_engine/predictor.rs",
      "line": 787,
      "code": "let result = predictor.predict_optimal_chain(&commands, &context).unwrap();",
      "context": [
        "            \"make test\".to_string(),",
        "            \"make deploy\".to_string(),",
        "        ];",
        "",
        "        let context = HashMap::new();",
        "        let result = predictor.predict_optimal_chain(&commands, &context).unwrap();",
        "",
        "        assert!(result.confidence >= 0.0 && result.confidence <= 1.0);",
        "        assert!(result.failure_risk.failure_probability >= 0.0);",
        "    }",
        ""
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/learning_engine/predictor.rs",
      "line": 804,
      "code": "let features = predictor.extract_features_vec(&commands).unwrap();",
      "context": [
        "            \"npm install\".to_string(),",
        "            \"npm run build\".to_string(),",
        "            \"npm test\".to_string(),",
        "        ];",
        "",
        "        let features = predictor.extract_features_vec(&commands).unwrap();",
        "        assert_eq!(features.len(), 128);",
        "        assert_eq!(features[0], 3.0); // Number of commands",
        "    }",
        "}"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/synthex_bashgod/execution.rs",
      "line": 441,
      "code": "working_directory: std::env::current_dir().unwrap(),",
      "context": [
        "",
        "        let context = ExecutionContext {",
        "            id: \"test-exec\".to_string(),",
        "            chain,",
        "            environment: HashMap::new(),",
        "            working_directory: std::env::current_dir().unwrap(),",
        "            constraints: crate::synthex_bashgod::core::ExecutionConstraints {",
        "                timeout: Duration::from_secs(30),",
        "                max_retries: 3,",
        "                stop_on_error: true,",
        "                resource_limits: crate::synthex_bashgod::core::ResourceLimits {"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/synthex_bashgod/execution.rs",
      "line": 458,
      "code": "let result = executor.execute(context, ExecutionConfig::default()).await.unwrap();",
      "context": [
        "                },",
        "            },",
        "            state: ExecutionState::Pending,",
        "        };",
        "",
        "        let result = executor.execute(context, ExecutionConfig::default()).await.unwrap();",
        "        assert!(result.success);",
        "        assert!(result.output.contains(\"hello\"));",
        "    }",
        "}"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/synthex_bashgod/actor.rs",
      "line": 553,
      "code": "tx.send(ActorMessage::Shutdown).await.unwrap();",
      "context": [
        "        let mcp = Arc::new(DummyMCP);",
        "",
        "        let actor = BashGodActor::new(rx, learning, mcp, 4);",
        "",
        "        // Send shutdown message",
        "        tx.send(ActorMessage::Shutdown).await.unwrap();",
        "",
        "        // Run actor (should exit immediately)",
        "        actor.run().await;",
        "    }",
        "}"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/synthex_bashgod/supervisor.rs",
      "line": 407,
      "code": "supervisor.start_actor(\"test-actor\", ActorConfig::default()).await.unwrap();",
      "context": [
        "        // Get initial stats",
        "        let stats = supervisor.get_stats().await;",
        "        assert_eq!(stats.total_actors, 1); // Default actor",
        "",
        "        // Start another actor",
        "        supervisor.start_actor(\"test-actor\", ActorConfig::default()).await.unwrap();",
        "",
        "        // Check stats",
        "        let stats = supervisor.get_stats().await;",
        "        assert_eq!(stats.total_actors, 2);",
        ""
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/synthex_bashgod/messages.rs",
      "line": 228,
      "code": ".unwrap()",
      "context": [
        "    pub fn new(sender_id: String, payload: T) -> Self {",
        "        Self {",
        "            id: uuid::Uuid::new_v4().to_string(),",
        "            timestamp: std::time::SystemTime::now()",
        "                .duration_since(std::time::UNIX_EPOCH)",
        "                .unwrap()",
        "                .as_secs(),",
        "            priority: MessagePriority::default(),",
        "            sender_id,",
        "            correlation_id: None,",
        "            payload,"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/synthex_bashgod/distributed.rs",
      "line": 267,
      "code": ".unwrap()",
      "context": [
        "        for target in gossip_targets {",
        "            let msg = DistributedMessage::HealthPing {",
        "                node_id: node_id.to_string(),",
        "                timestamp: std::time::SystemTime::now()",
        "                    .duration_since(std::time::UNIX_EPOCH)",
        "                    .unwrap()",
        "                    .as_secs(),",
        "            };",
        "",
        "            let _ = network.send_to_node(&target, &msg).await;",
        "        }"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/synthex_bashgod/python_bindings.rs",
      "line": 588,
      "code": "synthex_bashgod(py, module).unwrap();",
      "context": [
        "    fn test_python_module() {",
        "        pyo3::prepare_freethreaded_python();",
        "",
        "        Python::with_gil(|py| {",
        "            let module = PyModule::new(py, \"test_synthex_bashgod\").unwrap();",
        "            synthex_bashgod(py, module).unwrap();",
        "",
        "            assert!(module.hasattr(\"PySynthexBashGod\").unwrap());",
        "            assert!(module.hasattr(\"__version__\").unwrap());",
        "        });",
        "    }"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/synthex_bashgod/python_bindings.rs",
      "line": 590,
      "code": "assert!(module.hasattr(\"PySynthexBashGod\").unwrap());",
      "context": [
        "",
        "        Python::with_gil(|py| {",
        "            let module = PyModule::new(py, \"test_synthex_bashgod\").unwrap();",
        "            synthex_bashgod(py, module).unwrap();",
        "",
        "            assert!(module.hasattr(\"PySynthexBashGod\").unwrap());",
        "            assert!(module.hasattr(\"__version__\").unwrap());",
        "        });",
        "    }",
        "}"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/synthex_bashgod/python_bindings.rs",
      "line": 591,
      "code": "assert!(module.hasattr(\"__version__\").unwrap());",
      "context": [
        "        Python::with_gil(|py| {",
        "            let module = PyModule::new(py, \"test_synthex_bashgod\").unwrap();",
        "            synthex_bashgod(py, module).unwrap();",
        "",
        "            assert!(module.hasattr(\"PySynthexBashGod\").unwrap());",
        "            assert!(module.hasattr(\"__version__\").unwrap());",
        "        });",
        "    }",
        "}"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/synthex_bashgod/flow_control.rs",
      "line": 391,
      "code": "let permit1 = controller.acquire().await.unwrap();",
      "context": [
        "",
        "        // Should accept initial requests",
        "        assert!(controller.can_accept());",
        "",
        "        // Acquire permits",
        "        let permit1 = controller.acquire().await.unwrap();",
        "        let permit2 = controller.acquire().await.unwrap();",
        "",
        "        // Third should be rejected due to limit",
        "        let result = tokio::time::timeout(",
        "            Duration::from_millis(200),"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/synthex_bashgod/flow_control.rs",
      "line": 392,
      "code": "let permit2 = controller.acquire().await.unwrap();",
      "context": [
        "        // Should accept initial requests",
        "        assert!(controller.can_accept());",
        "",
        "        // Acquire permits",
        "        let permit1 = controller.acquire().await.unwrap();",
        "        let permit2 = controller.acquire().await.unwrap();",
        "",
        "        // Third should be rejected due to limit",
        "        let result = tokio::time::timeout(",
        "            Duration::from_millis(200),",
        "            controller.acquire()"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/synthex_bashgod/flow_control.rs",
      "line": 399,
      "code": "assert!(result.is_err() || result.unwrap().is_err());",
      "context": [
        "        // Third should be rejected due to limit",
        "        let result = tokio::time::timeout(",
        "            Duration::from_millis(200),",
        "            controller.acquire()",
        "        ).await;",
        "        assert!(result.is_err() || result.unwrap().is_err());",
        "",
        "        // Drop a permit",
        "        drop(permit1);",
        "",
        "        // Should now accept"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/synthex_bashgod/flow_control.rs",
      "line": 406,
      "code": "let _permit3 = controller.acquire().await.unwrap();",
      "context": [
        "        // Drop a permit",
        "        drop(permit1);",
        "",
        "        // Should now accept",
        "        tokio::time::sleep(Duration::from_millis(50)).await;",
        "        let _permit3 = controller.acquire().await.unwrap();",
        "",
        "        let metrics = controller.get_metrics();",
        "        assert_eq!(metrics.total_requests, 4);",
        "        assert_eq!(metrics.accepted_requests, 3);",
        "        assert_eq!(metrics.rejected_requests, 1);"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/synthex_bashgod/mod.rs",
      "line": 635,
      "code": "let serialized = serde_json::to_string(&chain).unwrap();",
      "context": [
        "                expected_resources: ResourceEstimate::default(),",
        "                priority: Priority::Normal,",
        "            },",
        "        };",
        "",
        "        let serialized = serde_json::to_string(&chain).unwrap();",
        "        let deserialized: CommandChain = serde_json::from_str(&serialized).unwrap();",
        "        assert_eq!(chain.id, deserialized.id);",
        "    }",
        "}",
        ""
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/synthex_bashgod/mod.rs",
      "line": 636,
      "code": "let deserialized: CommandChain = serde_json::from_str(&serialized).unwrap();",
      "context": [
        "                priority: Priority::Normal,",
        "            },",
        "        };",
        "",
        "        let serialized = serde_json::to_string(&chain).unwrap();",
        "        let deserialized: CommandChain = serde_json::from_str(&serialized).unwrap();",
        "        assert_eq!(chain.id, deserialized.id);",
        "    }",
        "}",
        "",
        "/// Create a new BashGod service instance"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/resources/memory_manager.rs",
      "line": 353,
      "code": "let allocation = manager.allocate(&service_id, 1024).await.unwrap();",
      "context": [
        "        };",
        "",
        "        let manager = MemoryManager::with_config(config);",
        "",
        "        let service_id = Uuid::new_v4();",
        "        let allocation = manager.allocate(&service_id, 1024).await.unwrap();",
        "",
        "        assert_eq!(allocation.memory_mb, 1024);",
        "        assert_eq!(manager.get_allocated_memory().await, 1024);",
        "",
        "        // Try to allocate more than available"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/resources/memory_manager.rs",
      "line": 364,
      "code": "manager.release(&service_id).await.unwrap();",
      "context": [
        "        let service_id2 = Uuid::new_v4();",
        "        let result = manager.allocate(&service_id2, 10000).await;",
        "        assert!(result.is_err());",
        "",
        "        // Release allocation",
        "        manager.release(&service_id).await.unwrap();",
        "        assert_eq!(manager.get_allocated_memory().await, 0);",
        "    }",
        "",
        "    #[tokio::test]",
        "    async fn test_memory_scaling() {"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/resources/memory_manager.rs",
      "line": 373,
      "code": "manager.allocate(&service_id, 512).await.unwrap();",
      "context": [
        "    #[tokio::test]",
        "    async fn test_memory_scaling() {",
        "        let manager = MemoryManager::new();",
        "",
        "        let service_id = Uuid::new_v4();",
        "        manager.allocate(&service_id, 512).await.unwrap();",
        "",
        "        // Scale up",
        "        let updated = manager.update_allocation(&service_id, 1024).await.unwrap();",
        "        assert_eq!(updated.memory_mb, 1024);",
        "        assert_eq!(manager.get_allocated_memory().await, 1024);"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/resources/memory_manager.rs",
      "line": 376,
      "code": "let updated = manager.update_allocation(&service_id, 1024).await.unwrap();",
      "context": [
        "",
        "        let service_id = Uuid::new_v4();",
        "        manager.allocate(&service_id, 512).await.unwrap();",
        "",
        "        // Scale up",
        "        let updated = manager.update_allocation(&service_id, 1024).await.unwrap();",
        "        assert_eq!(updated.memory_mb, 1024);",
        "        assert_eq!(manager.get_allocated_memory().await, 1024);",
        "",
        "        // Scale down",
        "        let updated = manager.update_allocation(&service_id, 256).await.unwrap();"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/resources/memory_manager.rs",
      "line": 381,
      "code": "let updated = manager.update_allocation(&service_id, 256).await.unwrap();",
      "context": [
        "        let updated = manager.update_allocation(&service_id, 1024).await.unwrap();",
        "        assert_eq!(updated.memory_mb, 1024);",
        "        assert_eq!(manager.get_allocated_memory().await, 1024);",
        "",
        "        // Scale down",
        "        let updated = manager.update_allocation(&service_id, 256).await.unwrap();",
        "        assert_eq!(updated.memory_mb, 256);",
        "        assert_eq!(manager.get_allocated_memory().await, 256);",
        "    }",
        "",
        "    #[tokio::test]"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/resources/memory_manager.rs",
      "line": 398,
      "code": "let allocation = manager.allocate(&service_id, 1024).await.unwrap();",
      "context": [
        "        };",
        "",
        "        let manager = MemoryManager::with_config(config);",
        "",
        "        let service_id = Uuid::new_v4();",
        "        let allocation = manager.allocate(&service_id, 1024).await.unwrap();",
        "",
        "        assert_eq!(allocation.memory_mb, 1024);",
        "        assert_eq!(allocation.swap_mb, 512);",
        "        assert_eq!(allocation.memory_limit_mb, 1536);",
        "    }"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/resources/storage_manager.rs",
      "line": 428,
      "code": "let allocation = manager.allocate(&service_id, 1024).await.unwrap();",
      "context": [
        "        };",
        "",
        "        let manager = StorageManager::with_config(config);",
        "",
        "        let service_id = Uuid::new_v4();",
        "        let allocation = manager.allocate(&service_id, 1024).await.unwrap();",
        "",
        "        assert_eq!(allocation.disk_mb, 1024);",
        "        assert_eq!(allocation.storage_class, StorageClass::Standard);",
        "        assert_eq!(manager.get_allocated_storage().await, 1024);",
        ""
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/resources/storage_manager.rs",
      "line": 435,
      "code": "manager.release(&service_id).await.unwrap();",
      "context": [
        "        assert_eq!(allocation.disk_mb, 1024);",
        "        assert_eq!(allocation.storage_class, StorageClass::Standard);",
        "        assert_eq!(manager.get_allocated_storage().await, 1024);",
        "",
        "        // Release allocation",
        "        manager.release(&service_id).await.unwrap();",
        "        assert_eq!(manager.get_allocated_storage().await, 0);",
        "    }",
        "",
        "    #[tokio::test]",
        "    async fn test_storage_resize() {"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/resources/storage_manager.rs",
      "line": 444,
      "code": "manager.allocate(&service_id, 500).await.unwrap();",
      "context": [
        "    #[tokio::test]",
        "    async fn test_storage_resize() {",
        "        let manager = StorageManager::new();",
        "",
        "        let service_id = Uuid::new_v4();",
        "        manager.allocate(&service_id, 500).await.unwrap();",
        "",
        "        // Resize up",
        "        let resized = manager.resize_allocation(&service_id, 1000).await.unwrap();",
        "        assert_eq!(resized.disk_mb, 1000);",
        "        assert_eq!(manager.get_allocated_storage().await, 1000);"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/resources/storage_manager.rs",
      "line": 447,
      "code": "let resized = manager.resize_allocation(&service_id, 1000).await.unwrap();",
      "context": [
        "",
        "        let service_id = Uuid::new_v4();",
        "        manager.allocate(&service_id, 500).await.unwrap();",
        "",
        "        // Resize up",
        "        let resized = manager.resize_allocation(&service_id, 1000).await.unwrap();",
        "        assert_eq!(resized.disk_mb, 1000);",
        "        assert_eq!(manager.get_allocated_storage().await, 1000);",
        "",
        "        // Resize down",
        "        let resized = manager.resize_allocation(&service_id, 250).await.unwrap();"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/resources/storage_manager.rs",
      "line": 452,
      "code": "let resized = manager.resize_allocation(&service_id, 250).await.unwrap();",
      "context": [
        "        let resized = manager.resize_allocation(&service_id, 1000).await.unwrap();",
        "        assert_eq!(resized.disk_mb, 1000);",
        "        assert_eq!(manager.get_allocated_storage().await, 1000);",
        "",
        "        // Resize down",
        "        let resized = manager.resize_allocation(&service_id, 250).await.unwrap();",
        "        assert_eq!(resized.disk_mb, 250);",
        "        assert_eq!(manager.get_allocated_storage().await, 250);",
        "    }",
        "",
        "    #[tokio::test]"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/resources/storage_manager.rs",
      "line": 462,
      "code": "manager.allocate(&service_id, 1024).await.unwrap();",
      "context": [
        "    #[tokio::test]",
        "    async fn test_io_limits() {",
        "        let manager = StorageManager::new();",
        "",
        "        let service_id = Uuid::new_v4();",
        "        manager.allocate(&service_id, 1024).await.unwrap();",
        "",
        "        // Set I/O limits",
        "        manager.set_io_limits(&service_id, Some(1000), Some(100)).await.unwrap();",
        "",
        "        let allocation = manager.allocations.get(&service_id).unwrap();"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/resources/storage_manager.rs",
      "line": 465,
      "code": "manager.set_io_limits(&service_id, Some(1000), Some(100)).await.unwrap();",
      "context": [
        "",
        "        let service_id = Uuid::new_v4();",
        "        manager.allocate(&service_id, 1024).await.unwrap();",
        "",
        "        // Set I/O limits",
        "        manager.set_io_limits(&service_id, Some(1000), Some(100)).await.unwrap();",
        "",
        "        let allocation = manager.allocations.get(&service_id).unwrap();",
        "        assert_eq!(allocation.iops_limit, Some(1000));",
        "        assert_eq!(allocation.bandwidth_limit_mbps, Some(100));",
        "    }"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/resources/cpu_manager.rs",
      "line": 321,
      "code": "let allocation = manager.allocate(&service_id, 2.0).await.unwrap();",
      "context": [
        "        };",
        "",
        "        let manager = CpuManager::with_config(config);",
        "",
        "        let service_id = Uuid::new_v4();",
        "        let allocation = manager.allocate(&service_id, 2.0).await.unwrap();",
        "",
        "        assert_eq!(allocation.cores, 2.0);",
        "        assert_eq!(manager.get_allocated_cores().await, 2.0);",
        "",
        "        // Try to allocate more than available"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/resources/cpu_manager.rs",
      "line": 332,
      "code": "manager.release(&service_id).await.unwrap();",
      "context": [
        "        let service_id2 = Uuid::new_v4();",
        "        let result = manager.allocate(&service_id2, 20.0).await;",
        "        assert!(result.is_err());",
        "",
        "        // Release allocation",
        "        manager.release(&service_id).await.unwrap();",
        "        assert_eq!(manager.get_allocated_cores().await, 0.0);",
        "    }",
        "",
        "    #[tokio::test]",
        "    async fn test_cpu_scaling() {"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/resources/cpu_manager.rs",
      "line": 341,
      "code": "manager.allocate(&service_id, 1.0).await.unwrap();",
      "context": [
        "    #[tokio::test]",
        "    async fn test_cpu_scaling() {",
        "        let manager = CpuManager::new();",
        "",
        "        let service_id = Uuid::new_v4();",
        "        manager.allocate(&service_id, 1.0).await.unwrap();",
        "",
        "        // Scale up",
        "        let updated = manager.update_allocation(&service_id, 2.0).await.unwrap();",
        "        assert_eq!(updated.cores, 2.0);",
        "        assert_eq!(manager.get_allocated_cores().await, 2.0);"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/resources/cpu_manager.rs",
      "line": 344,
      "code": "let updated = manager.update_allocation(&service_id, 2.0).await.unwrap();",
      "context": [
        "",
        "        let service_id = Uuid::new_v4();",
        "        manager.allocate(&service_id, 1.0).await.unwrap();",
        "",
        "        // Scale up",
        "        let updated = manager.update_allocation(&service_id, 2.0).await.unwrap();",
        "        assert_eq!(updated.cores, 2.0);",
        "        assert_eq!(manager.get_allocated_cores().await, 2.0);",
        "",
        "        // Scale down",
        "        let updated = manager.update_allocation(&service_id, 0.5).await.unwrap();"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/resources/cpu_manager.rs",
      "line": 349,
      "code": "let updated = manager.update_allocation(&service_id, 0.5).await.unwrap();",
      "context": [
        "        let updated = manager.update_allocation(&service_id, 2.0).await.unwrap();",
        "        assert_eq!(updated.cores, 2.0);",
        "        assert_eq!(manager.get_allocated_cores().await, 2.0);",
        "",
        "        // Scale down",
        "        let updated = manager.update_allocation(&service_id, 0.5).await.unwrap();",
        "        assert_eq!(updated.cores, 0.5);",
        "        assert_eq!(manager.get_allocated_cores().await, 0.5);",
        "    }",
        "}"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/resources/mod.rs",
      "line": 200,
      "code": "let allocation = manager.allocate_resources(&service_id, request).await.unwrap();",
      "context": [
        "            cpu_cores: 2.0,",
        "            memory_mb: 1024,",
        "            disk_mb: 2048,",
        "        };",
        "",
        "        let allocation = manager.allocate_resources(&service_id, request).await.unwrap();",
        "        assert_eq!(allocation.service_id, service_id);",
        "",
        "        // Verify allocation exists",
        "        let retrieved = manager.get_allocation(&service_id).await;",
        "        assert!(retrieved.is_some());"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/resources/mod.rs",
      "line": 208,
      "code": "manager.release_resources(&service_id).await.unwrap();",
      "context": [
        "        // Verify allocation exists",
        "        let retrieved = manager.get_allocation(&service_id).await;",
        "        assert!(retrieved.is_some());",
        "",
        "        // Release resources",
        "        manager.release_resources(&service_id).await.unwrap();",
        "",
        "        // Verify allocation removed",
        "        let retrieved = manager.get_allocation(&service_id).await;",
        "        assert!(retrieved.is_none());",
        "    }"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/bin/mcp_launcher_standalone.rs",
      "line": 211,
      "code": "server.auth_key.as_ref().unwrap()",
      "context": [
        "            } else if server.status == ServerStatus::MissingAuth {",
        "                stats.missing_auth += 1;",
        "                println!(",
        "                    \"\u26a0\ufe0f  {} server skipped: {} not configured\",",
        "                    server.name,",
        "                    server.auth_key.as_ref().unwrap()",
        "                );",
        "            }",
        "        }",
        "",
        "        *self.stats.write().await = stats;"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/synthex/performance_optimizer.rs",
      "line": 272,
      "code": "l1_cache: Arc::new(RwLock::new(LruCache::new(NonZeroUsize::new(l1_size).unwrap()))),",
      "context": [
        "            path: path.clone(),",
        "            index: Arc::new(DashMap::new()),",
        "        });",
        "",
        "        Ok(Self {",
        "            l1_cache: Arc::new(RwLock::new(LruCache::new(NonZeroUsize::new(l1_size).unwrap()))),",
        "            l2_cache: Arc::new(DashMap::new()),",
        "            l3_cache,",
        "            stats: Arc::new(LockFreeMetrics::new()),",
        "        })",
        "    }"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/synthex/performance_optimizer.rs",
      "line": 609,
      "code": "let cache = TieredCache::new(100, None).unwrap();",
      "context": [
        "        assert!(!matches.is_empty());",
        "    }",
        "",
        "    #[tokio::test]",
        "    async fn test_tiered_cache() {",
        "        let cache = TieredCache::new(100, None).unwrap();",
        "",
        "        cache.put(\"key1\".to_string(), Bytes::from(\"value1\"));",
        "        let result = cache.get(\"key1\");",
        "",
        "        assert!(result.is_some());"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/synthex/performance_optimizer.rs",
      "line": 615,
      "code": "assert_eq!(result.unwrap(), Bytes::from(\"value1\"));",
      "context": [
        "",
        "        cache.put(\"key1\".to_string(), Bytes::from(\"value1\"));",
        "        let result = cache.get(\"key1\");",
        "",
        "        assert!(result.is_some());",
        "        assert_eq!(result.unwrap(), Bytes::from(\"value1\"));",
        "    }",
        "}"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/synthex/service.rs",
      "line": 97,
      "code": "let service = create_synthex_service(config).await.unwrap();",
      "context": [
        "use crate::synthex::query::SubQuery;",
        "",
        "    #[tokio::test]",
        "    async fn test_service_creation() {",
        "        let config = SynthexConfig::default();",
        "        let service = create_synthex_service(config).await.unwrap();",
        "        let status = service.get_agent_status().await.unwrap();",
        "        assert!(status.is_empty());",
        "    }",
        "}"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/synthex/service.rs",
      "line": 98,
      "code": "let status = service.get_agent_status().await.unwrap();",
      "context": [
        "",
        "    #[tokio::test]",
        "    async fn test_service_creation() {",
        "        let config = SynthexConfig::default();",
        "        let service = create_synthex_service(config).await.unwrap();",
        "        let status = service.get_agent_status().await.unwrap();",
        "        assert!(status.is_empty());",
        "    }",
        "}"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/synthex/bashgod_optimizer.rs",
      "line": 140,
      "code": ".max_by(|a, b| a.score.partial_cmp(&b.score).unwrap())",
      "context": [
        "        let scored_variants = self.score_variants(variants, &context).await?;",
        "",
        "        // Select best variant",
        "        let best_command = scored_variants",
        "            .into_iter()",
        "            .max_by(|a, b| a.score.partial_cmp(&b.score).unwrap())",
        "            .ok_or_else(|| anyhow!(\"No valid command generated\"))?;",
        "",
        "        // Cache the result",
        "        self.command_predictor.cache_prediction(",
        "            request_bytes.clone(),"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/synthex/bashgod_optimizer.rs",
      "line": 483,
      "code": "matching_patterns.sort_by(|a, b| b.success_rate.partial_cmp(&a.success_rate).unwrap());",
      "context": [
        "                matching_patterns.push(pattern.clone());",
        "            }",
        "        }",
        "",
        "        // Sort by success rate",
        "        matching_patterns.sort_by(|a, b| b.success_rate.partial_cmp(&a.success_rate).unwrap());",
        "",
        "        Ok(matching_patterns)",
        "    }",
        "",
        "    fn pattern_matches(&self, request: &str, pattern: &str) -> bool {"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/synthex/engine.rs",
      "line": 351,
      "code": "let mut engine = SynthexEngine::new(config).await.unwrap();",
      "context": [
        "    use crate::synthex::agents::MockAgent;",
        "",
        "    #[tokio::test]",
        "    async fn test_engine_creation() {",
        "        let config = SynthexConfig::default();",
        "        let mut engine = SynthexEngine::new(config).await.unwrap();",
        "        assert!(engine.initialize().await.is_ok());",
        "        assert!(engine.shutdown().await.is_ok());",
        "    }",
        "",
        "    #[tokio::test]"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/synthex/engine.rs",
      "line": 359,
      "code": "let engine = SynthexEngine::new(config).await.unwrap();",
      "context": [
        "    }",
        "",
        "    #[tokio::test]",
        "    async fn test_agent_registration() {",
        "        let config = SynthexConfig::default();",
        "        let engine = SynthexEngine::new(config).await.unwrap();",
        "",
        "        let mock_agent = Arc::new(MockAgent::new());",
        "        assert!(engine.register_agent(\"test_agent\".to_string(), mock_agent).await.is_ok());",
        "",
        "        let status = engine.get_agent_status().await.unwrap();"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/synthex/engine.rs",
      "line": 364,
      "code": "let status = engine.get_agent_status().await.unwrap();",
      "context": [
        "        let engine = SynthexEngine::new(config).await.unwrap();",
        "",
        "        let mock_agent = Arc::new(MockAgent::new());",
        "        assert!(engine.register_agent(\"test_agent\".to_string(), mock_agent).await.is_ok());",
        "",
        "        let status = engine.get_agent_status().await.unwrap();",
        "        assert!(status.contains_key(\"test_agent\"));",
        "    }",
        "}"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/synthex/config.rs",
      "line": 133,
      "code": "serde_json::from_str(&serde_json::to_string(self).unwrap()).unwrap()",
      "context": [
        "        config",
        "    }",
        "",
        "    /// Convert to format suitable for Python",
        "    pub fn to_python_dict(&self) -> HashMap<String, serde_json::Value> {",
        "        serde_json::from_str(&serde_json::to_string(self).unwrap()).unwrap()",
        "    }",
        "",
        "    /// Validate configuration",
        "    pub fn validate(&self) -> Vec<String> {",
        "        let mut errors = Vec::new();"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/synthex/knowledge_graph.rs",
      "line": 193,
      "code": "related.sort_by(|a, b| a.1.partial_cmp(&b.1).unwrap());",
      "context": [
        "                graph.node_weight(idx).map(|entity| (entity.clone(), dist))",
        "            })",
        "            .collect();",
        "",
        "        // Sort by distance",
        "        related.sort_by(|a, b| a.1.partial_cmp(&b.1).unwrap());",
        "",
        "        related",
        "    }",
        "",
        "    /// Calculate entity importance using PageRank"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/synthex/knowledge_graph.rs",
      "line": 346,
      "code": "similarities.sort_by(|a, b| b.1.partial_cmp(&a.1).unwrap());",
      "context": [
        "                })",
        "            })",
        "            .collect();",
        "",
        "        // Sort by similarity (descending)",
        "        similarities.sort_by(|a, b| b.1.partial_cmp(&a.1).unwrap());",
        "        similarities.truncate(top_k);",
        "",
        "        similarities",
        "    }",
        ""
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/fusion/command_router.rs",
      "line": 680,
      "code": "let result = router.execute_bash(\"echo 'Hello, World!'\").await.unwrap();",
      "context": [
        "        let config = McpConfig::default();",
        "        let mcp_manager = Arc::new(McpManager::new(config));",
        "        let tool_registry = Arc::new(RwLock::new(ToolRegistry::new()));",
        "        let router = CommandRouter::new(mcp_manager, tool_registry);",
        "",
        "        let result = router.execute_bash(\"echo 'Hello, World!'\").await.unwrap();",
        "        assert_eq!(result.stdout.trim(), \"Hello, World!\");",
        "        assert_eq!(result.exit_code, 0);",
        "    }",
        "}"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/fusion/cross_tool.rs",
      "line": 857,
      "code": "let plan = orchestrator.build_execution_plan(&workflow).unwrap();",
      "context": [
        "            transaction_mode: TransactionMode::None,",
        "            timeout: Duration::from_secs(60),",
        "            retry_policy: RetryPolicy::default(),",
        "        };",
        "",
        "        let plan = orchestrator.build_execution_plan(&workflow).unwrap();",
        "        assert_eq!(plan.len(), 2);",
        "        assert_eq!(plan[0], vec![\"step1\".to_string()]);",
        "        assert_eq!(plan[1], vec![\"step2\".to_string()]);",
        "    }",
        "}"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/protocols/websocket.rs",
      "line": 460,
      "code": "let framed = framer.frame(&message).unwrap();",
      "context": [
        "            id: \"test\".to_string(),",
        "            method: \"test_method\".to_string(),",
        "            params: serde_json::json!({\"key\": \"value\"}),",
        "        };",
        "",
        "        let framed = framer.frame(&message).unwrap();",
        "        assert!(!framed.is_empty());",
        "",
        "        let mut data = framed;",
        "        let messages = framer.unframe(&mut data).unwrap();",
        "        assert_eq!(messages.len(), 1);"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/protocols/websocket.rs",
      "line": 464,
      "code": "let messages = framer.unframe(&mut data).unwrap();",
      "context": [
        "",
        "        let framed = framer.frame(&message).unwrap();",
        "        assert!(!framed.is_empty());",
        "",
        "        let mut data = framed;",
        "        let messages = framer.unframe(&mut data).unwrap();",
        "        assert_eq!(messages.len(), 1);",
        "    }",
        "}"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/protocols/mod.rs",
      "line": 282,
      "code": "let json = serde_json::to_string(&request).unwrap();",
      "context": [
        "            id: \"123\".to_string(),",
        "            method: \"test\".to_string(),",
        "            params: serde_json::json!({\"key\": \"value\"}),",
        "        };",
        "",
        "        let json = serde_json::to_string(&request).unwrap();",
        "        let deserialized: MessageType = serde_json::from_str(&json).unwrap();",
        "",
        "        assert_eq!(request, deserialized);",
        "    }",
        ""
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/protocols/http.rs",
      "line": 418,
      "code": "let protocol = protocol.unwrap();",
      "context": [
        "            10,",
        "            true,",
        "        );",
        "",
        "        assert!(protocol.is_ok());",
        "        let protocol = protocol.unwrap();",
        "        assert_eq!(protocol.capabilities().timeout, Duration::from_secs(30));",
        "    }",
        "}"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/server_types/infrastructure.rs",
      "line": 47,
      "code": "let obj = config.as_object().unwrap();",
      "context": [
        "        // Validate infrastructure-specific configuration",
        "        if !config.is_object() {",
        "            return Err(McpError::ConfigError(\"Config must be an object\".to_string()));",
        "        }",
        "",
        "        let obj = config.as_object().unwrap();",
        "",
        "        // Check required fields",
        "        if !obj.contains_key(\"provider\") {",
        "            return Err(McpError::ConfigError(\"Missing 'provider' field\".to_string()));",
        "        }"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/server_types/infrastructure.rs",
      "line": 195,
      "code": "let transformed = handler.transform_request(request).await.unwrap();",
      "context": [
        "        let request = serde_json::json!({",
        "            \"operation\": \"deploy\",",
        "            \"resource\": \"app-server\"",
        "        });",
        "",
        "        let transformed = handler.transform_request(request).await.unwrap();",
        "        let obj = transformed.as_object().unwrap();",
        "",
        "        assert!(obj.contains_key(\"timestamp\"));",
        "        assert!(obj.contains_key(\"request_id\"));",
        "    }"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/server_types/infrastructure.rs",
      "line": 196,
      "code": "let obj = transformed.as_object().unwrap();",
      "context": [
        "            \"operation\": \"deploy\",",
        "            \"resource\": \"app-server\"",
        "        });",
        "",
        "        let transformed = handler.transform_request(request).await.unwrap();",
        "        let obj = transformed.as_object().unwrap();",
        "",
        "        assert!(obj.contains_key(\"timestamp\"));",
        "        assert!(obj.contains_key(\"request_id\"));",
        "    }",
        ""
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/server_types/infrastructure.rs",
      "line": 211,
      "code": "let transformed = handler.transform_response(response).await.unwrap();",
      "context": [
        "        let response = serde_json::json!({",
        "            \"status\": \"running\",",
        "            \"id\": \"server-123\"",
        "        });",
        "",
        "        let transformed = handler.transform_response(response).await.unwrap();",
        "        let obj = transformed.as_object().unwrap();",
        "",
        "        assert_eq!(obj.get(\"standard_status\").unwrap().as_str().unwrap(), \"ok\");",
        "    }",
        "}"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/server_types/infrastructure.rs",
      "line": 212,
      "code": "let obj = transformed.as_object().unwrap();",
      "context": [
        "            \"status\": \"running\",",
        "            \"id\": \"server-123\"",
        "        });",
        "",
        "        let transformed = handler.transform_response(response).await.unwrap();",
        "        let obj = transformed.as_object().unwrap();",
        "",
        "        assert_eq!(obj.get(\"standard_status\").unwrap().as_str().unwrap(), \"ok\");",
        "    }",
        "}"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/server_types/monitoring.rs",
      "line": 46,
      "code": "let obj = config.as_object().unwrap();",
      "context": [
        "    async fn validate_config(&self, config: &serde_json::Value) -> Result<()> {",
        "        if !config.is_object() {",
        "            return Err(McpError::ConfigError(\"Config must be an object\".to_string()));",
        "        }",
        "",
        "        let obj = config.as_object().unwrap();",
        "",
        "        // Check for monitoring-specific fields",
        "        if !obj.contains_key(\"metrics_endpoint\") {",
        "            return Err(McpError::ConfigError(\"Missing 'metrics_endpoint' field\".to_string()));",
        "        }"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/server_types/monitoring.rs",
      "line": 259,
      "code": "let transformed = handler.transform_response(response).await.unwrap();",
      "context": [
        "                    \"unit\": \"percent\"",
        "                }",
        "            }",
        "        });",
        "",
        "        let transformed = handler.transform_response(response).await.unwrap();",
        "        let obj = transformed.as_object().unwrap();",
        "",
        "        assert!(obj.contains_key(\"standardized_metrics\"));",
        "        let std_metrics = obj.get(\"standardized_metrics\").unwrap().as_object().unwrap();",
        ""
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/server_types/monitoring.rs",
      "line": 260,
      "code": "let obj = transformed.as_object().unwrap();",
      "context": [
        "                }",
        "            }",
        "        });",
        "",
        "        let transformed = handler.transform_response(response).await.unwrap();",
        "        let obj = transformed.as_object().unwrap();",
        "",
        "        assert!(obj.contains_key(\"standardized_metrics\"));",
        "        let std_metrics = obj.get(\"standardized_metrics\").unwrap().as_object().unwrap();",
        "",
        "        assert!(std_metrics.get(\"cpu\").unwrap().get(\"value\").unwrap().as_f64().unwrap() == 45.5);"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/server_types/security.rs",
      "line": 77,
      "code": "let obj = config.as_object().unwrap();",
      "context": [
        "    async fn validate_config(&self, config: &serde_json::Value) -> Result<()> {",
        "        if !config.is_object() {",
        "            return Err(McpError::ConfigError(\"Config must be an object\".to_string()));",
        "        }",
        "",
        "        let obj = config.as_object().unwrap();",
        "",
        "        // Check for security-specific fields",
        "        if !obj.contains_key(\"scan_endpoint\") {",
        "            return Err(McpError::ConfigError(\"Missing 'scan_endpoint' field\".to_string()));",
        "        }"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/plugin/registry.rs",
      "line": 526,
      "code": "let id = registry.register(Box::new(plugin)).await.unwrap();",
      "context": [
        "                provides: vec![Capability::new(\"test\", \"feature\", 1)],",
        "                requires: vec![],",
        "            },",
        "        };",
        "",
        "        let id = registry.register(Box::new(plugin)).await.unwrap();",
        "        assert_eq!(id, \"test\");",
        "",
        "        assert!(registry.get(\"test\").is_some());",
        "",
        "        let providers = registry.find_by_capability(&Capability::new(\"test\", \"feature\", 1)).await;"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/plugin/version.rs",
      "line": 824,
      "code": "let version = Version::parse(version_str).unwrap();",
      "context": [
        "",
        "        // Register some versions",
        "        let plugin_id = \"test-plugin\".to_string();",
        "",
        "        for version_str in [\"1.0.0\", \"1.1.0\", \"1.2.0\", \"2.0.0-beta.1\", \"2.0.0\"] {",
        "            let version = Version::parse(version_str).unwrap();",
        "            let info = VersionInfo {",
        "                version: version.clone(),",
        "                released_at: Utc::now(),",
        "                metadata: VersionMetadata {",
        "                    description: format!(\"Version {}\", version),"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/plugin/version.rs",
      "line": 847,
      "code": "manager.register_version(plugin_id.clone(), info).await.unwrap();",
      "context": [
        "                dependencies: vec![],",
        "                breaking_changes: vec![],",
        "                migration: None,",
        "            };",
        "",
        "            manager.register_version(plugin_id.clone(), info).await.unwrap();",
        "        }",
        "",
        "        // Test resolution",
        "        let req = VersionReq::parse(\"^1.0.0\").unwrap();",
        "        let resolved = manager.resolve_version(&plugin_id, &req).await.unwrap();"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/plugin/version.rs",
      "line": 851,
      "code": "let req = VersionReq::parse(\"^1.0.0\").unwrap();",
      "context": [
        "",
        "            manager.register_version(plugin_id.clone(), info).await.unwrap();",
        "        }",
        "",
        "        // Test resolution",
        "        let req = VersionReq::parse(\"^1.0.0\").unwrap();",
        "        let resolved = manager.resolve_version(&plugin_id, &req).await.unwrap();",
        "        assert_eq!(resolved, Version::parse(\"1.2.0\").unwrap());",
        "",
        "        // Test with pre-release",
        "        let req = VersionReq::parse(\"^2.0.0\").unwrap();"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/plugin/version.rs",
      "line": 852,
      "code": "let resolved = manager.resolve_version(&plugin_id, &req).await.unwrap();",
      "context": [
        "            manager.register_version(plugin_id.clone(), info).await.unwrap();",
        "        }",
        "",
        "        // Test resolution",
        "        let req = VersionReq::parse(\"^1.0.0\").unwrap();",
        "        let resolved = manager.resolve_version(&plugin_id, &req).await.unwrap();",
        "        assert_eq!(resolved, Version::parse(\"1.2.0\").unwrap());",
        "",
        "        // Test with pre-release",
        "        let req = VersionReq::parse(\"^2.0.0\").unwrap();",
        "        let resolved = manager.resolve_version(&plugin_id, &req).await.unwrap();"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/plugin/version.rs",
      "line": 853,
      "code": "assert_eq!(resolved, Version::parse(\"1.2.0\").unwrap());",
      "context": [
        "        }",
        "",
        "        // Test resolution",
        "        let req = VersionReq::parse(\"^1.0.0\").unwrap();",
        "        let resolved = manager.resolve_version(&plugin_id, &req).await.unwrap();",
        "        assert_eq!(resolved, Version::parse(\"1.2.0\").unwrap());",
        "",
        "        // Test with pre-release",
        "        let req = VersionReq::parse(\"^2.0.0\").unwrap();",
        "        let resolved = manager.resolve_version(&plugin_id, &req).await.unwrap();",
        "        assert_eq!(resolved, Version::parse(\"2.0.0\").unwrap());"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/plugin/version.rs",
      "line": 856,
      "code": "let req = VersionReq::parse(\"^2.0.0\").unwrap();",
      "context": [
        "        let req = VersionReq::parse(\"^1.0.0\").unwrap();",
        "        let resolved = manager.resolve_version(&plugin_id, &req).await.unwrap();",
        "        assert_eq!(resolved, Version::parse(\"1.2.0\").unwrap());",
        "",
        "        // Test with pre-release",
        "        let req = VersionReq::parse(\"^2.0.0\").unwrap();",
        "        let resolved = manager.resolve_version(&plugin_id, &req).await.unwrap();",
        "        assert_eq!(resolved, Version::parse(\"2.0.0\").unwrap());",
        "    }",
        "}"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/plugin/version.rs",
      "line": 857,
      "code": "let resolved = manager.resolve_version(&plugin_id, &req).await.unwrap();",
      "context": [
        "        let resolved = manager.resolve_version(&plugin_id, &req).await.unwrap();",
        "        assert_eq!(resolved, Version::parse(\"1.2.0\").unwrap());",
        "",
        "        // Test with pre-release",
        "        let req = VersionReq::parse(\"^2.0.0\").unwrap();",
        "        let resolved = manager.resolve_version(&plugin_id, &req).await.unwrap();",
        "        assert_eq!(resolved, Version::parse(\"2.0.0\").unwrap());",
        "    }",
        "}"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/plugin/version.rs",
      "line": 858,
      "code": "assert_eq!(resolved, Version::parse(\"2.0.0\").unwrap());",
      "context": [
        "        assert_eq!(resolved, Version::parse(\"1.2.0\").unwrap());",
        "",
        "        // Test with pre-release",
        "        let req = VersionReq::parse(\"^2.0.0\").unwrap();",
        "        let resolved = manager.resolve_version(&plugin_id, &req).await.unwrap();",
        "        assert_eq!(resolved, Version::parse(\"2.0.0\").unwrap());",
        "    }",
        "}"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/plugin/negotiation.rs",
      "line": 773,
      "code": "proposals.sort_by(|a, b| b.score.partial_cmp(&a.score).unwrap());",
      "context": [
        "                },",
        "            });",
        "        }",
        "",
        "        // Sort by score",
        "        proposals.sort_by(|a, b| b.score.partial_cmp(&a.score).unwrap());",
        "",
        "        Ok(proposals)",
        "    }",
        "",
        "    /// Determine optimal communication protocol"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/plugin/negotiation.rs",
      "line": 994,
      "code": "negotiator.register_plugin(&provider_metadata).await.unwrap();",
      "context": [
        "                Capability::new(\"test\", \"operation.query\", 1),",
        "            ],",
        "            requires: vec![],",
        "        };",
        "",
        "        negotiator.register_plugin(&provider_metadata).await.unwrap();",
        "",
        "        // Start negotiation",
        "        let required = vec![",
        "            Capability::new(\"test\", \"operation.execute\", 1),",
        "        ];"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/plugin/negotiation.rs",
      "line": 1001,
      "code": "let session_id = negotiator.start_negotiation(\"test-consumer\", required).await.unwrap();",
      "context": [
        "        // Start negotiation",
        "        let required = vec![",
        "            Capability::new(\"test\", \"operation.execute\", 1),",
        "        ];",
        "",
        "        let session_id = negotiator.start_negotiation(\"test-consumer\", required).await.unwrap();",
        "",
        "        // Wait a bit for negotiation",
        "        tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;",
        "",
        "        // Check status"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/plugin/negotiation.rs",
      "line": 1007,
      "code": "let status = negotiator.check_negotiation_status(&session_id).await.unwrap();",
      "context": [
        "",
        "        // Wait a bit for negotiation",
        "        tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;",
        "",
        "        // Check status",
        "        let status = negotiator.check_negotiation_status(&session_id).await.unwrap();",
        "        assert!(matches!(status, NegotiationState::Completed | NegotiationState::Failed));",
        "    }",
        "}"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/plugin/schema.rs",
      "line": 390,
      "code": "serde_json::from_value(schema).unwrap(),",
      "context": [
        "",
        "        // Add to schema",
        "        if let Some(properties) = self.schema.schema.object.as_mut() {",
        "            properties.properties.insert(",
        "                name_str.clone(),",
        "                serde_json::from_value(schema).unwrap(),",
        "            );",
        "        }",
        "",
        "        // Add default if provided",
        "        if let Some(default_value) = default {"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/plugin/schema.rs",
      "line": 581,
      "code": "registry.register(schema).unwrap();",
      "context": [
        "                },",
        "                error_message: \"Port must be between 1 and 65535\".to_string(),",
        "            })",
        "            .build();",
        "",
        "        registry.register(schema).unwrap();",
        "",
        "        // Valid config",
        "        let valid_config = json!({",
        "            \"port\": 8080",
        "        });"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/plugin/hot_reload.rs",
      "line": 868,
      "code": "manager.start().await.unwrap();",
      "context": [
        "    async fn test_hot_reload_manager() {",
        "        let loader = Arc::new(PluginLoader::new());",
        "        let config = HotReloadConfig::default();",
        "        let mut manager = HotReloadManager::new(loader, config);",
        "",
        "        manager.start().await.unwrap();",
        "",
        "        // Test operations would go here",
        "    }",
        "}"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/plugin/rollback.rs",
      "line": 783,
      "code": "let session = sessions.get_mut(&session_id).unwrap();",
      "context": [
        "        }",
        "",
        "        // Update state",
        "        {",
        "            let mut sessions = self.active_rollbacks.lock().await;",
        "            let session = sessions.get_mut(&session_id).unwrap();",
        "            session.state = RollbackState::Preparing;",
        "        }",
        "",
        "        // Prepare rollback",
        "        match strategy.prepare_rollback(&source.handle, &target).await {"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/plugin/rollback.rs",
      "line": 802,
      "code": "let session = sessions.get_mut(&session_id).unwrap();",
      "context": [
        "        }",
        "",
        "        // Update state",
        "        {",
        "            let mut sessions = self.active_rollbacks.lock().await;",
        "            let session = sessions.get_mut(&session_id).unwrap();",
        "            session.state = RollbackState::Executing;",
        "        }",
        "",
        "        // Perform state transfer",
        "        let downtime_start = std::time::Instant::now();"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/plugin/rollback.rs",
      "line": 833,
      "code": "let session = sessions.get_mut(&session_id).unwrap();",
      "context": [
        "        result.downtime = Some(downtime_start.elapsed());",
        "",
        "        // Update state",
        "        {",
        "            let mut sessions = self.active_rollbacks.lock().await;",
        "            let session = sessions.get_mut(&session_id).unwrap();",
        "            session.state = RollbackState::Finalizing;",
        "        }",
        "",
        "        // Finalize",
        "        result.success = result.errors.is_empty();"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/plugin/capabilities.rs",
      "line": 601,
      "code": "manager.register_capability(def.clone()).await.unwrap();",
      "context": [
        "            version: Version::new(1, 0, 0),",
        "            deprecated: None,",
        "            features: HashSet::new(),",
        "        };",
        "",
        "        manager.register_capability(def.clone()).await.unwrap();",
        "",
        "        // Should fail on duplicate without overrides",
        "        assert!(manager.register_capability(def).await.is_err());",
        "    }",
        ""
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/plugin/capabilities.rs",
      "line": 616,
      "code": ").await.unwrap();",
      "context": [
        "        let capability = Capability::new(\"docker\", \"container.create\", 1);",
        "",
        "        manager.register_provider(",
        "            \"docker-plugin\".to_string(),",
        "            vec![capability.clone()],",
        "        ).await.unwrap();",
        "",
        "        let provider = manager.find_provider(&capability).await.unwrap();",
        "        assert_eq!(provider, Some(\"docker-plugin\".to_string()));",
        "    }",
        "}"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/plugin/capabilities.rs",
      "line": 618,
      "code": "let provider = manager.find_provider(&capability).await.unwrap();",
      "context": [
        "        manager.register_provider(",
        "            \"docker-plugin\".to_string(),",
        "            vec![capability.clone()],",
        "        ).await.unwrap();",
        "",
        "        let provider = manager.find_provider(&capability).await.unwrap();",
        "        assert_eq!(provider, Some(\"docker-plugin\".to_string()));",
        "    }",
        "}"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/plugin/mod.rs",
      "line": 402,
      "code": ".unwrap()",
      "context": [
        "",
        "        let mut metrics = self.metrics.lock().await;",
        "        use std::time::{SystemTime, UNIX_EPOCH};",
        "        let timestamp = SystemTime::now()",
        "            .duration_since(UNIX_EPOCH)",
        "            .unwrap()",
        "            .as_secs() as i64;",
        "        metrics.last_health_check = Some((timestamp, result.is_ok()));",
        "",
        "        result",
        "    }"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/plugin/zero_downtime.rs",
      "line": 1153,
      "code": ".unwrap()",
      "context": [
        "                active_instances[0]",
        "            }",
        "            RoutingStrategy::LeastConnections => {",
        "                active_instances.iter()",
        "                    .min_by_key(|i| i.metrics.active_connections.load(Ordering::Relaxed))",
        "                    .unwrap()",
        "            }",
        "            RoutingStrategy::LeastResponseTime => {",
        "                active_instances.iter()",
        "                    .min_by_key(|i| i.metrics.last_response_time_us.load(Ordering::Relaxed))",
        "                    .unwrap()"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/plugin/zero_downtime.rs",
      "line": 1158,
      "code": ".unwrap()",
      "context": [
        "                    .unwrap()",
        "            }",
        "            RoutingStrategy::LeastResponseTime => {",
        "                active_instances.iter()",
        "                    .min_by_key(|i| i.metrics.last_response_time_us.load(Ordering::Relaxed))",
        "                    .unwrap()",
        "            }",
        "            _ => active_instances[0],",
        "        };",
        "",
        "        Ok(selected.clone())"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/plugin/state_transfer.rs",
      "line": 713,
      "code": "let json = serde_json::to_string(&snapshot).unwrap();",
      "context": [
        "            },",
        "            checksum: \"abc123\".to_string(),",
        "        };",
        "",
        "        // Serialize",
        "        let json = serde_json::to_string(&snapshot).unwrap();",
        "",
        "        // Deserialize",
        "        let restored: StateSnapshot = serde_json::from_str(&json).unwrap();",
        "",
        "        assert_eq!(restored.id, snapshot.id);"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/plugin/state_transfer.rs",
      "line": 716,
      "code": "let restored: StateSnapshot = serde_json::from_str(&json).unwrap();",
      "context": [
        "",
        "        // Serialize",
        "        let json = serde_json::to_string(&snapshot).unwrap();",
        "",
        "        // Deserialize",
        "        let restored: StateSnapshot = serde_json::from_str(&json).unwrap();",
        "",
        "        assert_eq!(restored.id, snapshot.id);",
        "        assert_eq!(restored.plugin_id, snapshot.plugin_id);",
        "    }",
        "}"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/optimization/cache.rs",
      "line": 247,
      "code": "let frequency_map = self.frequency_map.read().unwrap();",
      "context": [
        "        Ok(queue.pop_front())",
        "    }",
        "",
        "    /// Evict using LFU policy",
        "    async fn evict_lfu(&self) -> Result<Option<K>> {",
        "        let frequency_map = self.frequency_map.read().unwrap();",
        "",
        "        frequency_map.iter()",
        "            .min_by_key(|(_, &freq)| freq)",
        "            .map(|(k, _)| k.clone())",
        "            .ok_or_else(|| anyhow!(\"No entries to evict\"))"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/optimization/cache.rs",
      "line": 264,
      "code": "let storage = self.storage.read().unwrap();",
      "context": [
        "        Ok(queue.pop_front())",
        "    }",
        "",
        "    /// Evict random entry",
        "    async fn evict_random(&self) -> Result<Option<K>> {",
        "        let storage = self.storage.read().unwrap();",
        "        let keys: Vec<_> = storage.keys().cloned().collect();",
        "",
        "        if keys.is_empty() {",
        "            return Ok(None);",
        "        }"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/optimization/cache.rs",
      "line": 278,
      "code": "let storage = self.storage.read().unwrap();",
      "context": [
        "        Ok(Some(keys[idx].clone()))",
        "    }",
        "",
        "    /// Evict oldest entry",
        "    async fn evict_oldest(&self) -> Result<Option<K>> {",
        "        let storage = self.storage.read().unwrap();",
        "",
        "        storage.iter()",
        "            .min_by_key(|(_, entry)| entry.created_at)",
        "            .map(|(k, _)| k.clone())",
        "            .ok_or_else(|| anyhow!(\"No entries to evict\"))"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/optimization/cache.rs",
      "line": 486,
      "code": "cache.put(\"a\".to_string(), 1, 10).await.unwrap();",
      "context": [
        "    #[tokio::test]",
        "    async fn test_lru_cache() {",
        "        let cache = AdvancedCache::new(100, 3, EvictionPolicy::LRU, None);",
        "",
        "        // Add entries",
        "        cache.put(\"a\".to_string(), 1, 10).await.unwrap();",
        "        cache.put(\"b\".to_string(), 2, 10).await.unwrap();",
        "        cache.put(\"c\".to_string(), 3, 10).await.unwrap();",
        "",
        "        // Access 'a' to make it recently used",
        "        assert_eq!(cache.get(&\"a\".to_string()).await, Some(1));"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/optimization/cache.rs",
      "line": 487,
      "code": "cache.put(\"b\".to_string(), 2, 10).await.unwrap();",
      "context": [
        "    async fn test_lru_cache() {",
        "        let cache = AdvancedCache::new(100, 3, EvictionPolicy::LRU, None);",
        "",
        "        // Add entries",
        "        cache.put(\"a\".to_string(), 1, 10).await.unwrap();",
        "        cache.put(\"b\".to_string(), 2, 10).await.unwrap();",
        "        cache.put(\"c\".to_string(), 3, 10).await.unwrap();",
        "",
        "        // Access 'a' to make it recently used",
        "        assert_eq!(cache.get(&\"a\".to_string()).await, Some(1));",
        ""
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/optimization/cache.rs",
      "line": 488,
      "code": "cache.put(\"c\".to_string(), 3, 10).await.unwrap();",
      "context": [
        "        let cache = AdvancedCache::new(100, 3, EvictionPolicy::LRU, None);",
        "",
        "        // Add entries",
        "        cache.put(\"a\".to_string(), 1, 10).await.unwrap();",
        "        cache.put(\"b\".to_string(), 2, 10).await.unwrap();",
        "        cache.put(\"c\".to_string(), 3, 10).await.unwrap();",
        "",
        "        // Access 'a' to make it recently used",
        "        assert_eq!(cache.get(&\"a\".to_string()).await, Some(1));",
        "",
        "        // Add 'd' which should evict 'b' (least recently used)"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/optimization/cache.rs",
      "line": 494,
      "code": "cache.put(\"d\".to_string(), 4, 10).await.unwrap();",
      "context": [
        "",
        "        // Access 'a' to make it recently used",
        "        assert_eq!(cache.get(&\"a\".to_string()).await, Some(1));",
        "",
        "        // Add 'd' which should evict 'b' (least recently used)",
        "        cache.put(\"d\".to_string(), 4, 10).await.unwrap();",
        "",
        "        assert_eq!(cache.get(&\"a\".to_string()).await, Some(1));",
        "        assert_eq!(cache.get(&\"b\".to_string()).await, None); // Evicted",
        "        assert_eq!(cache.get(&\"c\".to_string()).await, Some(3));",
        "        assert_eq!(cache.get(&\"d\".to_string()).await, Some(4));"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/optimization/cache.rs",
      "line": 512,
      "code": ").await.unwrap();",
      "context": [
        "        cache.put_with_ttl(",
        "            \"temp\".to_string(),",
        "            42,",
        "            10,",
        "            Some(Duration::from_millis(100))",
        "        ).await.unwrap();",
        "",
        "        // Should exist immediately",
        "        assert_eq!(cache.get(&\"temp\".to_string()).await, Some(42));",
        "",
        "        // Wait for expiration"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/optimization/cache.rs",
      "line": 531,
      "code": "cache.put(\"hit\".to_string(), 1, 10).await.unwrap();",
      "context": [
        "",
        "    #[tokio::test]",
        "    async fn test_cache_stats() {",
        "        let cache = AdvancedCache::new(100, 10, EvictionPolicy::LRU, None);",
        "",
        "        cache.put(\"hit\".to_string(), 1, 10).await.unwrap();",
        "",
        "        // Generate hits",
        "        cache.get(&\"hit\".to_string()).await;",
        "        cache.get(&\"hit\".to_string()).await;",
        ""
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/optimization/cache.rs",
      "line": 560,
      "code": "multi_cache.put(\"key\".to_string(), \"value\", 10).await.unwrap();",
      "context": [
        "",
        "        // L2: Larger, slower cache",
        "        multi_cache.add_tier(200, 20, EvictionPolicy::LFU, Some(Duration::from_secs(300)));",
        "",
        "        // Put in L1",
        "        multi_cache.put(\"key\".to_string(), \"value\", 10).await.unwrap();",
        "",
        "        // Get should find in L1",
        "        assert_eq!(multi_cache.get(&\"key\".to_string()).await, Some(\"value\"));",
        "",
        "        let stats = multi_cache.get_stats();"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/optimization/prefetch.rs",
      "line": 187,
      "code": "let sequential_state = self.sequential_state.read().unwrap();",
      "context": [
        "        }",
        "    }",
        "",
        "    /// Sequential prediction",
        "    async fn predict_sequential(&self, pattern: &AccessPattern) -> Result<PrefetchRequest> {",
        "        let sequential_state = self.sequential_state.read().unwrap();",
        "",
        "        if let Some(sequence) = sequential_state.get(&pattern.key) {",
        "            let keys = sequence.iter()",
        "                .take(self.max_prefetch_size)",
        "                .cloned()"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/optimization/prefetch.rs",
      "line": 208,
      "code": "let temporal_patterns = self.temporal_patterns.read().unwrap();",
      "context": [
        "        }",
        "    }",
        "",
        "    /// Temporal prediction",
        "    async fn predict_temporal(&self, pattern: &AccessPattern) -> Result<PrefetchRequest> {",
        "        let temporal_patterns = self.temporal_patterns.read().unwrap();",
        "",
        "        // Find keys accessed around the same time",
        "        let mut temporal_keys = Vec::new();",
        "",
        "        for (key, intervals) in temporal_patterns.iter() {"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/optimization/prefetch.rs",
      "line": 242,
      "code": "let spatial_map = self.spatial_map.read().unwrap();",
      "context": [
        "        })",
        "    }",
        "",
        "    /// Spatial prediction",
        "    async fn predict_spatial(&self, pattern: &AccessPattern) -> Result<PrefetchRequest> {",
        "        let spatial_map = self.spatial_map.read().unwrap();",
        "",
        "        if let Some(neighbors) = spatial_map.get(&pattern.key) {",
        "            let keys = neighbors.iter()",
        "                .take(self.max_prefetch_size)",
        "                .cloned()"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/optimization/prefetch.rs",
      "line": 263,
      "code": "let model = self.markov_model.read().unwrap();",
      "context": [
        "        }",
        "    }",
        "",
        "    /// Markov chain prediction",
        "    async fn predict_markov(&self, pattern: &AccessPattern) -> Result<PrefetchRequest> {",
        "        let model = self.markov_model.read().unwrap();",
        "",
        "        if let Some(transitions) = model.transitions.get(&pattern.key) {",
        "            // Get top predictions by probability",
        "            let mut predictions: Vec<_> = transitions.iter().collect();",
        "            predictions.sort_by(|a, b| b.1.partial_cmp(a.1).unwrap());"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/optimization/prefetch.rs",
      "line": 268,
      "code": "predictions.sort_by(|a, b| b.1.partial_cmp(a.1).unwrap());",
      "context": [
        "        let model = self.markov_model.read().unwrap();",
        "",
        "        if let Some(transitions) = model.transitions.get(&pattern.key) {",
        "            // Get top predictions by probability",
        "            let mut predictions: Vec<_> = transitions.iter().collect();",
        "            predictions.sort_by(|a, b| b.1.partial_cmp(a.1).unwrap());",
        "",
        "            let keys: Vec<String> = predictions.iter()",
        "                .take(self.max_prefetch_size)",
        "                .filter(|(_, &prob)| prob > 0.5)",
        "                .map(|(key, _)| (*key).clone())"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/optimization/prefetch.rs",
      "line": 298,
      "code": "let model = self.neural_model.read().unwrap();",
      "context": [
        "        }",
        "    }",
        "",
        "    /// Neural network prediction",
        "    async fn predict_neural(&self, pattern: &AccessPattern) -> Result<PrefetchRequest> {",
        "        let model = self.neural_model.read().unwrap();",
        "",
        "        // Simplified neural prediction",
        "        // In real implementation, this would use proper feature extraction",
        "        let features = self.extract_features(pattern);",
        "        let predictions = self.neural_forward(&model, &features);"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/optimization/prefetch.rs",
      "line": 308,
      "code": "indexed_predictions.sort_by(|a, b| b.1.partial_cmp(a.1).unwrap());",
      "context": [
        "        let predictions = self.neural_forward(&model, &features);",
        "",
        "        let mut indexed_predictions: Vec<_> = predictions.iter()",
        "            .enumerate()",
        "            .collect();",
        "        indexed_predictions.sort_by(|a, b| b.1.partial_cmp(a.1).unwrap());",
        "",
        "        let keys: Vec<String> = indexed_predictions.iter()",
        "            .take(self.max_prefetch_size)",
        "            .filter(|(_, &score)| score > 0.7)",
        "            .map(|(idx, _)| format!(\"predicted_key_{}\", idx))"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/optimization/prefetch.rs",
      "line": 367,
      "code": "sorted_predictions.sort_by(|a, b| b.1.partial_cmp(&a.1).unwrap());",
      "context": [
        "            return Err(anyhow!(\"No predictions from any strategy\"));",
        "        }",
        "",
        "        // Sort by combined confidence",
        "        let mut sorted_predictions: Vec<_> = all_predictions.into_iter().collect();",
        "        sorted_predictions.sort_by(|a, b| b.1.partial_cmp(&a.1).unwrap());",
        "",
        "        let keys: Vec<String> = sorted_predictions.iter()",
        "            .take(self.max_prefetch_size)",
        "            .map(|(key, _)| key.clone())",
        "            .collect();"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/resilience/chaos.rs",
      "line": 184,
      "code": "if *self.safety_enabled.read().unwrap() {",
      "context": [
        "    pub async fn schedule_experiment(&self, config: ExperimentConfig) -> Result<String> {",
        "        // Validate experiment",
        "        self.validate_experiment(&config)?;",
        "",
        "        // Check safety",
        "        if *self.safety_enabled.read().unwrap() {",
        "            self.check_safety(&config)?;",
        "        }",
        "",
        "        // Generate experiment ID",
        "        let id = self.generate_experiment_id();"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/resilience/chaos.rs",
      "line": 492,
      "code": "let experiments = self.experiments.read().unwrap();",
      "context": [
        "        Ok(())",
        "    }",
        "",
        "    /// Check safety constraints",
        "    fn check_safety(&self, config: &ExperimentConfig) -> Result<()> {",
        "        let experiments = self.experiments.read().unwrap();",
        "",
        "        // Check for concurrent experiments on same target",
        "        let concurrent = experiments.values()",
        "            .filter(|e| e.status == ExperimentStatus::Running)",
        "            .count();"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/resilience/chaos.rs",
      "line": 603,
      "code": "let id = chaos.schedule_experiment(config).await.unwrap();",
      "context": [
        "            intensity: 0.5,",
        "            probability: 1.0,",
        "            params: HashMap::new(),",
        "        };",
        "",
        "        let id = chaos.schedule_experiment(config).await.unwrap();",
        "        assert!(!id.is_empty());",
        "",
        "        // Wait for experiment to start",
        "        tokio::time::sleep(Duration::from_millis(100)).await;",
        ""
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/distributed/failover.rs",
      "line": 248,
      "code": "healthy_backups.choose(&mut rand::thread_rng()).unwrap()",
      "context": [
        "                healthy_backups[0]",
        "            }",
        "            FailoverStrategy::ActiveActive => {",
        "                // Random selection for load distribution",
        "                use rand::seq::SliceRandom;",
        "                healthy_backups.choose(&mut rand::thread_rng()).unwrap()",
        "            }",
        "            FailoverStrategy::PriorityBased => {",
        "                // Highest priority backup",
        "                healthy_backups.iter()",
        "                    .max_by_key(|s| s.priority())"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/distributed/failover.rs",
      "line": 254,
      "code": ".unwrap()",
      "context": [
        "            }",
        "            FailoverStrategy::PriorityBased => {",
        "                // Highest priority backup",
        "                healthy_backups.iter()",
        "                    .max_by_key(|s| s.priority())",
        "                    .unwrap()",
        "            }",
        "            FailoverStrategy::Geographic => {",
        "                // In production: select based on geographic proximity",
        "                // For now, just use first",
        "                healthy_backups[0]"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/distributed/failover.rs",
      "line": 364,
      "code": "Arc::new(McpServer::new(id.to_string(), config).unwrap())",
      "context": [
        "            max_retries: 3,",
        "            priority,",
        "            tags: vec![],",
        "        };",
        "",
        "        Arc::new(McpServer::new(id.to_string(), config).unwrap())",
        "    }",
        "",
        "    #[tokio::test]",
        "    async fn test_failover_manager() {",
        "        let manager = FailoverManager::new(FailoverStrategy::ActivePassive);"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/distributed/failover.rs",
      "line": 379,
      "code": "let backup_id = manager.handle_failure(\"primary-1\").await.unwrap();",
      "context": [
        "",
        "        manager.register_primary(\"group-1\".to_string(), primary).await;",
        "        manager.register_backup(\"group-1\".to_string(), backup).await;",
        "",
        "        // Test failover",
        "        let backup_id = manager.handle_failure(\"primary-1\").await.unwrap();",
        "        assert_eq!(backup_id, \"backup-1\");",
        "",
        "        // Check active failovers",
        "        assert!(manager.is_failed_over(\"primary-1\").await);",
        "    }"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/distributed/failover.rs",
      "line": 398,
      "code": "let backup_id = manager.handle_failure(\"primary-1\").await.unwrap();",
      "context": [
        "        manager.register_backup(\"group-1\".to_string(), create_test_server(\"backup-3\", 7)).await;",
        "",
        "        manager.register_primary(\"group-1\".to_string(), create_test_server(\"primary-1\", 15)).await;",
        "",
        "        // Should select backup-2 (highest priority)",
        "        let backup_id = manager.handle_failure(\"primary-1\").await.unwrap();",
        "        assert_eq!(backup_id, \"backup-2\");",
        "    }",
        "",
        "    #[tokio::test]",
        "    async fn test_failover_history() {"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/distributed/failover.rs",
      "line": 413,
      "code": "manager.handle_failure(\"primary-1\").await.unwrap();",
      "context": [
        "",
        "        manager.register_primary(\"group-1\".to_string(), primary).await;",
        "        manager.register_backup(\"group-1\".to_string(), backup).await;",
        "",
        "        // Perform failover",
        "        manager.handle_failure(\"primary-1\").await.unwrap();",
        "",
        "        // Check history",
        "        let history = manager.get_history(None).await;",
        "        assert!(history.len() >= 3); // FailureDetected, FailoverInitiated, FailoverCompleted",
        ""
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/distributed/failover.rs",
      "line": 421,
      "code": ".unwrap();",
      "context": [
        "        let history = manager.get_history(None).await;",
        "        assert!(history.len() >= 3); // FailureDetected, FailoverInitiated, FailoverCompleted",
        "",
        "        let failure_event = history.iter()",
        "            .find(|e| e.event_type == FailoverEventType::FailureDetected)",
        "            .unwrap();",
        "        assert_eq!(failure_event.source, \"primary-1\");",
        "    }",
        "}"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/distributed/load_balancer.rs",
      "line": 324,
      "code": "Arc::new(McpServer::new(id.to_string(), config).unwrap())",
      "context": [
        "            max_retries: 3,",
        "            priority: 10,",
        "            tags: vec![],",
        "        };",
        "",
        "        Arc::new(McpServer::new(id.to_string(), config).unwrap())",
        "    }",
        "",
        "    #[tokio::test]",
        "    async fn test_round_robin() {",
        "        let lb = LoadBalancer::new(LoadBalancingAlgorithm::RoundRobin);"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/distributed/load_balancer.rs",
      "line": 338,
      "code": "let server1 = lb.select_server(\"test-pool\", None).await.unwrap();",
      "context": [
        "            let server = create_test_server(&format!(\"server-{}\", i));",
        "            lb.add_server(\"test-pool\".to_string(), server, 1).await;",
        "        }",
        "",
        "        // Test round-robin selection",
        "        let server1 = lb.select_server(\"test-pool\", None).await.unwrap();",
        "        let server2 = lb.select_server(\"test-pool\", None).await.unwrap();",
        "",
        "        assert_ne!(server1.id(), server2.id());",
        "    }",
        ""
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/distributed/load_balancer.rs",
      "line": 339,
      "code": "let server2 = lb.select_server(\"test-pool\", None).await.unwrap();",
      "context": [
        "            lb.add_server(\"test-pool\".to_string(), server, 1).await;",
        "        }",
        "",
        "        // Test round-robin selection",
        "        let server1 = lb.select_server(\"test-pool\", None).await.unwrap();",
        "        let server2 = lb.select_server(\"test-pool\", None).await.unwrap();",
        "",
        "        assert_ne!(server1.id(), server2.id());",
        "    }",
        "",
        "    #[tokio::test]"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/distributed/load_balancer.rs",
      "line": 355,
      "code": "lb.update_connections(\"test-pool\", \"server-0\", 5).await.unwrap();",
      "context": [
        "            let server = create_test_server(&format!(\"server-{}\", i));",
        "            lb.add_server(\"test-pool\".to_string(), server, 1).await;",
        "        }",
        "",
        "        // Update connections",
        "        lb.update_connections(\"test-pool\", \"server-0\", 5).await.unwrap();",
        "        lb.update_connections(\"test-pool\", \"server-1\", 2).await.unwrap();",
        "",
        "        // Should select server-2 (0 connections)",
        "        let server = lb.select_server(\"test-pool\", None).await.unwrap();",
        "        assert_eq!(server.id(), \"server-2\");"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/distributed/load_balancer.rs",
      "line": 356,
      "code": "lb.update_connections(\"test-pool\", \"server-1\", 2).await.unwrap();",
      "context": [
        "            lb.add_server(\"test-pool\".to_string(), server, 1).await;",
        "        }",
        "",
        "        // Update connections",
        "        lb.update_connections(\"test-pool\", \"server-0\", 5).await.unwrap();",
        "        lb.update_connections(\"test-pool\", \"server-1\", 2).await.unwrap();",
        "",
        "        // Should select server-2 (0 connections)",
        "        let server = lb.select_server(\"test-pool\", None).await.unwrap();",
        "        assert_eq!(server.id(), \"server-2\");",
        "    }"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/distributed/load_balancer.rs",
      "line": 359,
      "code": "let server = lb.select_server(\"test-pool\", None).await.unwrap();",
      "context": [
        "        // Update connections",
        "        lb.update_connections(\"test-pool\", \"server-0\", 5).await.unwrap();",
        "        lb.update_connections(\"test-pool\", \"server-1\", 2).await.unwrap();",
        "",
        "        // Should select server-2 (0 connections)",
        "        let server = lb.select_server(\"test-pool\", None).await.unwrap();",
        "        assert_eq!(server.id(), \"server-2\");",
        "    }",
        "",
        "    #[tokio::test]",
        "    async fn test_ip_hash() {"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/distributed/load_balancer.rs",
      "line": 374,
      "code": "let server1 = lb.select_server(\"test-pool\", Some(\"192.168.1.1\")).await.unwrap();",
      "context": [
        "            let server = create_test_server(&format!(\"server-{}\", i));",
        "            lb.add_server(\"test-pool\".to_string(), server, 1).await;",
        "        }",
        "",
        "        // Same IP should always get same server",
        "        let server1 = lb.select_server(\"test-pool\", Some(\"192.168.1.1\")).await.unwrap();",
        "        let server2 = lb.select_server(\"test-pool\", Some(\"192.168.1.1\")).await.unwrap();",
        "",
        "        assert_eq!(server1.id(), server2.id());",
        "    }",
        "}"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/mcp_manager/distributed/load_balancer.rs",
      "line": 375,
      "code": "let server2 = lb.select_server(\"test-pool\", Some(\"192.168.1.1\")).await.unwrap();",
      "context": [
        "            lb.add_server(\"test-pool\".to_string(), server, 1).await;",
        "        }",
        "",
        "        // Same IP should always get same server",
        "        let server1 = lb.select_server(\"test-pool\", Some(\"192.168.1.1\")).await.unwrap();",
        "        let server2 = lb.select_server(\"test-pool\", Some(\"192.168.1.1\")).await.unwrap();",
        "",
        "        assert_eq!(server1.id(), server2.id());",
        "    }",
        "}"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/synthex_bashgod/synergy/optimizer.rs",
      "line": 695,
      "code": "let result = optimizer.optimize(commands, vec![synergy], &context).await.unwrap();",
      "context": [
        "                max_memory_mb: None,",
        "                atomic_required: false,",
        "            },",
        "        };",
        "",
        "        let result = optimizer.optimize(commands, vec![synergy], &context).await.unwrap();",
        "",
        "        assert!(result.success);",
        "        assert_eq!(result.optimized.len(), 1);",
        "        assert!(result.optimized[0].contains(\"|\"));",
        "    }"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/synthex_bashgod/synergy/detector.rs",
      "line": 693,
      "code": "let result = detector.detect(&commands, &context).await.unwrap();",
      "context": [
        "                max_memory_mb: None,",
        "                atomic_required: false,",
        "            },",
        "        };",
        "",
        "        let result = detector.detect(&commands, &context).await.unwrap();",
        "",
        "        assert!(!result.synergies.is_empty());",
        "        assert!(result.overall_score > 0.0);",
        "    }",
        "}"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/synthex_bashgod/memory/hybrid.rs",
      "line": 372,
      "code": ".unwrap();",
      "context": [
        "        let memory = HybridMemoryBuilder::new()",
        "            .tensor_weight(0.5)",
        "            .graph_weight(0.5)",
        "            .use_gpu(false)",
        "            .build()",
        "            .unwrap();",
        "",
        "        let pattern = CommandPattern {",
        "            id: \"hybrid-test\".to_string(),",
        "            commands: vec![\"echo hybrid\".to_string()],",
        "            features: vec![0.5; 128],"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/synthex_bashgod/memory/hybrid.rs",
      "line": 396,
      "code": "memory.store_pattern(pattern.clone()).await.unwrap();",
      "context": [
        "                avg_memory_mb: 5,",
        "            },",
        "        };",
        "",
        "        // Store pattern",
        "        memory.store_pattern(pattern.clone()).await.unwrap();",
        "",
        "        // Find similar",
        "        let results = memory.find_similar(&pattern, 0.8).await.unwrap();",
        "",
        "        assert!(!results.is_empty());"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/synthex_bashgod/memory/hybrid.rs",
      "line": 399,
      "code": "let results = memory.find_similar(&pattern, 0.8).await.unwrap();",
      "context": [
        "",
        "        // Store pattern",
        "        memory.store_pattern(pattern.clone()).await.unwrap();",
        "",
        "        // Find similar",
        "        let results = memory.find_similar(&pattern, 0.8).await.unwrap();",
        "",
        "        assert!(!results.is_empty());",
        "        assert_eq!(results[0].pattern.id, \"hybrid-test\");",
        "    }",
        ""
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/synthex_bashgod/memory/hybrid.rs",
      "line": 411,
      "code": ".unwrap();",
      "context": [
        "    async fn test_hybrid_memory_stats() {",
        "        let memory = HybridMemoryBuilder::new()",
        "            .max_patterns(1000)",
        "            .max_graph_nodes(5000)",
        "            .build()",
        "            .unwrap();",
        "",
        "        // Add some patterns",
        "        for i in 0..5 {",
        "            let pattern = CommandPattern {",
        "                id: format!(\"pattern-{}\", i),"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/synthex_bashgod/memory/hybrid.rs",
      "line": 430,
      "code": "memory.store_pattern(pattern).await.unwrap();",
      "context": [
        "                    last_accessed: chrono::Utc::now(),",
        "                },",
        "                metrics: PatternMetrics::default(),",
        "            };",
        "",
        "            memory.store_pattern(pattern).await.unwrap();",
        "        }",
        "",
        "        // Get stats",
        "        let stats = memory.get_memory_stats().await.unwrap();",
        ""
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/synthex_bashgod/memory/hybrid.rs",
      "line": 434,
      "code": "let stats = memory.get_memory_stats().await.unwrap();",
      "context": [
        "",
        "            memory.store_pattern(pattern).await.unwrap();",
        "        }",
        "",
        "        // Get stats",
        "        let stats = memory.get_memory_stats().await.unwrap();",
        "",
        "        assert_eq!(stats.pattern_count, 5);",
        "        assert!(stats.graph_nodes >= 5); // At least one node per pattern",
        "    }",
        ""
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/synthex_bashgod/memory/hybrid.rs",
      "line": 445,
      "code": ".unwrap();",
      "context": [
        "    #[tokio::test]",
        "    async fn test_memory_optimization() {",
        "        let memory = HybridMemoryBuilder::new()",
        "            .enable_cross_optimization(true)",
        "            .build()",
        "            .unwrap();",
        "",
        "        // Add patterns",
        "        for i in 0..10 {",
        "            let pattern = CommandPattern {",
        "                id: format!(\"opt-pattern-{}\", i),"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/synthex_bashgod/memory/hybrid.rs",
      "line": 467,
      "code": "memory.store_pattern(pattern).await.unwrap();",
      "context": [
        "                    execution_count: (10 - i) as u64,",
        "                    ..Default::default()",
        "                },",
        "            };",
        "",
        "            memory.store_pattern(pattern).await.unwrap();",
        "        }",
        "",
        "        // Optimize",
        "        let result = memory.optimize_memory().await.unwrap();",
        ""
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/synthex_bashgod/memory/hybrid.rs",
      "line": 471,
      "code": "let result = memory.optimize_memory().await.unwrap();",
      "context": [
        "",
        "            memory.store_pattern(pattern).await.unwrap();",
        "        }",
        "",
        "        // Optimize",
        "        let result = memory.optimize_memory().await.unwrap();",
        "",
        "        // Should have freed some memory",
        "        assert!(result.memory_freed_mb > 0 || result.patterns_evicted > 0 || result.nodes_pruned > 0);",
        "    }",
        "}"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/synthex_bashgod/memory/tensor.rs",
      "line": 725,
      "code": "let memory = TensorMemory::new(config).unwrap();",
      "context": [
        "        let config = TensorMemoryConfig {",
        "            use_gpu: false, // Use CPU for tests",
        "            ..Default::default()",
        "        };",
        "",
        "        let memory = TensorMemory::new(config).unwrap();",
        "",
        "        // Create test pattern",
        "        let pattern = CommandPattern {",
        "            id: \"test-1\".to_string(),",
        "            commands: vec![\"ls -la\".to_string()],"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/synthex_bashgod/memory/tensor.rs",
      "line": 750,
      "code": "memory.store(pattern.clone()).await.unwrap();",
      "context": [
        "                avg_memory_mb: 10,",
        "            },",
        "        };",
        "",
        "        // Store pattern",
        "        memory.store(pattern.clone()).await.unwrap();",
        "",
        "        // Find similar patterns",
        "        let results = memory.find_similar(&vec![0.5; 128], 0.9).await.unwrap();",
        "",
        "        assert_eq!(results.len(), 1);"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/synthex_bashgod/memory/tensor.rs",
      "line": 753,
      "code": "let results = memory.find_similar(&vec![0.5; 128], 0.9).await.unwrap();",
      "context": [
        "",
        "        // Store pattern",
        "        memory.store(pattern.clone()).await.unwrap();",
        "",
        "        // Find similar patterns",
        "        let results = memory.find_similar(&vec![0.5; 128], 0.9).await.unwrap();",
        "",
        "        assert_eq!(results.len(), 1);",
        "        assert_eq!(results[0].pattern.id, \"test-1\");",
        "        assert!(results[0].similarity > 0.99);",
        "    }"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/synthex_bashgod/memory/tensor.rs",
      "line": 767,
      "code": "let memory = TensorMemory::new(config).unwrap();",
      "context": [
        "        let config = TensorMemoryConfig {",
        "            use_gpu: false,",
        "            ..Default::default()",
        "        };",
        "",
        "        let memory = TensorMemory::new(config).unwrap();",
        "",
        "        // Store initial pattern",
        "        let pattern = CommandPattern {",
        "            id: \"stats-test\".to_string(),",
        "            commands: vec![\"echo test\".to_string()],"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/synthex_bashgod/memory/tensor.rs",
      "line": 791,
      "code": "memory.store(pattern).await.unwrap();",
      "context": [
        "                avg_cpu_usage: 0.1,",
        "                avg_memory_mb: 10,",
        "            },",
        "        };",
        "",
        "        memory.store(pattern).await.unwrap();",
        "",
        "        // Update statistics",
        "        let execution_result = ExecutionResult {",
        "            success: true,",
        "            execution_time_ms: 200,"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/synthex_bashgod/memory/tensor.rs",
      "line": 802,
      "code": "memory.update_stats(\"stats-test\", &execution_result).await.unwrap();",
      "context": [
        "            cpu_usage: 0.2,",
        "            memory_mb: 20,",
        "            errors: vec![],",
        "        };",
        "",
        "        memory.update_stats(\"stats-test\", &execution_result).await.unwrap();",
        "",
        "        // Verify update",
        "        let updated = memory.patterns.get(\"stats-test\").unwrap();",
        "        assert_eq!(updated.metrics.execution_count, 2);",
        "        assert_eq!(updated.metrics.avg_execution_time_ms, 150.0);"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/synthex_bashgod/memory/graph.rs",
      "line": 630,
      "code": "memory.add_pattern(&pattern).await.unwrap();",
      "context": [
        "                avg_cpu_usage: 0.1,",
        "                avg_memory_mb: 10,",
        "            },",
        "        };",
        "",
        "        memory.add_pattern(&pattern).await.unwrap();",
        "",
        "        let (patterns, nodes, edges) = memory.get_stats().await;",
        "        assert_eq!(patterns, 1);",
        "        assert_eq!(nodes, 4); // 1 pattern + 3 commands",
        "        assert!(edges >= 5); // Pattern->commands + sequence + dependencies"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/synthex_bashgod/memory/graph.rs",
      "line": 658,
      "code": "memory.add_pattern(&pattern1).await.unwrap();",
      "context": [
        "                last_accessed: chrono::Utc::now(),",
        "            },",
        "            metrics: Default::default(),",
        "        };",
        "",
        "        memory.add_pattern(&pattern1).await.unwrap();",
        "",
        "        // Add second pattern with connection",
        "        let pattern2 = CommandPattern {",
        "            id: \"pattern2\".to_string(),",
        "            commands: vec![\"echo end\".to_string()],"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/synthex_bashgod/memory/graph.rs",
      "line": 676,
      "code": "memory.add_pattern(&pattern2).await.unwrap();",
      "context": [
        "                last_accessed: chrono::Utc::now(),",
        "            },",
        "            metrics: Default::default(),",
        "        };",
        "",
        "        memory.add_pattern(&pattern2).await.unwrap();",
        "",
        "        // Manually add connection between patterns",
        "        let mut graph = memory.graph.write().await;",
        "        if let (Some(&idx1), Some(&idx2)) =",
        "            (memory.node_index.get(\"pattern1\"), memory.node_index.get(\"pattern2\")) {"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/synthex_bashgod/memory/graph.rs",
      "line": 699,
      "code": "let related = memory.find_related(\"pattern1\", 2).await.unwrap();",
      "context": [
        "            );",
        "        }",
        "        drop(graph);",
        "",
        "        // Find related patterns",
        "        let related = memory.find_related(\"pattern1\", 2).await.unwrap();",
        "",
        "        assert!(related.iter().any(|(id, _)| id == \"pattern2\"));",
        "    }",
        "",
        "    #[tokio::test]"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/synthex_bashgod/memory/graph.rs",
      "line": 725,
      "code": "memory.add_pattern(&pattern).await.unwrap();",
      "context": [
        "                    last_accessed: chrono::Utc::now(),",
        "                },",
        "                metrics: Default::default(),",
        "            };",
        "",
        "            memory.add_pattern(&pattern).await.unwrap();",
        "        }",
        "",
        "        // Add connections to form a cycle",
        "        let mut graph = memory.graph.write().await;",
        "        let idx0 = memory.node_index.get(\"pattern0\").unwrap();"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/synthex_bashgod/memory/graph.rs",
      "line": 752,
      "code": "let communities = memory.detect_communities().await.unwrap();",
      "context": [
        "            );",
        "        }",
        "        drop(graph);",
        "",
        "        // Detect communities",
        "        let communities = memory.detect_communities().await.unwrap();",
        "",
        "        // Should detect at least one community",
        "        assert!(!communities.is_empty());",
        "    }",
        "}"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/synthex_bashgod/memory/mod.rs",
      "line": 252,
      "code": "lru_cache: lru::LruCache::new(capacity.try_into().unwrap()),",
      "context": [
        "",
        "impl MemoryCache {",
        "    /// Create a new memory cache",
        "    pub fn new(capacity: usize) -> Self {",
        "        Self {",
        "            lru_cache: lru::LruCache::new(capacity.try_into().unwrap()),",
        "            feature_index: dashmap::DashMap::new(),",
        "        }",
        "    }",
        "",
        "    /// Add pattern to cache"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/synthex_bashgod/mcp_integration/server_manager.rs",
      "line": 120,
      "code": ".unwrap();",
      "context": [
        "    /// Create new server manager",
        "    pub fn new(configs: Vec<MCPServerConfig>) -> Self {",
        "        let client = Client::builder()",
        "            .timeout(Duration::from_secs(30))",
        "            .build()",
        "            .unwrap();",
        "",
        "        let servers = Arc::new(DashMap::new());",
        "",
        "        // Initialize servers",
        "        for config in configs {"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/synthex/agents/database_agent.rs",
      "line": 144,
      "code": "all_results.sort_by(|a, b| b.score.partial_cmp(&a.score).unwrap());",
      "context": [
        "                all_results.push(result);",
        "            }",
        "        }",
        "",
        "        // Sort by score",
        "        all_results.sort_by(|a, b| b.score.partial_cmp(&a.score).unwrap());",
        "        all_results.truncate(options.max_results);",
        "",
        "        Ok(all_results)",
        "    }",
        ""
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/synthex/agents/api_agent.rs",
      "line": 169,
      "code": "match request.try_clone().unwrap().send().await {",
      "context": [
        "        let mut attempts = 0;",
        "",
        "        loop {",
        "            attempts += 1;",
        "",
        "            match request.try_clone().unwrap().send().await {",
        "                Ok(response) if response.status().is_success() => return Ok(response),",
        "                Ok(response) => {",
        "                    let status = response.status();",
        "                    let body = response.text().await.unwrap_or_default();",
        ""
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/synthex/agents/api_agent.rs",
      "line": 343,
      "code": "all_results.sort_by(|a, b| b.score.partial_cmp(&a.score).unwrap());",
      "context": [
        "                }",
        "            }",
        "        }",
        "",
        "        // Sort by score and limit",
        "        all_results.sort_by(|a, b| b.score.partial_cmp(&a.score).unwrap());",
        "        all_results.truncate(options.max_results);",
        "",
        "        // Update metrics",
        "        {",
        "            let mut metrics = self.metrics.write();"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    },
    {
      "file": "src/synthex/agents/api_agent.rs",
      "line": 371,
      "code": "let (_, endpoint) = endpoints.iter().next().unwrap();",
      "context": [
        "                last_check: chrono::Utc::now().timestamp_millis() as u64,",
        "            });",
        "        }",
        "",
        "        // Check first endpoint",
        "        let (_, endpoint) = endpoints.iter().next().unwrap();",
        "        let start = std::time::Instant::now();",
        "",
        "        let url = format!(\"{}/health\", endpoint.base_url);",
        "        let response = self.client",
        "            .get(&url)"
      ],
      "suggestion": "Replace .unwrap() with ? for error propagation"
    }
  ],
  "needs_expect": [
    {
      "file": "src/infrastructure.rs",
      "line": 408,
      "code": "regex::Regex::new(r\"(?i)(error|exception|failed)\").unwrap()",
      "context": [
        "    #[new]",
        "    fn new() -> Self {",
        "        let mut patterns = HashMap::new();",
        "        patterns.insert(",
        "            \"error\".to_string(),",
        "            regex::Regex::new(r\"(?i)(error|exception|failed)\").unwrap()",
        "        );",
        "        patterns.insert(",
        "            \"warning\".to_string(),",
        "            regex::Regex::new(r\"(?i)(warn|warning|deprecated)\").unwrap()",
        "        );"
      ],
      "suggestion": "Use .expect(\"Invalid regex pattern: (?i)(error|exception...\")"
    },
    {
      "file": "src/infrastructure.rs",
      "line": 412,
      "code": "regex::Regex::new(r\"(?i)(warn|warning|deprecated)\").unwrap()",
      "context": [
        "            \"error\".to_string(),",
        "            regex::Regex::new(r\"(?i)(error|exception|failed)\").unwrap()",
        "        );",
        "        patterns.insert(",
        "            \"warning\".to_string(),",
        "            regex::Regex::new(r\"(?i)(warn|warning|deprecated)\").unwrap()",
        "        );",
        "        patterns.insert(",
        "            \"timestamp\".to_string(),",
        "            regex::Regex::new(r\"\\d{4}-\\d{2}-\\d{2}[T\\s]\\d{2}:\\d{2}:\\d{2}\").unwrap()",
        "        );"
      ],
      "suggestion": "Use .expect(\"Invalid regex pattern: (?i)(warn|warning|de...\")"
    },
    {
      "file": "src/infrastructure.rs",
      "line": 416,
      "code": "regex::Regex::new(r\"\\d{4}-\\d{2}-\\d{2}[T\\s]\\d{2}:\\d{2}:\\d{2}\").unwrap()",
      "context": [
        "            \"warning\".to_string(),",
        "            regex::Regex::new(r\"(?i)(warn|warning|deprecated)\").unwrap()",
        "        );",
        "        patterns.insert(",
        "            \"timestamp\".to_string(),",
        "            regex::Regex::new(r\"\\d{4}-\\d{2}-\\d{2}[T\\s]\\d{2}:\\d{2}:\\d{2}\").unwrap()",
        "        );",
        "",
        "        Self {",
        "            patterns,",
        "            total_lines: 0,"
      ],
      "suggestion": "Use .expect(\"Invalid regex pattern: \\d{4}-\\d{2}-\\d{2}[T\\...\")"
    },
    {
      "file": "src/security_enhanced.rs",
      "line": 43,
      "code": "Regex::new(r\"^[a-zA-Z0-9_\\-\\.\\/]+$\").unwrap()",
      "context": [
        "// Constants and Static Configuration",
        "// ============================================================================",
        "",
        "// Command validation patterns",
        "static SAFE_COMMAND_PATTERN: Lazy<Regex> = Lazy::new(|| {",
        "    Regex::new(r\"^[a-zA-Z0-9_\\-\\.\\/]+$\").unwrap()",
        "});",
        "",
        "static DANGEROUS_PATTERNS: Lazy<Vec<Regex>> = Lazy::new(|| {",
        "    vec![",
        "        Regex::new(r\"(;|\\||&&|\\$\\(|\\`|>|<)\").unwrap(),  // Command injection"
      ],
      "suggestion": "Use .expect(\"Invalid regex pattern: ^[a-zA-Z0-9_\\-\\.\\/]+...\")"
    },
    {
      "file": "src/security_enhanced.rs",
      "line": 48,
      "code": "Regex::new(r\"(;|\\||&&|\\$\\(|\\`|>|<)\").unwrap(),  // Command injection",
      "context": [
        "    Regex::new(r\"^[a-zA-Z0-9_\\-\\.\\/]+$\").unwrap()",
        "});",
        "",
        "static DANGEROUS_PATTERNS: Lazy<Vec<Regex>> = Lazy::new(|| {",
        "    vec![",
        "        Regex::new(r\"(;|\\||&&|\\$\\(|\\`|>|<)\").unwrap(),  // Command injection",
        "        Regex::new(r\"\\.\\.\\/\").unwrap(),                  // Path traversal",
        "        Regex::new(r\"\\$\\{.*\\}\").unwrap(),               // Variable expansion",
        "        Regex::new(r\"eval|exec|system\").unwrap(),       // Dangerous functions",
        "    ]",
        "});"
      ],
      "suggestion": "Use .expect(\"Invalid regex pattern: (;|\\||&&|\\$\\(|\\`|>|<...\")"
    },
    {
      "file": "src/security_enhanced.rs",
      "line": 49,
      "code": "Regex::new(r\"\\.\\.\\/\").unwrap(),                  // Path traversal",
      "context": [
        "});",
        "",
        "static DANGEROUS_PATTERNS: Lazy<Vec<Regex>> = Lazy::new(|| {",
        "    vec![",
        "        Regex::new(r\"(;|\\||&&|\\$\\(|\\`|>|<)\").unwrap(),  // Command injection",
        "        Regex::new(r\"\\.\\.\\/\").unwrap(),                  // Path traversal",
        "        Regex::new(r\"\\$\\{.*\\}\").unwrap(),               // Variable expansion",
        "        Regex::new(r\"eval|exec|system\").unwrap(),       // Dangerous functions",
        "    ]",
        "});",
        ""
      ],
      "suggestion": "Use .expect(\"Invalid regex pattern: \\.\\.\\/...\")"
    },
    {
      "file": "src/security_enhanced.rs",
      "line": 50,
      "code": "Regex::new(r\"\\$\\{.*\\}\").unwrap(),               // Variable expansion",
      "context": [
        "",
        "static DANGEROUS_PATTERNS: Lazy<Vec<Regex>> = Lazy::new(|| {",
        "    vec![",
        "        Regex::new(r\"(;|\\||&&|\\$\\(|\\`|>|<)\").unwrap(),  // Command injection",
        "        Regex::new(r\"\\.\\.\\/\").unwrap(),                  // Path traversal",
        "        Regex::new(r\"\\$\\{.*\\}\").unwrap(),               // Variable expansion",
        "        Regex::new(r\"eval|exec|system\").unwrap(),       // Dangerous functions",
        "    ]",
        "});",
        "",
        "// Allowed commands whitelist"
      ],
      "suggestion": "Use .expect(\"Invalid regex pattern: \\$\\{.*\\}...\")"
    },
    {
      "file": "src/security_enhanced.rs",
      "line": 51,
      "code": "Regex::new(r\"eval|exec|system\").unwrap(),       // Dangerous functions",
      "context": [
        "static DANGEROUS_PATTERNS: Lazy<Vec<Regex>> = Lazy::new(|| {",
        "    vec![",
        "        Regex::new(r\"(;|\\||&&|\\$\\(|\\`|>|<)\").unwrap(),  // Command injection",
        "        Regex::new(r\"\\.\\.\\/\").unwrap(),                  // Path traversal",
        "        Regex::new(r\"\\$\\{.*\\}\").unwrap(),               // Variable expansion",
        "        Regex::new(r\"eval|exec|system\").unwrap(),       // Dangerous functions",
        "    ]",
        "});",
        "",
        "// Allowed commands whitelist",
        "static ALLOWED_COMMANDS: Lazy<HashSet<&'static str>> = Lazy::new(|| {"
      ],
      "suggestion": "Use .expect(\"Invalid regex pattern: eval|exec|system...\")"
    },
    {
      "file": "src/security_enhanced.rs",
      "line": 852,
      "code": "pattern: Regex::new(r#\"(password|passwd|pwd)\\s*=\\s*['\\\"].*['\\\"]\"#).unwrap(),",
      "context": [
        "",
        "        let static_analyzer = StaticAnalyzer {",
        "            rules: vec![",
        "                SecurityRule {",
        "                    name: \"Hardcoded Credentials\".to_string(),",
        "                    pattern: Regex::new(r#\"(password|passwd|pwd)\\s*=\\s*['\\\"].*['\\\"]\"#).unwrap(),",
        "                    severity: Severity::Critical,",
        "                },",
        "                SecurityRule {",
        "                    name: \"Weak Cryptography\".to_string(),",
        "                    pattern: Regex::new(r\"(MD5|SHA1|DES|RC4)\").unwrap(),"
      ],
      "suggestion": "Replace with .expect(\"descriptive error message\")"
    },
    {
      "file": "src/security_enhanced.rs",
      "line": 857,
      "code": "pattern: Regex::new(r\"(MD5|SHA1|DES|RC4)\").unwrap(),",
      "context": [
        "                    pattern: Regex::new(r#\"(password|passwd|pwd)\\s*=\\s*['\\\"].*['\\\"]\"#).unwrap(),",
        "                    severity: Severity::Critical,",
        "                },",
        "                SecurityRule {",
        "                    name: \"Weak Cryptography\".to_string(),",
        "                    pattern: Regex::new(r\"(MD5|SHA1|DES|RC4)\").unwrap(),",
        "                    severity: Severity::High,",
        "                },",
        "                SecurityRule {",
        "                    name: \"Unsafe Deserialization\".to_string(),",
        "                    pattern: Regex::new(r\"pickle\\.loads|yaml\\.load\\(\").unwrap(),"
      ],
      "suggestion": "Use .expect(\"Invalid regex pattern: (MD5|SHA1|DES|RC4)...\")"
    },
    {
      "file": "src/security_enhanced.rs",
      "line": 862,
      "code": "pattern: Regex::new(r\"pickle\\.loads|yaml\\.load\\(\").unwrap(),",
      "context": [
        "                    pattern: Regex::new(r\"(MD5|SHA1|DES|RC4)\").unwrap(),",
        "                    severity: Severity::High,",
        "                },",
        "                SecurityRule {",
        "                    name: \"Unsafe Deserialization\".to_string(),",
        "                    pattern: Regex::new(r\"pickle\\.loads|yaml\\.load\\(\").unwrap(),",
        "                    severity: Severity::High,",
        "                },",
        "            ],",
        "        };",
        ""
      ],
      "suggestion": "Use .expect(\"Invalid regex pattern: pickle\\.loads|yaml\\....\")"
    },
    {
      "file": "src/adaptive_learning.rs",
      "line": 134,
      "code": "let mut state = self.cross_instance_state.lock().unwrap();",
      "context": [
        "        // Perform high-speed knowledge merging",
        "        let merged_knowledge = self.merge_knowledge_efficiently(&knowledge_data);",
        "",
        "        // Update cross-instance state",
        "        {",
        "            let mut state = self.cross_instance_state.lock().unwrap();",
        "            state.shared_knowledge.extend(merged_knowledge);",
        "            state.sync_timestamp = std::time::SystemTime::now();",
        "        }",
        "",
        "        // Calculate relevance scores in parallel"
      ],
      "suggestion": "Use .expect(\"Mutex poisoned\") or handle poisoning explicitly"
    },
    {
      "file": "src/adaptive_learning.rs",
      "line": 227,
      "code": "let metrics = self.performance_metrics.lock().unwrap();",
      "context": [
        "        Ok(result.into())",
        "    }",
        "",
        "    /// Get performance statistics",
        "    fn get_performance_stats(&self, py: Python<'_>) -> PyResult<PyObject> {",
        "        let metrics = self.performance_metrics.lock().unwrap();",
        "",
        "        let result = PyDict::new(py);",
        "        result.set_item(\"total_patterns_processed\", metrics.total_patterns_processed)?;",
        "        result.set_item(\"average_processing_time_ms\", metrics.average_processing_time_ms)?;",
        "        result.set_item(\"memory_usage_mb\", metrics.memory_usage_mb)?;"
      ],
      "suggestion": "Use .expect(\"Mutex poisoned\") or handle poisoning explicitly"
    },
    {
      "file": "src/adaptive_learning.rs",
      "line": 401,
      "code": "let mut metrics = self.performance_metrics.lock().unwrap();",
      "context": [
        "        // Return a complexity score",
        "        variance.sqrt() + mean.abs()",
        "    }",
        "",
        "    fn update_performance_metrics(&self, processing_time: f64, pattern_count: usize) {",
        "        let mut metrics = self.performance_metrics.lock().unwrap();",
        "",
        "        metrics.total_patterns_processed += pattern_count as u64;",
        "",
        "        // Update running average",
        "        let alpha = 0.1; // Exponential moving average factor"
      ],
      "suggestion": "Use .expect(\"Mutex poisoned\") or handle poisoning explicitly"
    },
    {
      "file": "src/mcp_manager/metrics.rs",
      "line": 19,
      "code": ").unwrap();",
      "context": [
        "lazy_static::lazy_static! {",
        "    /// Request counter",
        "    static ref REQUEST_COUNTER: IntCounterVec = IntCounterVec::new(",
        "        Opts::new(\"mcp_requests_total\", \"Total number of requests\"),",
        "        &[\"server_id\", \"method\", \"status\"]",
        "    ).unwrap();",
        "",
        "    /// Response time histogram",
        "    static ref RESPONSE_TIME: HistogramVec = HistogramVec::new(",
        "        HistogramOpts::new(\"mcp_response_time_seconds\", \"Response time in seconds\"),",
        "        &[\"server_id\", \"method\"]"
      ],
      "suggestion": "Replace with .expect(\"descriptive error message\")"
    },
    {
      "file": "src/synthex/query_parser.rs",
      "line": 223,
      "code": "Regex::new(r\"find|search|look for|locate|discover\").unwrap(),",
      "context": [
        "    fn new() -> Self {",
        "        let mut patterns = HashMap::new();",
        "",
        "        // Search patterns",
        "        patterns.insert(QueryIntent::Search, vec![",
        "            Regex::new(r\"find|search|look for|locate|discover\").unwrap(),",
        "            Regex::new(r\"what is|who is|where is|when is\").unwrap(),",
        "        ]);",
        "",
        "        // Aggregate patterns",
        "        patterns.insert(QueryIntent::Aggregate, vec!["
      ],
      "suggestion": "Use .expect(\"Invalid regex pattern: find|search|look for...\")"
    },
    {
      "file": "src/synthex/query_parser.rs",
      "line": 224,
      "code": "Regex::new(r\"what is|who is|where is|when is\").unwrap(),",
      "context": [
        "        let mut patterns = HashMap::new();",
        "",
        "        // Search patterns",
        "        patterns.insert(QueryIntent::Search, vec![",
        "            Regex::new(r\"find|search|look for|locate|discover\").unwrap(),",
        "            Regex::new(r\"what is|who is|where is|when is\").unwrap(),",
        "        ]);",
        "",
        "        // Aggregate patterns",
        "        patterns.insert(QueryIntent::Aggregate, vec![",
        "            Regex::new(r\"sum|total|average|count|statistics\").unwrap(),"
      ],
      "suggestion": "Use .expect(\"Invalid regex pattern: what is|who is|where...\")"
    },
    {
      "file": "src/synthex/query_parser.rs",
      "line": 229,
      "code": "Regex::new(r\"sum|total|average|count|statistics\").unwrap(),",
      "context": [
        "            Regex::new(r\"what is|who is|where is|when is\").unwrap(),",
        "        ]);",
        "",
        "        // Aggregate patterns",
        "        patterns.insert(QueryIntent::Aggregate, vec![",
        "            Regex::new(r\"sum|total|average|count|statistics\").unwrap(),",
        "            Regex::new(r\"aggregate|combine|merge|collect\").unwrap(),",
        "        ]);",
        "",
        "        // Action patterns",
        "        patterns.insert(QueryIntent::Action, vec!["
      ],
      "suggestion": "Use .expect(\"Invalid regex pattern: sum|total|average|co...\")"
    },
    {
      "file": "src/synthex/query_parser.rs",
      "line": 230,
      "code": "Regex::new(r\"aggregate|combine|merge|collect\").unwrap(),",
      "context": [
        "        ]);",
        "",
        "        // Aggregate patterns",
        "        patterns.insert(QueryIntent::Aggregate, vec![",
        "            Regex::new(r\"sum|total|average|count|statistics\").unwrap(),",
        "            Regex::new(r\"aggregate|combine|merge|collect\").unwrap(),",
        "        ]);",
        "",
        "        // Action patterns",
        "        patterns.insert(QueryIntent::Action, vec![",
        "            Regex::new(r\"create|update|delete|modify|execute\").unwrap(),"
      ],
      "suggestion": "Use .expect(\"Invalid regex pattern: aggregate|combine|me...\")"
    },
    {
      "file": "src/synthex/query_parser.rs",
      "line": 235,
      "code": "Regex::new(r\"create|update|delete|modify|execute\").unwrap(),",
      "context": [
        "            Regex::new(r\"aggregate|combine|merge|collect\").unwrap(),",
        "        ]);",
        "",
        "        // Action patterns",
        "        patterns.insert(QueryIntent::Action, vec![",
        "            Regex::new(r\"create|update|delete|modify|execute\").unwrap(),",
        "            Regex::new(r\"run|start|stop|deploy|configure\").unwrap(),",
        "        ]);",
        "",
        "        Self { patterns }",
        "    }"
      ],
      "suggestion": "Use .expect(\"Invalid regex pattern: create|update|delete...\")"
    },
    {
      "file": "src/synthex/query_parser.rs",
      "line": 236,
      "code": "Regex::new(r\"run|start|stop|deploy|configure\").unwrap(),",
      "context": [
        "        ]);",
        "",
        "        // Action patterns",
        "        patterns.insert(QueryIntent::Action, vec![",
        "            Regex::new(r\"create|update|delete|modify|execute\").unwrap(),",
        "            Regex::new(r\"run|start|stop|deploy|configure\").unwrap(),",
        "        ]);",
        "",
        "        Self { patterns }",
        "    }",
        ""
      ],
      "suggestion": "Use .expect(\"Invalid regex pattern: run|start|stop|deplo...\")"
    },
    {
      "file": "src/synthex/query_parser.rs",
      "line": 313,
      "code": "Regex::new(r\"https?://[^\\s]+\").unwrap()",
      "context": [
        "    fn new() -> Self {",
        "        let mut entity_patterns = HashMap::new();",
        "",
        "        entity_patterns.insert(",
        "            EntityType::Url,",
        "            Regex::new(r\"https?://[^\\s]+\").unwrap()",
        "        );",
        "",
        "        entity_patterns.insert(",
        "            EntityType::Email,",
        "            Regex::new(r\"[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}\").unwrap()"
      ],
      "suggestion": "Use .expect(\"Invalid regex pattern: https?://[^\\s]+...\")"
    },
    {
      "file": "src/synthex/query_parser.rs",
      "line": 318,
      "code": "Regex::new(r\"[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}\").unwrap()",
      "context": [
        "            Regex::new(r\"https?://[^\\s]+\").unwrap()",
        "        );",
        "",
        "        entity_patterns.insert(",
        "            EntityType::Email,",
        "            Regex::new(r\"[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}\").unwrap()",
        "        );",
        "",
        "        entity_patterns.insert(",
        "            EntityType::Number,",
        "            Regex::new(r\"\\b\\d+\\.?\\d*\\b\").unwrap()"
      ],
      "suggestion": "Use .expect(\"Invalid regex pattern: [a-zA-Z0-9._%+-]+@[a...\")"
    },
    {
      "file": "src/synthex/query_parser.rs",
      "line": 323,
      "code": "Regex::new(r\"\\b\\d+\\.?\\d*\\b\").unwrap()",
      "context": [
        "            Regex::new(r\"[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}\").unwrap()",
        "        );",
        "",
        "        entity_patterns.insert(",
        "            EntityType::Number,",
        "            Regex::new(r\"\\b\\d+\\.?\\d*\\b\").unwrap()",
        "        );",
        "",
        "        Self { entity_patterns }",
        "    }",
        ""
      ],
      "suggestion": "Use .expect(\"Invalid regex pattern: \\b\\d+\\.?\\d*\\b...\")"
    },
    {
      "file": "src/mcp_manager/fusion/tool_enhancer.rs",
      "line": 19,
      "code": "(Regex::new(r\"^docker\\s+ps\").unwrap(), \"list_containers\"),",
      "context": [
        "use super::registry::ToolRegistry;",
        "",
        "lazy_static! {",
        "    /// Docker command patterns",
        "    static ref DOCKER_PATTERNS: Vec<(Regex, &'static str)> = vec![",
        "        (Regex::new(r\"^docker\\s+ps\").unwrap(), \"list_containers\"),",
        "        (Regex::new(r\"^docker\\s+images\").unwrap(), \"list_images\"),",
        "        (Regex::new(r\"^docker\\s+run\").unwrap(), \"run_container\"),",
        "        (Regex::new(r\"^docker\\s+build\").unwrap(), \"build_image\"),",
        "        (Regex::new(r\"^docker\\s+logs\").unwrap(), \"get_logs\"),",
        "        (Regex::new(r\"^docker\\s+exec\").unwrap(), \"exec_command\"),"
      ],
      "suggestion": "Use .expect(\"Invalid regex pattern: ^docker\\s+ps...\")"
    },
    {
      "file": "src/mcp_manager/fusion/tool_enhancer.rs",
      "line": 20,
      "code": "(Regex::new(r\"^docker\\s+images\").unwrap(), \"list_images\"),",
      "context": [
        "",
        "lazy_static! {",
        "    /// Docker command patterns",
        "    static ref DOCKER_PATTERNS: Vec<(Regex, &'static str)> = vec![",
        "        (Regex::new(r\"^docker\\s+ps\").unwrap(), \"list_containers\"),",
        "        (Regex::new(r\"^docker\\s+images\").unwrap(), \"list_images\"),",
        "        (Regex::new(r\"^docker\\s+run\").unwrap(), \"run_container\"),",
        "        (Regex::new(r\"^docker\\s+build\").unwrap(), \"build_image\"),",
        "        (Regex::new(r\"^docker\\s+logs\").unwrap(), \"get_logs\"),",
        "        (Regex::new(r\"^docker\\s+exec\").unwrap(), \"exec_command\"),",
        "        (Regex::new(r\"^docker\\s+stop\").unwrap(), \"stop_container\"),"
      ],
      "suggestion": "Use .expect(\"Invalid regex pattern: ^docker\\s+images...\")"
    },
    {
      "file": "src/mcp_manager/fusion/tool_enhancer.rs",
      "line": 21,
      "code": "(Regex::new(r\"^docker\\s+run\").unwrap(), \"run_container\"),",
      "context": [
        "lazy_static! {",
        "    /// Docker command patterns",
        "    static ref DOCKER_PATTERNS: Vec<(Regex, &'static str)> = vec![",
        "        (Regex::new(r\"^docker\\s+ps\").unwrap(), \"list_containers\"),",
        "        (Regex::new(r\"^docker\\s+images\").unwrap(), \"list_images\"),",
        "        (Regex::new(r\"^docker\\s+run\").unwrap(), \"run_container\"),",
        "        (Regex::new(r\"^docker\\s+build\").unwrap(), \"build_image\"),",
        "        (Regex::new(r\"^docker\\s+logs\").unwrap(), \"get_logs\"),",
        "        (Regex::new(r\"^docker\\s+exec\").unwrap(), \"exec_command\"),",
        "        (Regex::new(r\"^docker\\s+stop\").unwrap(), \"stop_container\"),",
        "        (Regex::new(r\"^docker\\s+rm\").unwrap(), \"remove_container\"),"
      ],
      "suggestion": "Use .expect(\"Invalid regex pattern: ^docker\\s+run...\")"
    },
    {
      "file": "src/mcp_manager/fusion/tool_enhancer.rs",
      "line": 22,
      "code": "(Regex::new(r\"^docker\\s+build\").unwrap(), \"build_image\"),",
      "context": [
        "    /// Docker command patterns",
        "    static ref DOCKER_PATTERNS: Vec<(Regex, &'static str)> = vec![",
        "        (Regex::new(r\"^docker\\s+ps\").unwrap(), \"list_containers\"),",
        "        (Regex::new(r\"^docker\\s+images\").unwrap(), \"list_images\"),",
        "        (Regex::new(r\"^docker\\s+run\").unwrap(), \"run_container\"),",
        "        (Regex::new(r\"^docker\\s+build\").unwrap(), \"build_image\"),",
        "        (Regex::new(r\"^docker\\s+logs\").unwrap(), \"get_logs\"),",
        "        (Regex::new(r\"^docker\\s+exec\").unwrap(), \"exec_command\"),",
        "        (Regex::new(r\"^docker\\s+stop\").unwrap(), \"stop_container\"),",
        "        (Regex::new(r\"^docker\\s+rm\").unwrap(), \"remove_container\"),",
        "        (Regex::new(r\"^docker-compose\\s+up\").unwrap(), \"compose_up\"),"
      ],
      "suggestion": "Use .expect(\"Invalid regex pattern: ^docker\\s+build...\")"
    },
    {
      "file": "src/mcp_manager/fusion/tool_enhancer.rs",
      "line": 23,
      "code": "(Regex::new(r\"^docker\\s+logs\").unwrap(), \"get_logs\"),",
      "context": [
        "    static ref DOCKER_PATTERNS: Vec<(Regex, &'static str)> = vec![",
        "        (Regex::new(r\"^docker\\s+ps\").unwrap(), \"list_containers\"),",
        "        (Regex::new(r\"^docker\\s+images\").unwrap(), \"list_images\"),",
        "        (Regex::new(r\"^docker\\s+run\").unwrap(), \"run_container\"),",
        "        (Regex::new(r\"^docker\\s+build\").unwrap(), \"build_image\"),",
        "        (Regex::new(r\"^docker\\s+logs\").unwrap(), \"get_logs\"),",
        "        (Regex::new(r\"^docker\\s+exec\").unwrap(), \"exec_command\"),",
        "        (Regex::new(r\"^docker\\s+stop\").unwrap(), \"stop_container\"),",
        "        (Regex::new(r\"^docker\\s+rm\").unwrap(), \"remove_container\"),",
        "        (Regex::new(r\"^docker-compose\\s+up\").unwrap(), \"compose_up\"),",
        "        (Regex::new(r\"^docker-compose\\s+down\").unwrap(), \"compose_down\"),"
      ],
      "suggestion": "Use .expect(\"Invalid regex pattern: ^docker\\s+logs...\")"
    },
    {
      "file": "src/mcp_manager/fusion/tool_enhancer.rs",
      "line": 24,
      "code": "(Regex::new(r\"^docker\\s+exec\").unwrap(), \"exec_command\"),",
      "context": [
        "        (Regex::new(r\"^docker\\s+ps\").unwrap(), \"list_containers\"),",
        "        (Regex::new(r\"^docker\\s+images\").unwrap(), \"list_images\"),",
        "        (Regex::new(r\"^docker\\s+run\").unwrap(), \"run_container\"),",
        "        (Regex::new(r\"^docker\\s+build\").unwrap(), \"build_image\"),",
        "        (Regex::new(r\"^docker\\s+logs\").unwrap(), \"get_logs\"),",
        "        (Regex::new(r\"^docker\\s+exec\").unwrap(), \"exec_command\"),",
        "        (Regex::new(r\"^docker\\s+stop\").unwrap(), \"stop_container\"),",
        "        (Regex::new(r\"^docker\\s+rm\").unwrap(), \"remove_container\"),",
        "        (Regex::new(r\"^docker-compose\\s+up\").unwrap(), \"compose_up\"),",
        "        (Regex::new(r\"^docker-compose\\s+down\").unwrap(), \"compose_down\"),",
        "    ];"
      ],
      "suggestion": "Use .expect(\"Invalid regex pattern: ^docker\\s+exec...\")"
    },
    {
      "file": "src/mcp_manager/fusion/tool_enhancer.rs",
      "line": 25,
      "code": "(Regex::new(r\"^docker\\s+stop\").unwrap(), \"stop_container\"),",
      "context": [
        "        (Regex::new(r\"^docker\\s+images\").unwrap(), \"list_images\"),",
        "        (Regex::new(r\"^docker\\s+run\").unwrap(), \"run_container\"),",
        "        (Regex::new(r\"^docker\\s+build\").unwrap(), \"build_image\"),",
        "        (Regex::new(r\"^docker\\s+logs\").unwrap(), \"get_logs\"),",
        "        (Regex::new(r\"^docker\\s+exec\").unwrap(), \"exec_command\"),",
        "        (Regex::new(r\"^docker\\s+stop\").unwrap(), \"stop_container\"),",
        "        (Regex::new(r\"^docker\\s+rm\").unwrap(), \"remove_container\"),",
        "        (Regex::new(r\"^docker-compose\\s+up\").unwrap(), \"compose_up\"),",
        "        (Regex::new(r\"^docker-compose\\s+down\").unwrap(), \"compose_down\"),",
        "    ];",
        ""
      ],
      "suggestion": "Use .expect(\"Invalid regex pattern: ^docker\\s+stop...\")"
    },
    {
      "file": "src/mcp_manager/fusion/tool_enhancer.rs",
      "line": 26,
      "code": "(Regex::new(r\"^docker\\s+rm\").unwrap(), \"remove_container\"),",
      "context": [
        "        (Regex::new(r\"^docker\\s+run\").unwrap(), \"run_container\"),",
        "        (Regex::new(r\"^docker\\s+build\").unwrap(), \"build_image\"),",
        "        (Regex::new(r\"^docker\\s+logs\").unwrap(), \"get_logs\"),",
        "        (Regex::new(r\"^docker\\s+exec\").unwrap(), \"exec_command\"),",
        "        (Regex::new(r\"^docker\\s+stop\").unwrap(), \"stop_container\"),",
        "        (Regex::new(r\"^docker\\s+rm\").unwrap(), \"remove_container\"),",
        "        (Regex::new(r\"^docker-compose\\s+up\").unwrap(), \"compose_up\"),",
        "        (Regex::new(r\"^docker-compose\\s+down\").unwrap(), \"compose_down\"),",
        "    ];",
        "",
        "    /// Git/GitHub command patterns"
      ],
      "suggestion": "Use .expect(\"Invalid regex pattern: ^docker\\s+rm...\")"
    },
    {
      "file": "src/mcp_manager/fusion/tool_enhancer.rs",
      "line": 27,
      "code": "(Regex::new(r\"^docker-compose\\s+up\").unwrap(), \"compose_up\"),",
      "context": [
        "        (Regex::new(r\"^docker\\s+build\").unwrap(), \"build_image\"),",
        "        (Regex::new(r\"^docker\\s+logs\").unwrap(), \"get_logs\"),",
        "        (Regex::new(r\"^docker\\s+exec\").unwrap(), \"exec_command\"),",
        "        (Regex::new(r\"^docker\\s+stop\").unwrap(), \"stop_container\"),",
        "        (Regex::new(r\"^docker\\s+rm\").unwrap(), \"remove_container\"),",
        "        (Regex::new(r\"^docker-compose\\s+up\").unwrap(), \"compose_up\"),",
        "        (Regex::new(r\"^docker-compose\\s+down\").unwrap(), \"compose_down\"),",
        "    ];",
        "",
        "    /// Git/GitHub command patterns",
        "    static ref GIT_PATTERNS: Vec<(Regex, &'static str)> = vec!["
      ],
      "suggestion": "Use .expect(\"Invalid regex pattern: ^docker-compose\\s+up...\")"
    },
    {
      "file": "src/mcp_manager/fusion/tool_enhancer.rs",
      "line": 28,
      "code": "(Regex::new(r\"^docker-compose\\s+down\").unwrap(), \"compose_down\"),",
      "context": [
        "        (Regex::new(r\"^docker\\s+logs\").unwrap(), \"get_logs\"),",
        "        (Regex::new(r\"^docker\\s+exec\").unwrap(), \"exec_command\"),",
        "        (Regex::new(r\"^docker\\s+stop\").unwrap(), \"stop_container\"),",
        "        (Regex::new(r\"^docker\\s+rm\").unwrap(), \"remove_container\"),",
        "        (Regex::new(r\"^docker-compose\\s+up\").unwrap(), \"compose_up\"),",
        "        (Regex::new(r\"^docker-compose\\s+down\").unwrap(), \"compose_down\"),",
        "    ];",
        "",
        "    /// Git/GitHub command patterns",
        "    static ref GIT_PATTERNS: Vec<(Regex, &'static str)> = vec![",
        "        (Regex::new(r\"^git\\s+status\").unwrap(), \"get_status\"),"
      ],
      "suggestion": "Use .expect(\"Invalid regex pattern: ^docker-compose\\s+do...\")"
    },
    {
      "file": "src/mcp_manager/fusion/tool_enhancer.rs",
      "line": 33,
      "code": "(Regex::new(r\"^git\\s+status\").unwrap(), \"get_status\"),",
      "context": [
        "        (Regex::new(r\"^docker-compose\\s+down\").unwrap(), \"compose_down\"),",
        "    ];",
        "",
        "    /// Git/GitHub command patterns",
        "    static ref GIT_PATTERNS: Vec<(Regex, &'static str)> = vec![",
        "        (Regex::new(r\"^git\\s+status\").unwrap(), \"get_status\"),",
        "        (Regex::new(r\"^git\\s+log\").unwrap(), \"get_commits\"),",
        "        (Regex::new(r\"^git\\s+diff\").unwrap(), \"get_diff\"),",
        "        (Regex::new(r\"^git\\s+add\").unwrap(), \"stage_files\"),",
        "        (Regex::new(r\"^git\\s+commit\").unwrap(), \"create_commit\"),",
        "        (Regex::new(r\"^git\\s+push\").unwrap(), \"push_changes\"),"
      ],
      "suggestion": "Use .expect(\"Invalid regex pattern: ^git\\s+status...\")"
    },
    {
      "file": "src/mcp_manager/fusion/tool_enhancer.rs",
      "line": 34,
      "code": "(Regex::new(r\"^git\\s+log\").unwrap(), \"get_commits\"),",
      "context": [
        "    ];",
        "",
        "    /// Git/GitHub command patterns",
        "    static ref GIT_PATTERNS: Vec<(Regex, &'static str)> = vec![",
        "        (Regex::new(r\"^git\\s+status\").unwrap(), \"get_status\"),",
        "        (Regex::new(r\"^git\\s+log\").unwrap(), \"get_commits\"),",
        "        (Regex::new(r\"^git\\s+diff\").unwrap(), \"get_diff\"),",
        "        (Regex::new(r\"^git\\s+add\").unwrap(), \"stage_files\"),",
        "        (Regex::new(r\"^git\\s+commit\").unwrap(), \"create_commit\"),",
        "        (Regex::new(r\"^git\\s+push\").unwrap(), \"push_changes\"),",
        "        (Regex::new(r\"^git\\s+pull\").unwrap(), \"pull_changes\"),"
      ],
      "suggestion": "Use .expect(\"Invalid regex pattern: ^git\\s+log...\")"
    },
    {
      "file": "src/mcp_manager/fusion/tool_enhancer.rs",
      "line": 35,
      "code": "(Regex::new(r\"^git\\s+diff\").unwrap(), \"get_diff\"),",
      "context": [
        "",
        "    /// Git/GitHub command patterns",
        "    static ref GIT_PATTERNS: Vec<(Regex, &'static str)> = vec![",
        "        (Regex::new(r\"^git\\s+status\").unwrap(), \"get_status\"),",
        "        (Regex::new(r\"^git\\s+log\").unwrap(), \"get_commits\"),",
        "        (Regex::new(r\"^git\\s+diff\").unwrap(), \"get_diff\"),",
        "        (Regex::new(r\"^git\\s+add\").unwrap(), \"stage_files\"),",
        "        (Regex::new(r\"^git\\s+commit\").unwrap(), \"create_commit\"),",
        "        (Regex::new(r\"^git\\s+push\").unwrap(), \"push_changes\"),",
        "        (Regex::new(r\"^git\\s+pull\").unwrap(), \"pull_changes\"),",
        "        (Regex::new(r\"^gh\\s+pr\\s+create\").unwrap(), \"create_pull_request\"),"
      ],
      "suggestion": "Use .expect(\"Invalid regex pattern: ^git\\s+diff...\")"
    },
    {
      "file": "src/mcp_manager/fusion/tool_enhancer.rs",
      "line": 36,
      "code": "(Regex::new(r\"^git\\s+add\").unwrap(), \"stage_files\"),",
      "context": [
        "    /// Git/GitHub command patterns",
        "    static ref GIT_PATTERNS: Vec<(Regex, &'static str)> = vec![",
        "        (Regex::new(r\"^git\\s+status\").unwrap(), \"get_status\"),",
        "        (Regex::new(r\"^git\\s+log\").unwrap(), \"get_commits\"),",
        "        (Regex::new(r\"^git\\s+diff\").unwrap(), \"get_diff\"),",
        "        (Regex::new(r\"^git\\s+add\").unwrap(), \"stage_files\"),",
        "        (Regex::new(r\"^git\\s+commit\").unwrap(), \"create_commit\"),",
        "        (Regex::new(r\"^git\\s+push\").unwrap(), \"push_changes\"),",
        "        (Regex::new(r\"^git\\s+pull\").unwrap(), \"pull_changes\"),",
        "        (Regex::new(r\"^gh\\s+pr\\s+create\").unwrap(), \"create_pull_request\"),",
        "        (Regex::new(r\"^gh\\s+issue\\s+create\").unwrap(), \"create_issue\"),"
      ],
      "suggestion": "Use .expect(\"Invalid regex pattern: ^git\\s+add...\")"
    },
    {
      "file": "src/mcp_manager/fusion/tool_enhancer.rs",
      "line": 37,
      "code": "(Regex::new(r\"^git\\s+commit\").unwrap(), \"create_commit\"),",
      "context": [
        "    static ref GIT_PATTERNS: Vec<(Regex, &'static str)> = vec![",
        "        (Regex::new(r\"^git\\s+status\").unwrap(), \"get_status\"),",
        "        (Regex::new(r\"^git\\s+log\").unwrap(), \"get_commits\"),",
        "        (Regex::new(r\"^git\\s+diff\").unwrap(), \"get_diff\"),",
        "        (Regex::new(r\"^git\\s+add\").unwrap(), \"stage_files\"),",
        "        (Regex::new(r\"^git\\s+commit\").unwrap(), \"create_commit\"),",
        "        (Regex::new(r\"^git\\s+push\").unwrap(), \"push_changes\"),",
        "        (Regex::new(r\"^git\\s+pull\").unwrap(), \"pull_changes\"),",
        "        (Regex::new(r\"^gh\\s+pr\\s+create\").unwrap(), \"create_pull_request\"),",
        "        (Regex::new(r\"^gh\\s+issue\\s+create\").unwrap(), \"create_issue\"),",
        "        (Regex::new(r\"^gh\\s+release\\s+create\").unwrap(), \"create_release\"),"
      ],
      "suggestion": "Use .expect(\"Invalid regex pattern: ^git\\s+commit...\")"
    },
    {
      "file": "src/mcp_manager/fusion/tool_enhancer.rs",
      "line": 38,
      "code": "(Regex::new(r\"^git\\s+push\").unwrap(), \"push_changes\"),",
      "context": [
        "        (Regex::new(r\"^git\\s+status\").unwrap(), \"get_status\"),",
        "        (Regex::new(r\"^git\\s+log\").unwrap(), \"get_commits\"),",
        "        (Regex::new(r\"^git\\s+diff\").unwrap(), \"get_diff\"),",
        "        (Regex::new(r\"^git\\s+add\").unwrap(), \"stage_files\"),",
        "        (Regex::new(r\"^git\\s+commit\").unwrap(), \"create_commit\"),",
        "        (Regex::new(r\"^git\\s+push\").unwrap(), \"push_changes\"),",
        "        (Regex::new(r\"^git\\s+pull\").unwrap(), \"pull_changes\"),",
        "        (Regex::new(r\"^gh\\s+pr\\s+create\").unwrap(), \"create_pull_request\"),",
        "        (Regex::new(r\"^gh\\s+issue\\s+create\").unwrap(), \"create_issue\"),",
        "        (Regex::new(r\"^gh\\s+release\\s+create\").unwrap(), \"create_release\"),",
        "    ];"
      ],
      "suggestion": "Use .expect(\"Invalid regex pattern: ^git\\s+push...\")"
    },
    {
      "file": "src/mcp_manager/fusion/tool_enhancer.rs",
      "line": 39,
      "code": "(Regex::new(r\"^git\\s+pull\").unwrap(), \"pull_changes\"),",
      "context": [
        "        (Regex::new(r\"^git\\s+log\").unwrap(), \"get_commits\"),",
        "        (Regex::new(r\"^git\\s+diff\").unwrap(), \"get_diff\"),",
        "        (Regex::new(r\"^git\\s+add\").unwrap(), \"stage_files\"),",
        "        (Regex::new(r\"^git\\s+commit\").unwrap(), \"create_commit\"),",
        "        (Regex::new(r\"^git\\s+push\").unwrap(), \"push_changes\"),",
        "        (Regex::new(r\"^git\\s+pull\").unwrap(), \"pull_changes\"),",
        "        (Regex::new(r\"^gh\\s+pr\\s+create\").unwrap(), \"create_pull_request\"),",
        "        (Regex::new(r\"^gh\\s+issue\\s+create\").unwrap(), \"create_issue\"),",
        "        (Regex::new(r\"^gh\\s+release\\s+create\").unwrap(), \"create_release\"),",
        "    ];",
        ""
      ],
      "suggestion": "Use .expect(\"Invalid regex pattern: ^git\\s+pull...\")"
    },
    {
      "file": "src/mcp_manager/fusion/tool_enhancer.rs",
      "line": 40,
      "code": "(Regex::new(r\"^gh\\s+pr\\s+create\").unwrap(), \"create_pull_request\"),",
      "context": [
        "        (Regex::new(r\"^git\\s+diff\").unwrap(), \"get_diff\"),",
        "        (Regex::new(r\"^git\\s+add\").unwrap(), \"stage_files\"),",
        "        (Regex::new(r\"^git\\s+commit\").unwrap(), \"create_commit\"),",
        "        (Regex::new(r\"^git\\s+push\").unwrap(), \"push_changes\"),",
        "        (Regex::new(r\"^git\\s+pull\").unwrap(), \"pull_changes\"),",
        "        (Regex::new(r\"^gh\\s+pr\\s+create\").unwrap(), \"create_pull_request\"),",
        "        (Regex::new(r\"^gh\\s+issue\\s+create\").unwrap(), \"create_issue\"),",
        "        (Regex::new(r\"^gh\\s+release\\s+create\").unwrap(), \"create_release\"),",
        "    ];",
        "",
        "    /// File operation patterns"
      ],
      "suggestion": "Use .expect(\"Invalid regex pattern: ^gh\\s+pr\\s+create...\")"
    },
    {
      "file": "src/mcp_manager/fusion/tool_enhancer.rs",
      "line": 41,
      "code": "(Regex::new(r\"^gh\\s+issue\\s+create\").unwrap(), \"create_issue\"),",
      "context": [
        "        (Regex::new(r\"^git\\s+add\").unwrap(), \"stage_files\"),",
        "        (Regex::new(r\"^git\\s+commit\").unwrap(), \"create_commit\"),",
        "        (Regex::new(r\"^git\\s+push\").unwrap(), \"push_changes\"),",
        "        (Regex::new(r\"^git\\s+pull\").unwrap(), \"pull_changes\"),",
        "        (Regex::new(r\"^gh\\s+pr\\s+create\").unwrap(), \"create_pull_request\"),",
        "        (Regex::new(r\"^gh\\s+issue\\s+create\").unwrap(), \"create_issue\"),",
        "        (Regex::new(r\"^gh\\s+release\\s+create\").unwrap(), \"create_release\"),",
        "    ];",
        "",
        "    /// File operation patterns",
        "    static ref FILE_PATTERNS: Vec<(Regex, &'static str)> = vec!["
      ],
      "suggestion": "Use .expect(\"Invalid regex pattern: ^gh\\s+issue\\s+create...\")"
    },
    {
      "file": "src/mcp_manager/fusion/tool_enhancer.rs",
      "line": 42,
      "code": "(Regex::new(r\"^gh\\s+release\\s+create\").unwrap(), \"create_release\"),",
      "context": [
        "        (Regex::new(r\"^git\\s+commit\").unwrap(), \"create_commit\"),",
        "        (Regex::new(r\"^git\\s+push\").unwrap(), \"push_changes\"),",
        "        (Regex::new(r\"^git\\s+pull\").unwrap(), \"pull_changes\"),",
        "        (Regex::new(r\"^gh\\s+pr\\s+create\").unwrap(), \"create_pull_request\"),",
        "        (Regex::new(r\"^gh\\s+issue\\s+create\").unwrap(), \"create_issue\"),",
        "        (Regex::new(r\"^gh\\s+release\\s+create\").unwrap(), \"create_release\"),",
        "    ];",
        "",
        "    /// File operation patterns",
        "    static ref FILE_PATTERNS: Vec<(Regex, &'static str)> = vec![",
        "        (Regex::new(r\"^ls\\s+\").unwrap(), \"list_directory\"),"
      ],
      "suggestion": "Use .expect(\"Invalid regex pattern: ^gh\\s+release\\s+crea...\")"
    },
    {
      "file": "src/mcp_manager/fusion/tool_enhancer.rs",
      "line": 47,
      "code": "(Regex::new(r\"^ls\\s+\").unwrap(), \"list_directory\"),",
      "context": [
        "        (Regex::new(r\"^gh\\s+release\\s+create\").unwrap(), \"create_release\"),",
        "    ];",
        "",
        "    /// File operation patterns",
        "    static ref FILE_PATTERNS: Vec<(Regex, &'static str)> = vec![",
        "        (Regex::new(r\"^ls\\s+\").unwrap(), \"list_directory\"),",
        "        (Regex::new(r\"^cat\\s+\").unwrap(), \"read_file\"),",
        "        (Regex::new(r\"^grep\\s+\").unwrap(), \"search_files\"),",
        "        (Regex::new(r\"^find\\s+\").unwrap(), \"find_files\"),",
        "        (Regex::new(r\"^cp\\s+\").unwrap(), \"copy_file\"),",
        "        (Regex::new(r\"^mv\\s+\").unwrap(), \"move_file\"),"
      ],
      "suggestion": "Use .expect(\"Invalid regex pattern: ^ls\\s+...\")"
    },
    {
      "file": "src/mcp_manager/fusion/tool_enhancer.rs",
      "line": 48,
      "code": "(Regex::new(r\"^cat\\s+\").unwrap(), \"read_file\"),",
      "context": [
        "    ];",
        "",
        "    /// File operation patterns",
        "    static ref FILE_PATTERNS: Vec<(Regex, &'static str)> = vec![",
        "        (Regex::new(r\"^ls\\s+\").unwrap(), \"list_directory\"),",
        "        (Regex::new(r\"^cat\\s+\").unwrap(), \"read_file\"),",
        "        (Regex::new(r\"^grep\\s+\").unwrap(), \"search_files\"),",
        "        (Regex::new(r\"^find\\s+\").unwrap(), \"find_files\"),",
        "        (Regex::new(r\"^cp\\s+\").unwrap(), \"copy_file\"),",
        "        (Regex::new(r\"^mv\\s+\").unwrap(), \"move_file\"),",
        "        (Regex::new(r\"^rm\\s+\").unwrap(), \"delete_file\"),"
      ],
      "suggestion": "Use .expect(\"Invalid regex pattern: ^cat\\s+...\")"
    },
    {
      "file": "src/mcp_manager/fusion/tool_enhancer.rs",
      "line": 49,
      "code": "(Regex::new(r\"^grep\\s+\").unwrap(), \"search_files\"),",
      "context": [
        "",
        "    /// File operation patterns",
        "    static ref FILE_PATTERNS: Vec<(Regex, &'static str)> = vec![",
        "        (Regex::new(r\"^ls\\s+\").unwrap(), \"list_directory\"),",
        "        (Regex::new(r\"^cat\\s+\").unwrap(), \"read_file\"),",
        "        (Regex::new(r\"^grep\\s+\").unwrap(), \"search_files\"),",
        "        (Regex::new(r\"^find\\s+\").unwrap(), \"find_files\"),",
        "        (Regex::new(r\"^cp\\s+\").unwrap(), \"copy_file\"),",
        "        (Regex::new(r\"^mv\\s+\").unwrap(), \"move_file\"),",
        "        (Regex::new(r\"^rm\\s+\").unwrap(), \"delete_file\"),",
        "        (Regex::new(r\"^mkdir\\s+\").unwrap(), \"create_directory\"),"
      ],
      "suggestion": "Use .expect(\"Invalid regex pattern: ^grep\\s+...\")"
    },
    {
      "file": "src/mcp_manager/fusion/tool_enhancer.rs",
      "line": 50,
      "code": "(Regex::new(r\"^find\\s+\").unwrap(), \"find_files\"),",
      "context": [
        "    /// File operation patterns",
        "    static ref FILE_PATTERNS: Vec<(Regex, &'static str)> = vec![",
        "        (Regex::new(r\"^ls\\s+\").unwrap(), \"list_directory\"),",
        "        (Regex::new(r\"^cat\\s+\").unwrap(), \"read_file\"),",
        "        (Regex::new(r\"^grep\\s+\").unwrap(), \"search_files\"),",
        "        (Regex::new(r\"^find\\s+\").unwrap(), \"find_files\"),",
        "        (Regex::new(r\"^cp\\s+\").unwrap(), \"copy_file\"),",
        "        (Regex::new(r\"^mv\\s+\").unwrap(), \"move_file\"),",
        "        (Regex::new(r\"^rm\\s+\").unwrap(), \"delete_file\"),",
        "        (Regex::new(r\"^mkdir\\s+\").unwrap(), \"create_directory\"),",
        "        (Regex::new(r\"^touch\\s+\").unwrap(), \"create_file\"),"
      ],
      "suggestion": "Use .expect(\"Invalid regex pattern: ^find\\s+...\")"
    },
    {
      "file": "src/mcp_manager/fusion/tool_enhancer.rs",
      "line": 51,
      "code": "(Regex::new(r\"^cp\\s+\").unwrap(), \"copy_file\"),",
      "context": [
        "    static ref FILE_PATTERNS: Vec<(Regex, &'static str)> = vec![",
        "        (Regex::new(r\"^ls\\s+\").unwrap(), \"list_directory\"),",
        "        (Regex::new(r\"^cat\\s+\").unwrap(), \"read_file\"),",
        "        (Regex::new(r\"^grep\\s+\").unwrap(), \"search_files\"),",
        "        (Regex::new(r\"^find\\s+\").unwrap(), \"find_files\"),",
        "        (Regex::new(r\"^cp\\s+\").unwrap(), \"copy_file\"),",
        "        (Regex::new(r\"^mv\\s+\").unwrap(), \"move_file\"),",
        "        (Regex::new(r\"^rm\\s+\").unwrap(), \"delete_file\"),",
        "        (Regex::new(r\"^mkdir\\s+\").unwrap(), \"create_directory\"),",
        "        (Regex::new(r\"^touch\\s+\").unwrap(), \"create_file\"),",
        "        (Regex::new(r\"^chmod\\s+\").unwrap(), \"change_permissions\"),"
      ],
      "suggestion": "Use .expect(\"Invalid regex pattern: ^cp\\s+...\")"
    },
    {
      "file": "src/mcp_manager/fusion/tool_enhancer.rs",
      "line": 52,
      "code": "(Regex::new(r\"^mv\\s+\").unwrap(), \"move_file\"),",
      "context": [
        "        (Regex::new(r\"^ls\\s+\").unwrap(), \"list_directory\"),",
        "        (Regex::new(r\"^cat\\s+\").unwrap(), \"read_file\"),",
        "        (Regex::new(r\"^grep\\s+\").unwrap(), \"search_files\"),",
        "        (Regex::new(r\"^find\\s+\").unwrap(), \"find_files\"),",
        "        (Regex::new(r\"^cp\\s+\").unwrap(), \"copy_file\"),",
        "        (Regex::new(r\"^mv\\s+\").unwrap(), \"move_file\"),",
        "        (Regex::new(r\"^rm\\s+\").unwrap(), \"delete_file\"),",
        "        (Regex::new(r\"^mkdir\\s+\").unwrap(), \"create_directory\"),",
        "        (Regex::new(r\"^touch\\s+\").unwrap(), \"create_file\"),",
        "        (Regex::new(r\"^chmod\\s+\").unwrap(), \"change_permissions\"),",
        "    ];"
      ],
      "suggestion": "Use .expect(\"Invalid regex pattern: ^mv\\s+...\")"
    },
    {
      "file": "src/mcp_manager/fusion/tool_enhancer.rs",
      "line": 53,
      "code": "(Regex::new(r\"^rm\\s+\").unwrap(), \"delete_file\"),",
      "context": [
        "        (Regex::new(r\"^cat\\s+\").unwrap(), \"read_file\"),",
        "        (Regex::new(r\"^grep\\s+\").unwrap(), \"search_files\"),",
        "        (Regex::new(r\"^find\\s+\").unwrap(), \"find_files\"),",
        "        (Regex::new(r\"^cp\\s+\").unwrap(), \"copy_file\"),",
        "        (Regex::new(r\"^mv\\s+\").unwrap(), \"move_file\"),",
        "        (Regex::new(r\"^rm\\s+\").unwrap(), \"delete_file\"),",
        "        (Regex::new(r\"^mkdir\\s+\").unwrap(), \"create_directory\"),",
        "        (Regex::new(r\"^touch\\s+\").unwrap(), \"create_file\"),",
        "        (Regex::new(r\"^chmod\\s+\").unwrap(), \"change_permissions\"),",
        "    ];",
        ""
      ],
      "suggestion": "Use .expect(\"Invalid regex pattern: ^rm\\s+...\")"
    },
    {
      "file": "src/mcp_manager/fusion/tool_enhancer.rs",
      "line": 54,
      "code": "(Regex::new(r\"^mkdir\\s+\").unwrap(), \"create_directory\"),",
      "context": [
        "        (Regex::new(r\"^grep\\s+\").unwrap(), \"search_files\"),",
        "        (Regex::new(r\"^find\\s+\").unwrap(), \"find_files\"),",
        "        (Regex::new(r\"^cp\\s+\").unwrap(), \"copy_file\"),",
        "        (Regex::new(r\"^mv\\s+\").unwrap(), \"move_file\"),",
        "        (Regex::new(r\"^rm\\s+\").unwrap(), \"delete_file\"),",
        "        (Regex::new(r\"^mkdir\\s+\").unwrap(), \"create_directory\"),",
        "        (Regex::new(r\"^touch\\s+\").unwrap(), \"create_file\"),",
        "        (Regex::new(r\"^chmod\\s+\").unwrap(), \"change_permissions\"),",
        "    ];",
        "",
        "    /// Kubernetes command patterns"
      ],
      "suggestion": "Use .expect(\"Invalid regex pattern: ^mkdir\\s+...\")"
    },
    {
      "file": "src/mcp_manager/fusion/tool_enhancer.rs",
      "line": 55,
      "code": "(Regex::new(r\"^touch\\s+\").unwrap(), \"create_file\"),",
      "context": [
        "        (Regex::new(r\"^find\\s+\").unwrap(), \"find_files\"),",
        "        (Regex::new(r\"^cp\\s+\").unwrap(), \"copy_file\"),",
        "        (Regex::new(r\"^mv\\s+\").unwrap(), \"move_file\"),",
        "        (Regex::new(r\"^rm\\s+\").unwrap(), \"delete_file\"),",
        "        (Regex::new(r\"^mkdir\\s+\").unwrap(), \"create_directory\"),",
        "        (Regex::new(r\"^touch\\s+\").unwrap(), \"create_file\"),",
        "        (Regex::new(r\"^chmod\\s+\").unwrap(), \"change_permissions\"),",
        "    ];",
        "",
        "    /// Kubernetes command patterns",
        "    static ref K8S_PATTERNS: Vec<(Regex, &'static str)> = vec!["
      ],
      "suggestion": "Use .expect(\"Invalid regex pattern: ^touch\\s+...\")"
    },
    {
      "file": "src/mcp_manager/fusion/tool_enhancer.rs",
      "line": 56,
      "code": "(Regex::new(r\"^chmod\\s+\").unwrap(), \"change_permissions\"),",
      "context": [
        "        (Regex::new(r\"^cp\\s+\").unwrap(), \"copy_file\"),",
        "        (Regex::new(r\"^mv\\s+\").unwrap(), \"move_file\"),",
        "        (Regex::new(r\"^rm\\s+\").unwrap(), \"delete_file\"),",
        "        (Regex::new(r\"^mkdir\\s+\").unwrap(), \"create_directory\"),",
        "        (Regex::new(r\"^touch\\s+\").unwrap(), \"create_file\"),",
        "        (Regex::new(r\"^chmod\\s+\").unwrap(), \"change_permissions\"),",
        "    ];",
        "",
        "    /// Kubernetes command patterns",
        "    static ref K8S_PATTERNS: Vec<(Regex, &'static str)> = vec![",
        "        (Regex::new(r\"^kubectl\\s+get\\s+pods\").unwrap(), \"list_pods\"),"
      ],
      "suggestion": "Use .expect(\"Invalid regex pattern: ^chmod\\s+...\")"
    },
    {
      "file": "src/mcp_manager/fusion/tool_enhancer.rs",
      "line": 61,
      "code": "(Regex::new(r\"^kubectl\\s+get\\s+pods\").unwrap(), \"list_pods\"),",
      "context": [
        "        (Regex::new(r\"^chmod\\s+\").unwrap(), \"change_permissions\"),",
        "    ];",
        "",
        "    /// Kubernetes command patterns",
        "    static ref K8S_PATTERNS: Vec<(Regex, &'static str)> = vec![",
        "        (Regex::new(r\"^kubectl\\s+get\\s+pods\").unwrap(), \"list_pods\"),",
        "        (Regex::new(r\"^kubectl\\s+get\\s+services\").unwrap(), \"list_services\"),",
        "        (Regex::new(r\"^kubectl\\s+apply\").unwrap(), \"apply_manifest\"),",
        "        (Regex::new(r\"^kubectl\\s+delete\").unwrap(), \"delete_resource\"),",
        "        (Regex::new(r\"^kubectl\\s+logs\").unwrap(), \"get_pod_logs\"),",
        "        (Regex::new(r\"^kubectl\\s+exec\").unwrap(), \"exec_in_pod\"),"
      ],
      "suggestion": "Use .expect(\"Invalid regex pattern: ^kubectl\\s+get\\s+pod...\")"
    },
    {
      "file": "src/mcp_manager/fusion/tool_enhancer.rs",
      "line": 62,
      "code": "(Regex::new(r\"^kubectl\\s+get\\s+services\").unwrap(), \"list_services\"),",
      "context": [
        "    ];",
        "",
        "    /// Kubernetes command patterns",
        "    static ref K8S_PATTERNS: Vec<(Regex, &'static str)> = vec![",
        "        (Regex::new(r\"^kubectl\\s+get\\s+pods\").unwrap(), \"list_pods\"),",
        "        (Regex::new(r\"^kubectl\\s+get\\s+services\").unwrap(), \"list_services\"),",
        "        (Regex::new(r\"^kubectl\\s+apply\").unwrap(), \"apply_manifest\"),",
        "        (Regex::new(r\"^kubectl\\s+delete\").unwrap(), \"delete_resource\"),",
        "        (Regex::new(r\"^kubectl\\s+logs\").unwrap(), \"get_pod_logs\"),",
        "        (Regex::new(r\"^kubectl\\s+exec\").unwrap(), \"exec_in_pod\"),",
        "        (Regex::new(r\"^kubectl\\s+describe\").unwrap(), \"describe_resource\"),"
      ],
      "suggestion": "Use .expect(\"Invalid regex pattern: ^kubectl\\s+get\\s+ser...\")"
    },
    {
      "file": "src/mcp_manager/fusion/tool_enhancer.rs",
      "line": 63,
      "code": "(Regex::new(r\"^kubectl\\s+apply\").unwrap(), \"apply_manifest\"),",
      "context": [
        "",
        "    /// Kubernetes command patterns",
        "    static ref K8S_PATTERNS: Vec<(Regex, &'static str)> = vec![",
        "        (Regex::new(r\"^kubectl\\s+get\\s+pods\").unwrap(), \"list_pods\"),",
        "        (Regex::new(r\"^kubectl\\s+get\\s+services\").unwrap(), \"list_services\"),",
        "        (Regex::new(r\"^kubectl\\s+apply\").unwrap(), \"apply_manifest\"),",
        "        (Regex::new(r\"^kubectl\\s+delete\").unwrap(), \"delete_resource\"),",
        "        (Regex::new(r\"^kubectl\\s+logs\").unwrap(), \"get_pod_logs\"),",
        "        (Regex::new(r\"^kubectl\\s+exec\").unwrap(), \"exec_in_pod\"),",
        "        (Regex::new(r\"^kubectl\\s+describe\").unwrap(), \"describe_resource\"),",
        "        (Regex::new(r\"^kubectl\\s+rollout\").unwrap(), \"manage_rollout\"),"
      ],
      "suggestion": "Use .expect(\"Invalid regex pattern: ^kubectl\\s+apply...\")"
    },
    {
      "file": "src/mcp_manager/fusion/tool_enhancer.rs",
      "line": 64,
      "code": "(Regex::new(r\"^kubectl\\s+delete\").unwrap(), \"delete_resource\"),",
      "context": [
        "    /// Kubernetes command patterns",
        "    static ref K8S_PATTERNS: Vec<(Regex, &'static str)> = vec![",
        "        (Regex::new(r\"^kubectl\\s+get\\s+pods\").unwrap(), \"list_pods\"),",
        "        (Regex::new(r\"^kubectl\\s+get\\s+services\").unwrap(), \"list_services\"),",
        "        (Regex::new(r\"^kubectl\\s+apply\").unwrap(), \"apply_manifest\"),",
        "        (Regex::new(r\"^kubectl\\s+delete\").unwrap(), \"delete_resource\"),",
        "        (Regex::new(r\"^kubectl\\s+logs\").unwrap(), \"get_pod_logs\"),",
        "        (Regex::new(r\"^kubectl\\s+exec\").unwrap(), \"exec_in_pod\"),",
        "        (Regex::new(r\"^kubectl\\s+describe\").unwrap(), \"describe_resource\"),",
        "        (Regex::new(r\"^kubectl\\s+rollout\").unwrap(), \"manage_rollout\"),",
        "        (Regex::new(r\"^helm\\s+install\").unwrap(), \"helm_install\"),"
      ],
      "suggestion": "Use .expect(\"Invalid regex pattern: ^kubectl\\s+delete...\")"
    },
    {
      "file": "src/mcp_manager/fusion/tool_enhancer.rs",
      "line": 65,
      "code": "(Regex::new(r\"^kubectl\\s+logs\").unwrap(), \"get_pod_logs\"),",
      "context": [
        "    static ref K8S_PATTERNS: Vec<(Regex, &'static str)> = vec![",
        "        (Regex::new(r\"^kubectl\\s+get\\s+pods\").unwrap(), \"list_pods\"),",
        "        (Regex::new(r\"^kubectl\\s+get\\s+services\").unwrap(), \"list_services\"),",
        "        (Regex::new(r\"^kubectl\\s+apply\").unwrap(), \"apply_manifest\"),",
        "        (Regex::new(r\"^kubectl\\s+delete\").unwrap(), \"delete_resource\"),",
        "        (Regex::new(r\"^kubectl\\s+logs\").unwrap(), \"get_pod_logs\"),",
        "        (Regex::new(r\"^kubectl\\s+exec\").unwrap(), \"exec_in_pod\"),",
        "        (Regex::new(r\"^kubectl\\s+describe\").unwrap(), \"describe_resource\"),",
        "        (Regex::new(r\"^kubectl\\s+rollout\").unwrap(), \"manage_rollout\"),",
        "        (Regex::new(r\"^helm\\s+install\").unwrap(), \"helm_install\"),",
        "        (Regex::new(r\"^helm\\s+upgrade\").unwrap(), \"helm_upgrade\"),"
      ],
      "suggestion": "Use .expect(\"Invalid regex pattern: ^kubectl\\s+logs...\")"
    },
    {
      "file": "src/mcp_manager/fusion/tool_enhancer.rs",
      "line": 66,
      "code": "(Regex::new(r\"^kubectl\\s+exec\").unwrap(), \"exec_in_pod\"),",
      "context": [
        "        (Regex::new(r\"^kubectl\\s+get\\s+pods\").unwrap(), \"list_pods\"),",
        "        (Regex::new(r\"^kubectl\\s+get\\s+services\").unwrap(), \"list_services\"),",
        "        (Regex::new(r\"^kubectl\\s+apply\").unwrap(), \"apply_manifest\"),",
        "        (Regex::new(r\"^kubectl\\s+delete\").unwrap(), \"delete_resource\"),",
        "        (Regex::new(r\"^kubectl\\s+logs\").unwrap(), \"get_pod_logs\"),",
        "        (Regex::new(r\"^kubectl\\s+exec\").unwrap(), \"exec_in_pod\"),",
        "        (Regex::new(r\"^kubectl\\s+describe\").unwrap(), \"describe_resource\"),",
        "        (Regex::new(r\"^kubectl\\s+rollout\").unwrap(), \"manage_rollout\"),",
        "        (Regex::new(r\"^helm\\s+install\").unwrap(), \"helm_install\"),",
        "        (Regex::new(r\"^helm\\s+upgrade\").unwrap(), \"helm_upgrade\"),",
        "    ];"
      ],
      "suggestion": "Use .expect(\"Invalid regex pattern: ^kubectl\\s+exec...\")"
    },
    {
      "file": "src/mcp_manager/fusion/tool_enhancer.rs",
      "line": 67,
      "code": "(Regex::new(r\"^kubectl\\s+describe\").unwrap(), \"describe_resource\"),",
      "context": [
        "        (Regex::new(r\"^kubectl\\s+get\\s+services\").unwrap(), \"list_services\"),",
        "        (Regex::new(r\"^kubectl\\s+apply\").unwrap(), \"apply_manifest\"),",
        "        (Regex::new(r\"^kubectl\\s+delete\").unwrap(), \"delete_resource\"),",
        "        (Regex::new(r\"^kubectl\\s+logs\").unwrap(), \"get_pod_logs\"),",
        "        (Regex::new(r\"^kubectl\\s+exec\").unwrap(), \"exec_in_pod\"),",
        "        (Regex::new(r\"^kubectl\\s+describe\").unwrap(), \"describe_resource\"),",
        "        (Regex::new(r\"^kubectl\\s+rollout\").unwrap(), \"manage_rollout\"),",
        "        (Regex::new(r\"^helm\\s+install\").unwrap(), \"helm_install\"),",
        "        (Regex::new(r\"^helm\\s+upgrade\").unwrap(), \"helm_upgrade\"),",
        "    ];",
        ""
      ],
      "suggestion": "Use .expect(\"Invalid regex pattern: ^kubectl\\s+describe...\")"
    },
    {
      "file": "src/mcp_manager/fusion/tool_enhancer.rs",
      "line": 68,
      "code": "(Regex::new(r\"^kubectl\\s+rollout\").unwrap(), \"manage_rollout\"),",
      "context": [
        "        (Regex::new(r\"^kubectl\\s+apply\").unwrap(), \"apply_manifest\"),",
        "        (Regex::new(r\"^kubectl\\s+delete\").unwrap(), \"delete_resource\"),",
        "        (Regex::new(r\"^kubectl\\s+logs\").unwrap(), \"get_pod_logs\"),",
        "        (Regex::new(r\"^kubectl\\s+exec\").unwrap(), \"exec_in_pod\"),",
        "        (Regex::new(r\"^kubectl\\s+describe\").unwrap(), \"describe_resource\"),",
        "        (Regex::new(r\"^kubectl\\s+rollout\").unwrap(), \"manage_rollout\"),",
        "        (Regex::new(r\"^helm\\s+install\").unwrap(), \"helm_install\"),",
        "        (Regex::new(r\"^helm\\s+upgrade\").unwrap(), \"helm_upgrade\"),",
        "    ];",
        "",
        "    /// Monitoring command patterns"
      ],
      "suggestion": "Use .expect(\"Invalid regex pattern: ^kubectl\\s+rollout...\")"
    },
    {
      "file": "src/mcp_manager/fusion/tool_enhancer.rs",
      "line": 69,
      "code": "(Regex::new(r\"^helm\\s+install\").unwrap(), \"helm_install\"),",
      "context": [
        "        (Regex::new(r\"^kubectl\\s+delete\").unwrap(), \"delete_resource\"),",
        "        (Regex::new(r\"^kubectl\\s+logs\").unwrap(), \"get_pod_logs\"),",
        "        (Regex::new(r\"^kubectl\\s+exec\").unwrap(), \"exec_in_pod\"),",
        "        (Regex::new(r\"^kubectl\\s+describe\").unwrap(), \"describe_resource\"),",
        "        (Regex::new(r\"^kubectl\\s+rollout\").unwrap(), \"manage_rollout\"),",
        "        (Regex::new(r\"^helm\\s+install\").unwrap(), \"helm_install\"),",
        "        (Regex::new(r\"^helm\\s+upgrade\").unwrap(), \"helm_upgrade\"),",
        "    ];",
        "",
        "    /// Monitoring command patterns",
        "    static ref MONITORING_PATTERNS: Vec<(Regex, &'static str)> = vec!["
      ],
      "suggestion": "Use .expect(\"Invalid regex pattern: ^helm\\s+install...\")"
    },
    {
      "file": "src/mcp_manager/fusion/tool_enhancer.rs",
      "line": 70,
      "code": "(Regex::new(r\"^helm\\s+upgrade\").unwrap(), \"helm_upgrade\"),",
      "context": [
        "        (Regex::new(r\"^kubectl\\s+logs\").unwrap(), \"get_pod_logs\"),",
        "        (Regex::new(r\"^kubectl\\s+exec\").unwrap(), \"exec_in_pod\"),",
        "        (Regex::new(r\"^kubectl\\s+describe\").unwrap(), \"describe_resource\"),",
        "        (Regex::new(r\"^kubectl\\s+rollout\").unwrap(), \"manage_rollout\"),",
        "        (Regex::new(r\"^helm\\s+install\").unwrap(), \"helm_install\"),",
        "        (Regex::new(r\"^helm\\s+upgrade\").unwrap(), \"helm_upgrade\"),",
        "    ];",
        "",
        "    /// Monitoring command patterns",
        "    static ref MONITORING_PATTERNS: Vec<(Regex, &'static str)> = vec![",
        "        (Regex::new(r\"^curl.*metrics\").unwrap(), \"get_metrics\"),"
      ],
      "suggestion": "Use .expect(\"Invalid regex pattern: ^helm\\s+upgrade...\")"
    },
    {
      "file": "src/mcp_manager/fusion/tool_enhancer.rs",
      "line": 75,
      "code": "(Regex::new(r\"^curl.*metrics\").unwrap(), \"get_metrics\"),",
      "context": [
        "        (Regex::new(r\"^helm\\s+upgrade\").unwrap(), \"helm_upgrade\"),",
        "    ];",
        "",
        "    /// Monitoring command patterns",
        "    static ref MONITORING_PATTERNS: Vec<(Regex, &'static str)> = vec![",
        "        (Regex::new(r\"^curl.*metrics\").unwrap(), \"get_metrics\"),",
        "        (Regex::new(r\"^prometheus.*query\").unwrap(), \"query_prometheus\"),",
        "        (Regex::new(r\"^grafana.*dashboard\").unwrap(), \"manage_dashboard\"),",
        "        (Regex::new(r\"^tail.*log\").unwrap(), \"tail_logs\"),",
        "        (Regex::new(r\"^journalctl\").unwrap(), \"system_logs\"),",
        "    ];"
      ],
      "suggestion": "Use .expect(\"Invalid regex pattern: ^curl.*metrics...\")"
    },
    {
      "file": "src/mcp_manager/fusion/tool_enhancer.rs",
      "line": 76,
      "code": "(Regex::new(r\"^prometheus.*query\").unwrap(), \"query_prometheus\"),",
      "context": [
        "    ];",
        "",
        "    /// Monitoring command patterns",
        "    static ref MONITORING_PATTERNS: Vec<(Regex, &'static str)> = vec![",
        "        (Regex::new(r\"^curl.*metrics\").unwrap(), \"get_metrics\"),",
        "        (Regex::new(r\"^prometheus.*query\").unwrap(), \"query_prometheus\"),",
        "        (Regex::new(r\"^grafana.*dashboard\").unwrap(), \"manage_dashboard\"),",
        "        (Regex::new(r\"^tail.*log\").unwrap(), \"tail_logs\"),",
        "        (Regex::new(r\"^journalctl\").unwrap(), \"system_logs\"),",
        "    ];",
        "}"
      ],
      "suggestion": "Use .expect(\"Invalid regex pattern: ^prometheus.*query...\")"
    },
    {
      "file": "src/mcp_manager/fusion/tool_enhancer.rs",
      "line": 77,
      "code": "(Regex::new(r\"^grafana.*dashboard\").unwrap(), \"manage_dashboard\"),",
      "context": [
        "",
        "    /// Monitoring command patterns",
        "    static ref MONITORING_PATTERNS: Vec<(Regex, &'static str)> = vec![",
        "        (Regex::new(r\"^curl.*metrics\").unwrap(), \"get_metrics\"),",
        "        (Regex::new(r\"^prometheus.*query\").unwrap(), \"query_prometheus\"),",
        "        (Regex::new(r\"^grafana.*dashboard\").unwrap(), \"manage_dashboard\"),",
        "        (Regex::new(r\"^tail.*log\").unwrap(), \"tail_logs\"),",
        "        (Regex::new(r\"^journalctl\").unwrap(), \"system_logs\"),",
        "    ];",
        "}",
        ""
      ],
      "suggestion": "Use .expect(\"Invalid regex pattern: ^grafana.*dashboard...\")"
    },
    {
      "file": "src/mcp_manager/fusion/tool_enhancer.rs",
      "line": 78,
      "code": "(Regex::new(r\"^tail.*log\").unwrap(), \"tail_logs\"),",
      "context": [
        "    /// Monitoring command patterns",
        "    static ref MONITORING_PATTERNS: Vec<(Regex, &'static str)> = vec![",
        "        (Regex::new(r\"^curl.*metrics\").unwrap(), \"get_metrics\"),",
        "        (Regex::new(r\"^prometheus.*query\").unwrap(), \"query_prometheus\"),",
        "        (Regex::new(r\"^grafana.*dashboard\").unwrap(), \"manage_dashboard\"),",
        "        (Regex::new(r\"^tail.*log\").unwrap(), \"tail_logs\"),",
        "        (Regex::new(r\"^journalctl\").unwrap(), \"system_logs\"),",
        "    ];",
        "}",
        "",
        "/// Enhanced command analysis result"
      ],
      "suggestion": "Use .expect(\"Invalid regex pattern: ^tail.*log...\")"
    },
    {
      "file": "src/mcp_manager/fusion/tool_enhancer.rs",
      "line": 79,
      "code": "(Regex::new(r\"^journalctl\").unwrap(), \"system_logs\"),",
      "context": [
        "    static ref MONITORING_PATTERNS: Vec<(Regex, &'static str)> = vec![",
        "        (Regex::new(r\"^curl.*metrics\").unwrap(), \"get_metrics\"),",
        "        (Regex::new(r\"^prometheus.*query\").unwrap(), \"query_prometheus\"),",
        "        (Regex::new(r\"^grafana.*dashboard\").unwrap(), \"manage_dashboard\"),",
        "        (Regex::new(r\"^tail.*log\").unwrap(), \"tail_logs\"),",
        "        (Regex::new(r\"^journalctl\").unwrap(), \"system_logs\"),",
        "    ];",
        "}",
        "",
        "/// Enhanced command analysis result",
        "#[derive(Debug)]"
      ],
      "suggestion": "Use .expect(\"Invalid regex pattern: ^journalctl...\")"
    },
    {
      "file": "src/mcp_manager/optimization/cache.rs",
      "line": 107,
      "code": "let mut storage = self.storage.write().unwrap();",
      "context": [
        "        cache",
        "    }",
        "",
        "    /// Get a value from the cache",
        "    pub async fn get(&self, key: &K) -> Option<V> {",
        "        let mut storage = self.storage.write().unwrap();",
        "",
        "        if let Some(entry) = storage.get_mut(key) {",
        "            // Check TTL",
        "            if let Some(ttl) = entry.ttl {",
        "                if entry.created_at.elapsed() > ttl {"
      ],
      "suggestion": "Replace with .expect(\"descriptive error message\")"
    },
    {
      "file": "src/mcp_manager/optimization/cache.rs",
      "line": 116,
      "code": "self.stats.write().unwrap().expirations += 1;",
      "context": [
        "            if let Some(ttl) = entry.ttl {",
        "                if entry.created_at.elapsed() > ttl {",
        "                    // Entry expired",
        "                    storage.remove(key);",
        "                    self.remove_from_tracking(key).await;",
        "                    self.stats.write().unwrap().expirations += 1;",
        "                    self.stats.write().unwrap().misses += 1;",
        "                    return None;",
        "                }",
        "            }",
        ""
      ],
      "suggestion": "Replace with .expect(\"descriptive error message\")"
    },
    {
      "file": "src/mcp_manager/optimization/cache.rs",
      "line": 117,
      "code": "self.stats.write().unwrap().misses += 1;",
      "context": [
        "                if entry.created_at.elapsed() > ttl {",
        "                    // Entry expired",
        "                    storage.remove(key);",
        "                    self.remove_from_tracking(key).await;",
        "                    self.stats.write().unwrap().expirations += 1;",
        "                    self.stats.write().unwrap().misses += 1;",
        "                    return None;",
        "                }",
        "            }",
        "",
        "            // Update access metadata"
      ],
      "suggestion": "Replace with .expect(\"descriptive error message\")"
    },
    {
      "file": "src/mcp_manager/optimization/cache.rs",
      "line": 129,
      "code": "self.stats.write().unwrap().hits += 1;",
      "context": [
        "            entry.access_count += 1;",
        "",
        "            // Update eviction tracking",
        "            self.update_access_tracking(key.clone()).await;",
        "",
        "            self.stats.write().unwrap().hits += 1;",
        "            Some(entry.value.clone())",
        "        } else {",
        "            self.stats.write().unwrap().misses += 1;",
        "            None",
        "        }"
      ],
      "suggestion": "Replace with .expect(\"descriptive error message\")"
    },
    {
      "file": "src/mcp_manager/optimization/cache.rs",
      "line": 132,
      "code": "self.stats.write().unwrap().misses += 1;",
      "context": [
        "            self.update_access_tracking(key.clone()).await;",
        "",
        "            self.stats.write().unwrap().hits += 1;",
        "            Some(entry.value.clone())",
        "        } else {",
        "            self.stats.write().unwrap().misses += 1;",
        "            None",
        "        }",
        "    }",
        "",
        "    /// Put a value in the cache"
      ],
      "suggestion": "Replace with .expect(\"descriptive error message\")"
    },
    {
      "file": "src/mcp_manager/optimization/cache.rs",
      "line": 165,
      "code": "let mut storage = self.storage.write().unwrap();",
      "context": [
        "            ttl,",
        "            size,",
        "        };",
        "",
        "        // Update storage",
        "        let mut storage = self.storage.write().unwrap();",
        "        let old_entry = storage.insert(key.clone(), entry);",
        "",
        "        // Update stats",
        "        let mut stats = self.stats.write().unwrap();",
        "        stats.entry_count = storage.len();"
      ],
      "suggestion": "Replace with .expect(\"descriptive error message\")"
    },
    {
      "file": "src/mcp_manager/optimization/cache.rs",
      "line": 169,
      "code": "let mut stats = self.stats.write().unwrap();",
      "context": [
        "        // Update storage",
        "        let mut storage = self.storage.write().unwrap();",
        "        let old_entry = storage.insert(key.clone(), entry);",
        "",
        "        // Update stats",
        "        let mut stats = self.stats.write().unwrap();",
        "        stats.entry_count = storage.len();",
        "        stats.total_size += size;",
        "        if let Some(old) = old_entry {",
        "            stats.total_size -= old.size;",
        "        }"
      ],
      "suggestion": "Replace with .expect(\"descriptive error message\")"
    },
    {
      "file": "src/mcp_manager/optimization/cache.rs",
      "line": 186,
      "code": "let mut storage = self.storage.write().unwrap();",
      "context": [
        "        Ok(())",
        "    }",
        "",
        "    /// Remove a value from the cache",
        "    pub async fn remove(&self, key: &K) -> Option<V> {",
        "        let mut storage = self.storage.write().unwrap();",
        "",
        "        if let Some(entry) = storage.remove(key) {",
        "            self.stats.write().unwrap().total_size -= entry.size;",
        "            self.stats.write().unwrap().entry_count -= 1;",
        ""
      ],
      "suggestion": "Replace with .expect(\"descriptive error message\")"
    },
    {
      "file": "src/mcp_manager/optimization/cache.rs",
      "line": 189,
      "code": "self.stats.write().unwrap().total_size -= entry.size;",
      "context": [
        "    /// Remove a value from the cache",
        "    pub async fn remove(&self, key: &K) -> Option<V> {",
        "        let mut storage = self.storage.write().unwrap();",
        "",
        "        if let Some(entry) = storage.remove(key) {",
        "            self.stats.write().unwrap().total_size -= entry.size;",
        "            self.stats.write().unwrap().entry_count -= 1;",
        "",
        "            drop(storage);",
        "            self.remove_from_tracking(key).await;",
        ""
      ],
      "suggestion": "Replace with .expect(\"descriptive error message\")"
    },
    {
      "file": "src/mcp_manager/optimization/cache.rs",
      "line": 190,
      "code": "self.stats.write().unwrap().entry_count -= 1;",
      "context": [
        "    pub async fn remove(&self, key: &K) -> Option<V> {",
        "        let mut storage = self.storage.write().unwrap();",
        "",
        "        if let Some(entry) = storage.remove(key) {",
        "            self.stats.write().unwrap().total_size -= entry.size;",
        "            self.stats.write().unwrap().entry_count -= 1;",
        "",
        "            drop(storage);",
        "            self.remove_from_tracking(key).await;",
        "",
        "            Some(entry.value)"
      ],
      "suggestion": "Replace with .expect(\"descriptive error message\")"
    },
    {
      "file": "src/mcp_manager/optimization/cache.rs",
      "line": 203,
      "code": "self.storage.write().unwrap().clear();",
      "context": [
        "        }",
        "    }",
        "",
        "    /// Clear the cache",
        "    pub async fn clear(&self) {",
        "        self.storage.write().unwrap().clear();",
        "        self.lru_queue.lock().await.clear();",
        "        self.frequency_map.write().unwrap().clear();",
        "        self.fifo_queue.lock().await.clear();",
        "",
        "        let mut stats = self.stats.write().unwrap();"
      ],
      "suggestion": "Replace with .expect(\"descriptive error message\")"
    },
    {
      "file": "src/mcp_manager/optimization/cache.rs",
      "line": 205,
      "code": "self.frequency_map.write().unwrap().clear();",
      "context": [
        "",
        "    /// Clear the cache",
        "    pub async fn clear(&self) {",
        "        self.storage.write().unwrap().clear();",
        "        self.lru_queue.lock().await.clear();",
        "        self.frequency_map.write().unwrap().clear();",
        "        self.fifo_queue.lock().await.clear();",
        "",
        "        let mut stats = self.stats.write().unwrap();",
        "        stats.total_size = 0;",
        "        stats.entry_count = 0;"
      ],
      "suggestion": "Replace with .expect(\"descriptive error message\")"
    },
    {
      "file": "src/mcp_manager/optimization/cache.rs",
      "line": 208,
      "code": "let mut stats = self.stats.write().unwrap();",
      "context": [
        "        self.storage.write().unwrap().clear();",
        "        self.lru_queue.lock().await.clear();",
        "        self.frequency_map.write().unwrap().clear();",
        "        self.fifo_queue.lock().await.clear();",
        "",
        "        let mut stats = self.stats.write().unwrap();",
        "        stats.total_size = 0;",
        "        stats.entry_count = 0;",
        "    }",
        "",
        "    /// Check if eviction is needed"
      ],
      "suggestion": "Replace with .expect(\"descriptive error message\")"
    },
    {
      "file": "src/mcp_manager/optimization/cache.rs",
      "line": 215,
      "code": "let stats = self.stats.read().unwrap();",
      "context": [
        "        stats.entry_count = 0;",
        "    }",
        "",
        "    /// Check if eviction is needed",
        "    async fn needs_eviction(&self, additional_size: usize) -> bool {",
        "        let stats = self.stats.read().unwrap();",
        "",
        "        stats.entry_count >= self.max_entries ||",
        "        stats.total_size + additional_size > self.max_size",
        "    }",
        ""
      ],
      "suggestion": "Replace with .expect(\"descriptive error message\")"
    },
    {
      "file": "src/mcp_manager/optimization/cache.rs",
      "line": 233,
      "code": "self.stats.write().unwrap().evictions += 1;",
      "context": [
        "            EvictionPolicy::TTL => self.evict_oldest().await?,",
        "        };",
        "",
        "        if let Some(key) = key_to_evict {",
        "            self.remove(&key).await;",
        "            self.stats.write().unwrap().evictions += 1;",
        "        }",
        "",
        "        Ok(())",
        "    }",
        ""
      ],
      "suggestion": "Replace with .expect(\"descriptive error message\")"
    },
    {
      "file": "src/mcp_manager/optimization/cache.rs",
      "line": 296,
      "code": "let mut freq_map = self.frequency_map.write().unwrap();",
      "context": [
        "                let mut queue = self.lru_queue.lock().await;",
        "                queue.retain(|k| k != &key);",
        "                queue.push_back(key);",
        "            }",
        "            EvictionPolicy::LFU => {",
        "                let mut freq_map = self.frequency_map.write().unwrap();",
        "                *freq_map.entry(key).or_insert(0) += 1;",
        "            }",
        "            _ => {}",
        "        }",
        "    }"
      ],
      "suggestion": "Replace with .expect(\"descriptive error message\")"
    },
    {
      "file": "src/mcp_manager/optimization/cache.rs",
      "line": 310,
      "code": "self.frequency_map.write().unwrap().insert(key, 1);",
      "context": [
        "        match self.eviction_policy {",
        "            EvictionPolicy::LRU => {",
        "                self.lru_queue.lock().await.push_back(key);",
        "            }",
        "            EvictionPolicy::LFU => {",
        "                self.frequency_map.write().unwrap().insert(key, 1);",
        "            }",
        "            EvictionPolicy::FIFO => {",
        "                self.fifo_queue.lock().await.push_back(key);",
        "            }",
        "            _ => {}"
      ],
      "suggestion": "Replace with .expect(\"descriptive error message\")"
    },
    {
      "file": "src/mcp_manager/optimization/cache.rs",
      "line": 326,
      "code": "self.frequency_map.write().unwrap().remove(key);",
      "context": [
        "        match self.eviction_policy {",
        "            EvictionPolicy::LRU => {",
        "                self.lru_queue.lock().await.retain(|k| k != key);",
        "            }",
        "            EvictionPolicy::LFU => {",
        "                self.frequency_map.write().unwrap().remove(key);",
        "            }",
        "            EvictionPolicy::FIFO => {",
        "                self.fifo_queue.lock().await.retain(|k| k != key);",
        "            }",
        "            _ => {}"
      ],
      "suggestion": "Replace with .expect(\"descriptive error message\")"
    },
    {
      "file": "src/mcp_manager/optimization/cache.rs",
      "line": 350,
      "code": "let storage_map = storage.read().unwrap();",
      "context": [
        "                interval.tick().await;",
        "",
        "                let mut expired_keys = Vec::new();",
        "",
        "                {",
        "                    let storage_map = storage.read().unwrap();",
        "                    for (key, entry) in storage_map.iter() {",
        "                        if let Some(ttl) = entry.ttl {",
        "                            if entry.created_at.elapsed() > ttl {",
        "                                expired_keys.push(key.clone());",
        "                            }"
      ],
      "suggestion": "Replace with .expect(\"descriptive error message\")"
    },
    {
      "file": "src/mcp_manager/optimization/cache.rs",
      "line": 361,
      "code": "let mut storage_map = storage.write().unwrap();",
      "context": [
        "                        }",
        "                    }",
        "                }",
        "",
        "                if !expired_keys.is_empty() {",
        "                    let mut storage_map = storage.write().unwrap();",
        "                    let mut stats_mut = stats.write().unwrap();",
        "",
        "                    for key in expired_keys {",
        "                        if let Some(entry) = storage_map.remove(&key) {",
        "                            stats_mut.expirations += 1;"
      ],
      "suggestion": "Replace with .expect(\"descriptive error message\")"
    },
    {
      "file": "src/mcp_manager/optimization/cache.rs",
      "line": 362,
      "code": "let mut stats_mut = stats.write().unwrap();",
      "context": [
        "                    }",
        "                }",
        "",
        "                if !expired_keys.is_empty() {",
        "                    let mut storage_map = storage.write().unwrap();",
        "                    let mut stats_mut = stats.write().unwrap();",
        "",
        "                    for key in expired_keys {",
        "                        if let Some(entry) = storage_map.remove(&key) {",
        "                            stats_mut.expirations += 1;",
        "                            stats_mut.total_size -= entry.size;"
      ],
      "suggestion": "Replace with .expect(\"descriptive error message\")"
    },
    {
      "file": "src/mcp_manager/optimization/cache.rs",
      "line": 378,
      "code": "self.stats.read().unwrap().clone()",
      "context": [
        "        });",
        "    }",
        "",
        "    /// Get cache statistics",
        "    pub fn get_stats(&self) -> CacheStats {",
        "        self.stats.read().unwrap().clone()",
        "    }",
        "",
        "    /// Get cache hit rate",
        "    pub fn get_hit_rate(&self) -> f64 {",
        "        let stats = self.stats.read().unwrap();"
      ],
      "suggestion": "Replace with .expect(\"descriptive error message\")"
    },
    {
      "file": "src/mcp_manager/optimization/cache.rs",
      "line": 383,
      "code": "let stats = self.stats.read().unwrap();",
      "context": [
        "        self.stats.read().unwrap().clone()",
        "    }",
        "",
        "    /// Get cache hit rate",
        "    pub fn get_hit_rate(&self) -> f64 {",
        "        let stats = self.stats.read().unwrap();",
        "        let total = stats.hits + stats.misses;",
        "",
        "        if total == 0 {",
        "            0.0",
        "        } else {"
      ],
      "suggestion": "Replace with .expect(\"descriptive error message\")"
    },
    {
      "file": "src/mcp_manager/optimization/cache.rs",
      "line": 395,
      "code": "self.stats.read().unwrap().total_size",
      "context": [
        "        }",
        "    }",
        "",
        "    /// Get current size",
        "    pub fn get_size(&self) -> usize {",
        "        self.stats.read().unwrap().total_size",
        "    }",
        "",
        "    /// Get entry count",
        "    pub fn get_entry_count(&self) -> usize {",
        "        self.stats.read().unwrap().entry_count"
      ],
      "suggestion": "Replace with .expect(\"descriptive error message\")"
    },
    {
      "file": "src/mcp_manager/optimization/cache.rs",
      "line": 400,
      "code": "self.stats.read().unwrap().entry_count",
      "context": [
        "        self.stats.read().unwrap().total_size",
        "    }",
        "",
        "    /// Get entry count",
        "    pub fn get_entry_count(&self) -> usize {",
        "        self.stats.read().unwrap().entry_count",
        "    }",
        "}",
        "",
        "/// Multi-tier cache with different policies per tier",
        "pub struct MultiTierCache<K, V>"
      ],
      "suggestion": "Replace with .expect(\"descriptive error message\")"
    },
    {
      "file": "src/mcp_manager/optimization/prefetch.rs",
      "line": 180,
      "code": "self.stats.write().unwrap().predictions_made += 1;",
      "context": [
        "        };",
        "",
        "        if let Ok(request) = predictions {",
        "            if request.confidence >= self.prefetch_threshold {",
        "                let _ = self.prefetch_tx.send(request).await;",
        "                self.stats.write().unwrap().predictions_made += 1;",
        "            }",
        "        }",
        "    }",
        "",
        "    /// Sequential prediction"
      ],
      "suggestion": "Replace with .expect(\"descriptive error message\")"
    },
    {
      "file": "src/mcp_manager/optimization/prefetch.rs",
      "line": 480,
      "code": "*sequential_state.write().unwrap() = sequences;",
      "context": [
        "                        sequences.entry(prev.key.clone())",
        "                            .or_insert_with(Vec::new)",
        "                            .push(next.key.clone());",
        "                    }",
        "                }",
        "                *sequential_state.write().unwrap() = sequences;",
        "",
        "                // Analyze temporal patterns",
        "                let mut temporal = HashMap::new();",
        "                let history_vec: Vec<_> = history.iter().cloned().collect();",
        "                for window in history_vec.windows(2) {"
      ],
      "suggestion": "Replace with .expect(\"descriptive error message\")"
    },
    {
      "file": "src/mcp_manager/optimization/prefetch.rs",
      "line": 493,
      "code": "*temporal_patterns.write().unwrap() = temporal;",
      "context": [
        "                        temporal.entry(next.key.clone())",
        "                            .or_insert_with(Vec::new)",
        "                            .push(interval);",
        "                    }",
        "                }",
        "                *temporal_patterns.write().unwrap() = temporal;",
        "",
        "                // Analyze spatial patterns (simplified - based on common context)",
        "                let mut spatial = HashMap::new();",
        "                for pattern in history.iter() {",
        "                    for other in history.iter() {"
      ],
      "suggestion": "Replace with .expect(\"descriptive error message\")"
    },
    {
      "file": "src/mcp_manager/optimization/prefetch.rs",
      "line": 512,
      "code": "*spatial_map.write().unwrap() = spatial;",
      "context": [
        "                                    .push(other.key.clone());",
        "                            }",
        "                        }",
        "                    }",
        "                }",
        "                *spatial_map.write().unwrap() = spatial;",
        "",
        "                // Update Markov model",
        "                let mut model = markov_model.write().unwrap();",
        "                model.transitions.clear();",
        "                model.state_counts.clear();"
      ],
      "suggestion": "Replace with .expect(\"descriptive error message\")"
    },
    {
      "file": "src/mcp_manager/optimization/prefetch.rs",
      "line": 515,
      "code": "let mut model = markov_model.write().unwrap();",
      "context": [
        "                    }",
        "                }",
        "                *spatial_map.write().unwrap() = spatial;",
        "",
        "                // Update Markov model",
        "                let mut model = markov_model.write().unwrap();",
        "                model.transitions.clear();",
        "                model.state_counts.clear();",
        "",
        "                let history_vec: Vec<_> = history.iter().cloned().collect();",
        "                for window in history_vec.windows(2) {"
      ],
      "suggestion": "Replace with .expect(\"descriptive error message\")"
    },
    {
      "file": "src/mcp_manager/optimization/prefetch.rs",
      "line": 564,
      "code": "stats.write().unwrap().total_prefetched += request.keys.len();",
      "context": [
        "                if queue.len() > 1000 {",
        "                    queue.pop_front();",
        "                }",
        "",
        "                // Update stats",
        "                stats.write().unwrap().total_prefetched += request.keys.len();",
        "            }",
        "        })",
        "    }",
        "",
        "    /// Start model trainer"
      ],
      "suggestion": "Replace with .expect(\"descriptive error message\")"
    },
    {
      "file": "src/mcp_manager/optimization/prefetch.rs",
      "line": 588,
      "code": "let mut model = neural_model.write().unwrap();",
      "context": [
        "                    continue;",
        "                }",
        "",
        "                // Train on recent patterns",
        "                // In real implementation, this would use proper backpropagation",
        "                let mut model = neural_model.write().unwrap();",
        "",
        "                let history_vec: Vec<_> = history.iter().cloned().collect();",
        "                for window in history_vec.windows(2) {",
        "                    if let [prev, _next] = window {",
        "                        // Simplified weight update"
      ],
      "suggestion": "Replace with .expect(\"descriptive error message\")"
    },
    {
      "file": "src/mcp_manager/optimization/prefetch.rs",
      "line": 623,
      "code": "let mut stats = self.stats.write().unwrap();",
      "context": [
        "        suggestions",
        "    }",
        "",
        "    /// Update statistics with actual access",
        "    pub fn update_stats(&self, key: &str, was_prefetched: bool) {",
        "        let mut stats = self.stats.write().unwrap();",
        "",
        "        if was_prefetched {",
        "            stats.successful_predictions += 1;",
        "        }",
        ""
      ],
      "suggestion": "Replace with .expect(\"descriptive error message\")"
    },
    {
      "file": "src/mcp_manager/optimization/prefetch.rs",
      "line": 671,
      "code": "let sequential_state = prefetcher.sequential_state.read().unwrap();",
      "context": [
        "",
        "        // Wait for pattern analysis",
        "        tokio::time::sleep(Duration::from_millis(100)).await;",
        "",
        "        // Check if patterns were learned",
        "        let sequential_state = prefetcher.sequential_state.read().unwrap();",
        "        assert!(!sequential_state.is_empty());",
        "    }",
        "",
        "    #[tokio::test]",
        "    async fn test_markov_prediction() {"
      ],
      "suggestion": "Replace with .expect(\"descriptive error message\")"
    },
    {
      "file": "src/mcp_manager/optimization/prefetch.rs",
      "line": 696,
      "code": "let model = prefetcher.markov_model.read().unwrap();",
      "context": [
        "",
        "        // Wait for pattern analysis",
        "        tokio::time::sleep(Duration::from_secs(11)).await;",
        "",
        "        // Check Markov model",
        "        let model = prefetcher.markov_model.read().unwrap();",
        "        assert!(!model.transitions.is_empty());",
        "",
        "        // A should transition to B with high probability",
        "        if let Some(transitions) = model.transitions.get(\"A\") {",
        "            assert!(transitions.get(\"B\").unwrap_or(&0.0) > &0.5);"
      ],
      "suggestion": "Replace with .expect(\"descriptive error message\")"
    },
    {
      "file": "src/mcp_manager/resilience/chaos.rs",
      "line": 203,
      "code": "self.experiments.write().unwrap().insert(id.clone(), result);",
      "context": [
        "            impact_metrics: HashMap::new(),",
        "            recovery_time: None,",
        "            errors: Vec::new(),",
        "        };",
        "",
        "        self.experiments.write().unwrap().insert(id.clone(), result);",
        "",
        "        // Queue experiment",
        "        self.experiment_queue.lock().await.push(config);",
        "",
        "        Ok(id)"
      ],
      "suggestion": "Replace with .expect(\"descriptive error message\")"
    },
    {
      "file": "src/mcp_manager/resilience/chaos.rs",
      "line": 220,
      "code": "self.service_hooks.write().unwrap().insert(service, hook);",
      "context": [
        "        Ok(())",
        "    }",
        "",
        "    /// Register a service hook",
        "    pub fn register_service_hook(&self, service: String, hook: Box<dyn ServiceHook>) {",
        "        self.service_hooks.write().unwrap().insert(service, hook);",
        "    }",
        "",
        "    /// Start experiment runner",
        "    fn start_experiment_runner(&self) -> tokio::task::JoinHandle<()> {",
        "        let experiment_rx = self.experiment_rx.clone();"
      ],
      "suggestion": "Replace with .expect(\"descriptive error message\")"
    },
    {
      "file": "src/mcp_manager/resilience/chaos.rs",
      "line": 273,
      "code": "let experiment_id = experiments.read().unwrap()",
      "context": [
        "    async fn run_experiment(",
        "        config: ExperimentConfig,",
        "        experiments: Arc<RwLock<HashMap<String, ExperimentResult>>>,",
        "        service_hooks: Arc<RwLock<HashMap<String, Box<dyn ServiceHook>>>>,",
        "    ) -> ExperimentResult {",
        "        let experiment_id = experiments.read().unwrap()",
        "            .values()",
        "            .find(|e| e.experiment_type == config.experiment_type &&",
        "                     e.status == ExperimentStatus::Pending)",
        "            .map(|e| e.id.clone())",
        "            .unwrap_or_else(|| \"unknown\".to_string());"
      ],
      "suggestion": "Replace with .expect(\"descriptive error message\")"
    },
    {
      "file": "src/mcp_manager/resilience/chaos.rs",
      "line": 281,
      "code": "if let Some(result) = experiments.write().unwrap().get_mut(&experiment_id) {",
      "context": [
        "                     e.status == ExperimentStatus::Pending)",
        "            .map(|e| e.id.clone())",
        "            .unwrap_or_else(|| \"unknown\".to_string());",
        "",
        "        // Update status to running",
        "        if let Some(result) = experiments.write().unwrap().get_mut(&experiment_id) {",
        "            result.status = ExperimentStatus::Running;",
        "            result.start_time = Instant::now();",
        "        }",
        "",
        "        // Execute experiment based on type"
      ],
      "suggestion": "Replace with .expect(\"descriptive error message\")"
    },
    {
      "file": "src/mcp_manager/resilience/chaos.rs",
      "line": 292,
      "code": "if let Some(hook) = service_hooks.read().unwrap().get(&config.target) {",
      "context": [
        "        let mut errors = Vec::new();",
        "        let mut impact_metrics = HashMap::new();",
        "",
        "        match config.experiment_type {",
        "            ExperimentType::NetworkLatency => {",
        "                if let Some(hook) = service_hooks.read().unwrap().get(&config.target) {",
        "                    let latency = Duration::from_millis((config.intensity * 1000.0) as u64);",
        "                    if let Err(e) = hook.inject_latency(latency) {",
        "                        errors.push(format!(\"Failed to inject latency: {}\", e));",
        "                    }",
        "                    impact_metrics.insert(\"latency_ms\".to_string(), latency.as_millis() as f64);"
      ],
      "suggestion": "Use .get().ok_or_else(|| Error::NotFound)? or pattern matching"
    },
    {
      "file": "src/mcp_manager/resilience/chaos.rs",
      "line": 301,
      "code": "if let Some(hook) = service_hooks.read().unwrap().get(&config.target) {",
      "context": [
        "                    }",
        "                    impact_metrics.insert(\"latency_ms\".to_string(), latency.as_millis() as f64);",
        "                }",
        "            }",
        "            ExperimentType::ServiceCrash => {",
        "                if let Some(hook) = service_hooks.read().unwrap().get(&config.target) {",
        "                    if let Err(e) = hook.kill_service() {",
        "                        errors.push(format!(\"Failed to kill service: {}\", e));",
        "                    }",
        "                    impact_metrics.insert(\"service_killed\".to_string(), 1.0);",
        "                }"
      ],
      "suggestion": "Use .get().ok_or_else(|| Error::NotFound)? or pattern matching"
    },
    {
      "file": "src/mcp_manager/resilience/chaos.rs",
      "line": 309,
      "code": "if let Some(hook) = service_hooks.read().unwrap().get(&config.target) {",
      "context": [
        "                    }",
        "                    impact_metrics.insert(\"service_killed\".to_string(), 1.0);",
        "                }",
        "            }",
        "            ExperimentType::PacketLoss => {",
        "                if let Some(hook) = service_hooks.read().unwrap().get(&config.target) {",
        "                    if let Err(e) = hook.inject_error(config.intensity) {",
        "                        errors.push(format!(\"Failed to inject packet loss: {}\", e));",
        "                    }",
        "                    impact_metrics.insert(\"packet_loss_rate\".to_string(), config.intensity);",
        "                }"
      ],
      "suggestion": "Use .get().ok_or_else(|| Error::NotFound)? or pattern matching"
    },
    {
      "file": "src/mcp_manager/resilience/chaos.rs",
      "line": 317,
      "code": "if let Some(hook) = service_hooks.read().unwrap().get(&config.target) {",
      "context": [
        "                    }",
        "                    impact_metrics.insert(\"packet_loss_rate\".to_string(), config.intensity);",
        "                }",
        "            }",
        "            ExperimentType::CPUSpike => {",
        "                if let Some(hook) = service_hooks.read().unwrap().get(&config.target) {",
        "                    let cpu_limit = 1.0 - config.intensity; // High intensity = low CPU limit",
        "                    if let Err(e) = hook.inject_resource_limit(cpu_limit, 1.0) {",
        "                        errors.push(format!(\"Failed to inject CPU spike: {}\", e));",
        "                    }",
        "                    impact_metrics.insert(\"cpu_limit\".to_string(), cpu_limit);"
      ],
      "suggestion": "Use .get().ok_or_else(|| Error::NotFound)? or pattern matching"
    },
    {
      "file": "src/mcp_manager/resilience/chaos.rs",
      "line": 326,
      "code": "if let Some(hook) = service_hooks.read().unwrap().get(&config.target) {",
      "context": [
        "                    }",
        "                    impact_metrics.insert(\"cpu_limit\".to_string(), cpu_limit);",
        "                }",
        "            }",
        "            ExperimentType::MemoryLeak => {",
        "                if let Some(hook) = service_hooks.read().unwrap().get(&config.target) {",
        "                    let memory_limit = 1.0 - config.intensity;",
        "                    if let Err(e) = hook.inject_resource_limit(1.0, memory_limit) {",
        "                        errors.push(format!(\"Failed to inject memory leak: {}\", e));",
        "                    }",
        "                    impact_metrics.insert(\"memory_limit\".to_string(), memory_limit);"
      ],
      "suggestion": "Use .get().ok_or_else(|| Error::NotFound)? or pattern matching"
    },
    {
      "file": "src/mcp_manager/resilience/chaos.rs",
      "line": 335,
      "code": "if let Some(hook) = service_hooks.read().unwrap().get(&config.target) {",
      "context": [
        "                    }",
        "                    impact_metrics.insert(\"memory_limit\".to_string(), memory_limit);",
        "                }",
        "            }",
        "            ExperimentType::NetworkPartition => {",
        "                if let Some(hook) = service_hooks.read().unwrap().get(&config.target) {",
        "                    if let Some(partition_target) = config.params.get(\"partition_target\") {",
        "                        if let Err(e) = hook.partition_network(partition_target) {",
        "                            errors.push(format!(\"Failed to partition network: {}\", e));",
        "                        }",
        "                        impact_metrics.insert(\"partition_active\".to_string(), 1.0);"
      ],
      "suggestion": "Use .get().ok_or_else(|| Error::NotFound)? or pattern matching"
    },
    {
      "file": "src/mcp_manager/resilience/chaos.rs",
      "line": 354,
      "code": "if let Some(result) = experiments.write().unwrap().get_mut(&experiment_id) {",
      "context": [
        "        // Wait for experiment duration",
        "        sleep(config.duration).await;",
        "",
        "        // Update final result",
        "        let end_time = Instant::now();",
        "        if let Some(result) = experiments.write().unwrap().get_mut(&experiment_id) {",
        "            result.end_time = Some(end_time);",
        "            result.status = if errors.is_empty() {",
        "                ExperimentStatus::Completed",
        "            } else {",
        "                ExperimentStatus::Failed"
      ],
      "suggestion": "Replace with .expect(\"descriptive error message\")"
    },
    {
      "file": "src/mcp_manager/resilience/chaos.rs",
      "line": 395,
      "code": "if !*safety_enabled.read().unwrap() {",
      "context": [
        "            let mut interval = interval(Duration::from_secs(1));",
        "",
        "            loop {",
        "                interval.tick().await;",
        "",
        "                if !*safety_enabled.read().unwrap() {",
        "                    continue;",
        "                }",
        "",
        "                let baseline = baseline_metrics.read().unwrap();",
        "                let current = current_metrics.read().unwrap();"
      ],
      "suggestion": "Replace with .expect(\"descriptive error message\")"
    },
    {
      "file": "src/mcp_manager/resilience/chaos.rs",
      "line": 399,
      "code": "let baseline = baseline_metrics.read().unwrap();",
      "context": [
        "",
        "                if !*safety_enabled.read().unwrap() {",
        "                    continue;",
        "                }",
        "",
        "                let baseline = baseline_metrics.read().unwrap();",
        "                let current = current_metrics.read().unwrap();",
        "",
        "                // Check for excessive degradation",
        "                let availability_degradation = (baseline.availability - current.availability) / baseline.availability;",
        "                let error_rate_increase = current.error_rate - baseline.error_rate;"
      ],
      "suggestion": "Replace with .expect(\"descriptive error message\")"
    },
    {
      "file": "src/mcp_manager/resilience/chaos.rs",
      "line": 400,
      "code": "let current = current_metrics.read().unwrap();",
      "context": [
        "                if !*safety_enabled.read().unwrap() {",
        "                    continue;",
        "                }",
        "",
        "                let baseline = baseline_metrics.read().unwrap();",
        "                let current = current_metrics.read().unwrap();",
        "",
        "                // Check for excessive degradation",
        "                let availability_degradation = (baseline.availability - current.availability) / baseline.availability;",
        "                let error_rate_increase = current.error_rate - baseline.error_rate;",
        "                let latency_increase = current.latency_p99.as_millis() as f64 / baseline.latency_p99.as_millis() as f64 - 1.0;"
      ],
      "suggestion": "Replace with .expect(\"descriptive error message\")"
    },
    {
      "file": "src/mcp_manager/resilience/chaos.rs",
      "line": 411,
      "code": "let running_experiments: Vec<String> = experiments.read().unwrap()",
      "context": [
        "",
        "                if availability_degradation > max_degradation ||",
        "                   error_rate_increase > max_degradation ||",
        "                   latency_increase > max_degradation {",
        "                    // Abort all running experiments",
        "                    let running_experiments: Vec<String> = experiments.read().unwrap()",
        "                        .iter()",
        "                        .filter(|(_, e)| e.status == ExperimentStatus::Running)",
        "                        .map(|(id, _)| id.clone())",
        "                        .collect();",
        ""
      ],
      "suggestion": "Replace with .expect(\"descriptive error message\")"
    },
    {
      "file": "src/mcp_manager/resilience/chaos.rs",
      "line": 437,
      "code": "let mut metrics = current_metrics.write().unwrap();",
      "context": [
        "            loop {",
        "                interval.tick().await;",
        "",
        "                // In real implementation, collect actual metrics",
        "                // For now, simulate metric collection",
        "                let mut metrics = current_metrics.write().unwrap();",
        "",
        "                // Add some random variation",
        "                let mut rng = thread_rng();",
        "                metrics.availability = 0.95 + rng.gen::<f64>() * 0.05;",
        "                metrics.error_rate = rng.gen::<f64>() * 0.05;"
      ],
      "suggestion": "Replace with .expect(\"descriptive error message\")"
    },
    {
      "file": "src/mcp_manager/resilience/chaos.rs",
      "line": 462,
      "code": "if let Some(result) = experiments.write().unwrap().get_mut(&experiment_id) {",
      "context": [
        "",
        "        tokio::spawn(async move {",
        "            let mut rx = abort_rx.lock().await;",
        "",
        "            while let Some(experiment_id) = rx.recv().await {",
        "                if let Some(result) = experiments.write().unwrap().get_mut(&experiment_id) {",
        "                    if result.status == ExperimentStatus::Running {",
        "                        result.status = ExperimentStatus::Aborted;",
        "                        result.end_time = Some(Instant::now());",
        "                        result.errors.push(\"Experiment aborted by safety monitor\".to_string());",
        "                    }"
      ],
      "suggestion": "Replace with .expect(\"descriptive error message\")"
    },
    {
      "file": "src/mcp_manager/resilience/chaos.rs",
      "line": 527,
      "code": "self.experiments.read().unwrap().get(experiment_id).cloned()",
      "context": [
        "            .collect()",
        "    }",
        "",
        "    /// Get experiment results",
        "    pub fn get_experiment_results(&self, experiment_id: &str) -> Option<ExperimentResult> {",
        "        self.experiments.read().unwrap().get(experiment_id).cloned()",
        "    }",
        "",
        "    /// Get all experiments",
        "    pub fn get_all_experiments(&self) -> Vec<ExperimentResult> {",
        "        self.experiments.read().unwrap().values().cloned().collect()"
      ],
      "suggestion": "Use .get().ok_or_else(|| Error::NotFound)? or pattern matching"
    },
    {
      "file": "src/mcp_manager/resilience/chaos.rs",
      "line": 532,
      "code": "self.experiments.read().unwrap().values().cloned().collect()",
      "context": [
        "        self.experiments.read().unwrap().get(experiment_id).cloned()",
        "    }",
        "",
        "    /// Get all experiments",
        "    pub fn get_all_experiments(&self) -> Vec<ExperimentResult> {",
        "        self.experiments.read().unwrap().values().cloned().collect()",
        "    }",
        "",
        "    /// Get current metrics",
        "    pub fn get_current_metrics(&self) -> SystemMetrics {",
        "        self.current_metrics.read().unwrap().clone()"
      ],
      "suggestion": "Replace with .expect(\"descriptive error message\")"
    },
    {
      "file": "src/mcp_manager/resilience/chaos.rs",
      "line": 537,
      "code": "self.current_metrics.read().unwrap().clone()",
      "context": [
        "        self.experiments.read().unwrap().values().cloned().collect()",
        "    }",
        "",
        "    /// Get current metrics",
        "    pub fn get_current_metrics(&self) -> SystemMetrics {",
        "        self.current_metrics.read().unwrap().clone()",
        "    }",
        "",
        "    /// Update baseline metrics",
        "    pub fn update_baseline_metrics(&self) {",
        "        let current = self.current_metrics.read().unwrap().clone();"
      ],
      "suggestion": "Replace with .expect(\"descriptive error message\")"
    },
    {
      "file": "src/mcp_manager/resilience/chaos.rs",
      "line": 542,
      "code": "let current = self.current_metrics.read().unwrap().clone();",
      "context": [
        "        self.current_metrics.read().unwrap().clone()",
        "    }",
        "",
        "    /// Update baseline metrics",
        "    pub fn update_baseline_metrics(&self) {",
        "        let current = self.current_metrics.read().unwrap().clone();",
        "        *self.baseline_metrics.write().unwrap() = current;",
        "    }",
        "",
        "    /// Enable/disable safety checks",
        "    pub fn set_safety_enabled(&self, enabled: bool) {"
      ],
      "suggestion": "Replace with .expect(\"descriptive error message\")"
    },
    {
      "file": "src/mcp_manager/resilience/chaos.rs",
      "line": 543,
      "code": "*self.baseline_metrics.write().unwrap() = current;",
      "context": [
        "    }",
        "",
        "    /// Update baseline metrics",
        "    pub fn update_baseline_metrics(&self) {",
        "        let current = self.current_metrics.read().unwrap().clone();",
        "        *self.baseline_metrics.write().unwrap() = current;",
        "    }",
        "",
        "    /// Enable/disable safety checks",
        "    pub fn set_safety_enabled(&self, enabled: bool) {",
        "        *self.safety_enabled.write().unwrap() = enabled;"
      ],
      "suggestion": "Replace with .expect(\"descriptive error message\")"
    },
    {
      "file": "src/mcp_manager/resilience/chaos.rs",
      "line": 548,
      "code": "*self.safety_enabled.write().unwrap() = enabled;",
      "context": [
        "        *self.baseline_metrics.write().unwrap() = current;",
        "    }",
        "",
        "    /// Enable/disable safety checks",
        "    pub fn set_safety_enabled(&self, enabled: bool) {",
        "        *self.safety_enabled.write().unwrap() = enabled;",
        "    }",
        "}",
        "",
        "/// Mock service hook for testing",
        "pub struct MockServiceHook;"
      ],
      "suggestion": "Replace with .expect(\"descriptive error message\")"
    },
    {
      "file": "src/synthex_bashgod/mcp_integration/tool_enhancer.rs",
      "line": 313,
      "code": "bash_pattern: regex::Regex::new(pattern).unwrap(),",
      "context": [
        "    }",
        "",
        "    /// Create Docker command mapping",
        "    fn create_docker_mapping(pattern: &str, tool: &str) -> CommandMapping {",
        "        CommandMapping {",
        "            bash_pattern: regex::Regex::new(pattern).unwrap(),",
        "            server: \"docker\".to_string(),",
        "            tool: tool.to_string(),",
        "            param_extractor: Box::new(DockerParamExtractor),",
        "            success_criteria: crate::synthex_bashgod::mcp_integration::SuccessCriteria {",
        "                output_pattern: None,"
      ],
      "suggestion": "Replace with .expect(\"descriptive error message\")"
    },
    {
      "file": "src/synthex_bashgod/mcp_integration/tool_enhancer.rs",
      "line": 328,
      "code": "bash_pattern: regex::Regex::new(pattern).unwrap(),",
      "context": [
        "    }",
        "",
        "    /// Create Git command mapping",
        "    fn create_git_mapping(pattern: &str, tool: &str) -> CommandMapping {",
        "        CommandMapping {",
        "            bash_pattern: regex::Regex::new(pattern).unwrap(),",
        "            server: \"git\".to_string(),",
        "            tool: tool.to_string(),",
        "            param_extractor: Box::new(GitParamExtractor),",
        "            success_criteria: crate::synthex_bashgod::mcp_integration::SuccessCriteria {",
        "                output_pattern: None,"
      ],
      "suggestion": "Replace with .expect(\"descriptive error message\")"
    },
    {
      "file": "src/synthex_bashgod/mcp_integration/tool_enhancer.rs",
      "line": 343,
      "code": "bash_pattern: regex::Regex::new(pattern).unwrap(),",
      "context": [
        "    }",
        "",
        "    /// Create Kubernetes command mapping",
        "    fn create_k8s_mapping(pattern: &str, tool: &str) -> CommandMapping {",
        "        CommandMapping {",
        "            bash_pattern: regex::Regex::new(pattern).unwrap(),",
        "            server: \"kubernetes\".to_string(),",
        "            tool: tool.to_string(),",
        "            param_extractor: Box::new(K8sParamExtractor),",
        "            success_criteria: crate::synthex_bashgod::mcp_integration::SuccessCriteria {",
        "                output_pattern: None,"
      ],
      "suggestion": "Replace with .expect(\"descriptive error message\")"
    },
    {
      "file": "src/synthex_bashgod/mcp_integration/tool_enhancer.rs",
      "line": 358,
      "code": "bash_pattern: regex::Regex::new(pattern).unwrap(),",
      "context": [
        "    }",
        "",
        "    /// Create file system command mapping",
        "    fn create_fs_mapping(pattern: &str, tool: &str) -> CommandMapping {",
        "        CommandMapping {",
        "            bash_pattern: regex::Regex::new(pattern).unwrap(),",
        "            server: \"filesystem\".to_string(),",
        "            tool: tool.to_string(),",
        "            param_extractor: Box::new(FsParamExtractor),",
        "            success_criteria: crate::synthex_bashgod::mcp_integration::SuccessCriteria {",
        "                output_pattern: None,"
      ],
      "suggestion": "Replace with .expect(\"descriptive error message\")"
    },
    {
      "file": "src/synthex_bashgod/learning/pattern_detector.rs",
      "line": 117,
      "code": "pattern: regex::Regex::new(r\"^(.+)$\").unwrap(),",
      "context": [
        "            // Repetition detection",
        "            PatternRule {",
        "                name: \"repeated_commands\".to_string(),",
        "                pattern_type: PatternType::Repetition,",
        "                matcher: Box::new(RegexPatternMatcher {",
        "                    pattern: regex::Regex::new(r\"^(.+)$\").unwrap(),",
        "                }),",
        "                severity: PatternSeverity::Warning,",
        "            },",
        "            // Resource waste patterns",
        "            PatternRule {"
      ],
      "suggestion": "Use .expect(\"Invalid regex pattern: ^(.+)$...\")"
    },
    {
      "file": "src/synthex_bashgod/learning/pattern_detector.rs",
      "line": 126,
      "code": "pattern: regex::Regex::new(r\"cat\\s+.+\\s*\\|\\s*grep\").unwrap(),",
      "context": [
        "            // Resource waste patterns",
        "            PatternRule {",
        "                name: \"cat_grep_waste\".to_string(),",
        "                pattern_type: PatternType::ResourceWaste,",
        "                matcher: Box::new(RegexPatternMatcher {",
        "                    pattern: regex::Regex::new(r\"cat\\s+.+\\s*\\|\\s*grep\").unwrap(),",
        "                }),",
        "                severity: PatternSeverity::Warning,",
        "            },",
        "            // Security risks",
        "            PatternRule {"
      ],
      "suggestion": "Use .expect(\"Invalid regex pattern: cat\\s+.+\\s*\\|\\s*grep...\")"
    },
    {
      "file": "src/synthex_bashgod/learning/pattern_detector.rs",
      "line": 135,
      "code": "pattern: regex::Regex::new(r\"eval\\s+\").unwrap(),",
      "context": [
        "            // Security risks",
        "            PatternRule {",
        "                name: \"unsafe_eval\".to_string(),",
        "                pattern_type: PatternType::SecurityRisk,",
        "                matcher: Box::new(RegexPatternMatcher {",
        "                    pattern: regex::Regex::new(r\"eval\\s+\").unwrap(),",
        "                }),",
        "                severity: PatternSeverity::Critical,",
        "            },",
        "        ]",
        "    }"
      ],
      "suggestion": "Use .expect(\"Invalid regex pattern: eval\\s+...\")"
    },
    {
      "file": "src/synthex_bashgod/learning/predictor.rs",
      "line": 500,
      "code": "pattern: regex::Regex::new(r\"sudo|/root/|/etc/\").unwrap(),",
      "context": [
        "    fn add_default_patterns(&mut self) {",
        "        // Permission issues",
        "        self.pattern_rules.push(IssuePattern {",
        "            id: \"permission-denied\".to_string(),",
        "            issue_type: IssueType::PermissionDenied,",
        "            pattern: regex::Regex::new(r\"sudo|/root/|/etc/\").unwrap(),",
        "            base_probability: 0.3,",
        "            mitigations: vec![",
        "                \"Ensure proper permissions\".to_string(),",
        "                \"Use sudo if required\".to_string(),",
        "            ],"
      ],
      "suggestion": "Use .expect(\"Invalid regex pattern: sudo|/root/|/etc/...\")"
    },
    {
      "file": "src/synthex_bashgod/learning/predictor.rs",
      "line": 512,
      "code": "pattern: regex::Regex::new(r\"find.*-exec|grep -r|tar|zip\").unwrap(),",
      "context": [
        "",
        "        // Resource exhaustion",
        "        self.pattern_rules.push(IssuePattern {",
        "            id: \"memory-intensive\".to_string(),",
        "            issue_type: IssueType::ResourceExhaustion,",
        "            pattern: regex::Regex::new(r\"find.*-exec|grep -r|tar|zip\").unwrap(),",
        "            base_probability: 0.2,",
        "            mitigations: vec![",
        "                \"Monitor memory usage\".to_string(),",
        "                \"Use streaming operations\".to_string(),",
        "            ],"
      ],
      "suggestion": "Use .expect(\"Invalid regex pattern: find.*-exec|grep -r|...\")"
    },
    {
      "file": "src/synthex_bashgod/learning/predictor.rs",
      "line": 524,
      "code": "pattern: regex::Regex::new(r\"curl|wget|git clone|docker pull\").unwrap(),",
      "context": [
        "",
        "        // Timeout risk",
        "        self.pattern_rules.push(IssuePattern {",
        "            id: \"timeout-risk\".to_string(),",
        "            issue_type: IssueType::TimeoutRisk,",
        "            pattern: regex::Regex::new(r\"curl|wget|git clone|docker pull\").unwrap(),",
        "            base_probability: 0.15,",
        "            mitigations: vec![",
        "                \"Set appropriate timeouts\".to_string(),",
        "                \"Use retry logic\".to_string(),",
        "            ],"
      ],
      "suggestion": "Use .expect(\"Invalid regex pattern: curl|wget|git clone|...\")"
    }
  ],
  "needs_refactor": [
    {
      "file": "src/infrastructure.rs",
      "line": 341,
      "code": "&self.validated_configs.get(&config_id).unwrap().value()",
      "context": [
        "        let config_id = uuid::Uuid::new_v4().to_string();",
        "        self.validated_configs.insert(config_id.clone(), config);",
        "",
        "        // Return as JSON",
        "        let json = serde_json::to_string_pretty(",
        "            &self.validated_configs.get(&config_id).unwrap().value()",
        "        ).map_err(|e| CoreError::Serialization(format!(\"JSON serialize error: {}\", e)))?;",
        "",
        "        Ok(json)",
        "    }",
        "}"
      ],
      "suggestion": "Use .get().ok_or_else(|| Error::NotFound)? or pattern matching"
    },
    {
      "file": "src/lockfree_collections.rs",
      "line": 750,
      "code": "assert_eq!(map.get(\"key1\".to_string()).unwrap(), Some(\"value1\".to_string()));",
      "context": [
        "    fn test_concurrent_hashmap() {",
        "        Python::with_gil(|_py| {",
        "            let map = ConcurrentHashMap::new();",
        "",
        "            assert!(map.insert(\"key1\".to_string(), \"value1\".to_string()).unwrap());",
        "            assert_eq!(map.get(\"key1\".to_string()).unwrap(), Some(\"value1\".to_string()));",
        "            assert_eq!(map.size(), 1);",
        "",
        "            assert_eq!(map.remove(\"key1\".to_string()).unwrap(), Some(\"value1\".to_string()));",
        "            assert_eq!(map.size(), 0);",
        "        });"
      ],
      "suggestion": "Use .get().ok_or_else(|| Error::NotFound)? or pattern matching"
    },
    {
      "file": "src/lockfree_collections.rs",
      "line": 772,
      "code": "assert_eq!(stats.get(\"count\").unwrap(), &1.0);",
      "context": [
        "            collector.set_gauge(\"memory_usage\".to_string(), 1024).unwrap();",
        "            assert_eq!(collector.get_gauge(\"memory_usage\".to_string()).unwrap(), 1024);",
        "",
        "            collector.record_histogram(\"latency\".to_string(), 123.45).unwrap();",
        "            let stats = collector.get_histogram_stats(\"latency\".to_string()).unwrap();",
        "            assert_eq!(stats.get(\"count\").unwrap(), &1.0);",
        "        });",
        "    }",
        "}"
      ],
      "suggestion": "Use .get().ok_or_else(|| Error::NotFound)? or pattern matching"
    },
    {
      "file": "src/resources/storage_manager.rs",
      "line": 467,
      "code": "let allocation = manager.allocations.get(&service_id).unwrap();",
      "context": [
        "        manager.allocate(&service_id, 1024).await.unwrap();",
        "",
        "        // Set I/O limits",
        "        manager.set_io_limits(&service_id, Some(1000), Some(100)).await.unwrap();",
        "",
        "        let allocation = manager.allocations.get(&service_id).unwrap();",
        "        assert_eq!(allocation.iops_limit, Some(1000));",
        "        assert_eq!(allocation.bandwidth_limit_mbps, Some(100));",
        "    }",
        "}"
      ],
      "suggestion": "Use .get().ok_or_else(|| Error::NotFound)? or pattern matching"
    },
    {
      "file": "src/mcp_manager/server_types/infrastructure.rs",
      "line": 214,
      "code": "assert_eq!(obj.get(\"standard_status\").unwrap().as_str().unwrap(), \"ok\");",
      "context": [
        "        });",
        "",
        "        let transformed = handler.transform_response(response).await.unwrap();",
        "        let obj = transformed.as_object().unwrap();",
        "",
        "        assert_eq!(obj.get(\"standard_status\").unwrap().as_str().unwrap(), \"ok\");",
        "    }",
        "}"
      ],
      "suggestion": "Use .get().ok_or_else(|| Error::NotFound)? or pattern matching"
    },
    {
      "file": "src/mcp_manager/server_types/monitoring.rs",
      "line": 263,
      "code": "let std_metrics = obj.get(\"standardized_metrics\").unwrap().as_object().unwrap();",
      "context": [
        "",
        "        let transformed = handler.transform_response(response).await.unwrap();",
        "        let obj = transformed.as_object().unwrap();",
        "",
        "        assert!(obj.contains_key(\"standardized_metrics\"));",
        "        let std_metrics = obj.get(\"standardized_metrics\").unwrap().as_object().unwrap();",
        "",
        "        assert!(std_metrics.get(\"cpu\").unwrap().get(\"value\").unwrap().as_f64().unwrap() == 45.5);",
        "        assert!(std_metrics.get(\"memory\").unwrap().get(\"value\").unwrap().as_f64().unwrap() == 1024.0);",
        "        assert!(std_metrics.get(\"disk\").unwrap().get(\"value\").unwrap().as_f64().unwrap() == 80.0);",
        "    }"
      ],
      "suggestion": "Use .get().ok_or_else(|| Error::NotFound)? or pattern matching"
    },
    {
      "file": "src/mcp_manager/server_types/monitoring.rs",
      "line": 265,
      "code": "assert!(std_metrics.get(\"cpu\").unwrap().get(\"value\").unwrap().as_f64().unwrap() == 45.5);",
      "context": [
        "        let obj = transformed.as_object().unwrap();",
        "",
        "        assert!(obj.contains_key(\"standardized_metrics\"));",
        "        let std_metrics = obj.get(\"standardized_metrics\").unwrap().as_object().unwrap();",
        "",
        "        assert!(std_metrics.get(\"cpu\").unwrap().get(\"value\").unwrap().as_f64().unwrap() == 45.5);",
        "        assert!(std_metrics.get(\"memory\").unwrap().get(\"value\").unwrap().as_f64().unwrap() == 1024.0);",
        "        assert!(std_metrics.get(\"disk\").unwrap().get(\"value\").unwrap().as_f64().unwrap() == 80.0);",
        "    }",
        "}"
      ],
      "suggestion": "Use .get().ok_or_else(|| Error::NotFound)? or pattern matching"
    },
    {
      "file": "src/mcp_manager/server_types/monitoring.rs",
      "line": 266,
      "code": "assert!(std_metrics.get(\"memory\").unwrap().get(\"value\").unwrap().as_f64().unwrap() == 1024.0);",
      "context": [
        "",
        "        assert!(obj.contains_key(\"standardized_metrics\"));",
        "        let std_metrics = obj.get(\"standardized_metrics\").unwrap().as_object().unwrap();",
        "",
        "        assert!(std_metrics.get(\"cpu\").unwrap().get(\"value\").unwrap().as_f64().unwrap() == 45.5);",
        "        assert!(std_metrics.get(\"memory\").unwrap().get(\"value\").unwrap().as_f64().unwrap() == 1024.0);",
        "        assert!(std_metrics.get(\"disk\").unwrap().get(\"value\").unwrap().as_f64().unwrap() == 80.0);",
        "    }",
        "}"
      ],
      "suggestion": "Use .get().ok_or_else(|| Error::NotFound)? or pattern matching"
    },
    {
      "file": "src/mcp_manager/server_types/monitoring.rs",
      "line": 267,
      "code": "assert!(std_metrics.get(\"disk\").unwrap().get(\"value\").unwrap().as_f64().unwrap() == 80.0);",
      "context": [
        "        assert!(obj.contains_key(\"standardized_metrics\"));",
        "        let std_metrics = obj.get(\"standardized_metrics\").unwrap().as_object().unwrap();",
        "",
        "        assert!(std_metrics.get(\"cpu\").unwrap().get(\"value\").unwrap().as_f64().unwrap() == 45.5);",
        "        assert!(std_metrics.get(\"memory\").unwrap().get(\"value\").unwrap().as_f64().unwrap() == 1024.0);",
        "        assert!(std_metrics.get(\"disk\").unwrap().get(\"value\").unwrap().as_f64().unwrap() == 80.0);",
        "    }",
        "}"
      ],
      "suggestion": "Use .get().ok_or_else(|| Error::NotFound)? or pattern matching"
    },
    {
      "file": "src/mcp_manager/plugin/rollback.rs",
      "line": 763,
      "code": "let strategy = strategies.get(&self.config.default_strategy).unwrap();",
      "context": [
        "        result.from_version = source.version.clone();",
        "        result.to_version = target.version.clone();",
        "",
        "        // Validate rollback",
        "        let strategies = self.strategies.read().await;",
        "        let strategy = strategies.get(&self.config.default_strategy).unwrap();",
        "",
        "        match strategy.validate_rollback(&source.handle, &target).await {",
        "            Ok(validation) => {",
        "                if !validation.can_rollback {",
        "                    result.errors.push(\"Rollback validation failed\".to_string());"
      ],
      "suggestion": "Use .get().ok_or_else(|| Error::NotFound)? or pattern matching"
    },
    {
      "file": "src/synthex_bashgod/memory/tensor.rs",
      "line": 805,
      "code": "let updated = memory.patterns.get(\"stats-test\").unwrap();",
      "context": [
        "        };",
        "",
        "        memory.update_stats(\"stats-test\", &execution_result).await.unwrap();",
        "",
        "        // Verify update",
        "        let updated = memory.patterns.get(\"stats-test\").unwrap();",
        "        assert_eq!(updated.metrics.execution_count, 2);",
        "        assert_eq!(updated.metrics.avg_execution_time_ms, 150.0);",
        "    }",
        "}"
      ],
      "suggestion": "Use .get().ok_or_else(|| Error::NotFound)? or pattern matching"
    },
    {
      "file": "src/synthex_bashgod/memory/graph.rs",
      "line": 730,
      "code": "let idx0 = memory.node_index.get(\"pattern0\").unwrap();",
      "context": [
        "            memory.add_pattern(&pattern).await.unwrap();",
        "        }",
        "",
        "        // Add connections to form a cycle",
        "        let mut graph = memory.graph.write().await;",
        "        let idx0 = memory.node_index.get(\"pattern0\").unwrap();",
        "        let idx1 = memory.node_index.get(\"pattern1\").unwrap();",
        "        let idx2 = memory.node_index.get(\"pattern2\").unwrap();",
        "",
        "        for (from, to) in &[(*idx0, *idx1), (*idx1, *idx2), (*idx2, *idx0)] {",
        "            graph.add_edge("
      ],
      "suggestion": "Use .get().ok_or_else(|| Error::NotFound)? or pattern matching"
    },
    {
      "file": "src/synthex_bashgod/memory/graph.rs",
      "line": 731,
      "code": "let idx1 = memory.node_index.get(\"pattern1\").unwrap();",
      "context": [
        "        }",
        "",
        "        // Add connections to form a cycle",
        "        let mut graph = memory.graph.write().await;",
        "        let idx0 = memory.node_index.get(\"pattern0\").unwrap();",
        "        let idx1 = memory.node_index.get(\"pattern1\").unwrap();",
        "        let idx2 = memory.node_index.get(\"pattern2\").unwrap();",
        "",
        "        for (from, to) in &[(*idx0, *idx1), (*idx1, *idx2), (*idx2, *idx0)] {",
        "            graph.add_edge(",
        "                *from,"
      ],
      "suggestion": "Use .get().ok_or_else(|| Error::NotFound)? or pattern matching"
    },
    {
      "file": "src/synthex_bashgod/memory/graph.rs",
      "line": 732,
      "code": "let idx2 = memory.node_index.get(\"pattern2\").unwrap();",
      "context": [
        "",
        "        // Add connections to form a cycle",
        "        let mut graph = memory.graph.write().await;",
        "        let idx0 = memory.node_index.get(\"pattern0\").unwrap();",
        "        let idx1 = memory.node_index.get(\"pattern1\").unwrap();",
        "        let idx2 = memory.node_index.get(\"pattern2\").unwrap();",
        "",
        "        for (from, to) in &[(*idx0, *idx1), (*idx1, *idx2), (*idx2, *idx0)] {",
        "            graph.add_edge(",
        "                *from,",
        "                *to,"
      ],
      "suggestion": "Use .get().ok_or_else(|| Error::NotFound)? or pattern matching"
    }
  ],
  "good_practices": [
    {
      "file": "src/infrastructure.rs",
      "pattern": "Custom error mapping",
      "example": ".map_err(|e| CoreError::Infrastructure(format!(\"Thread pool error: {}\", e)))?;"
    },
    {
      "file": "src/async_helpers.rs",
      "pattern": "Custom error mapping",
      "example": ".map_err(|e| PyRuntimeError::new_err(format!(\"Failed to create runtime: {}\", e)))?;"
    },
    {
      "file": "src/security_enhanced.rs",
      "pattern": "Custom error mapping",
      "example": ".map_err(|e| CoreError::Security(format!(\"Invalid base path: {}\", e)))?;"
    },
    {
      "file": "src/memory_mapped.rs",
      "pattern": "Custom error mapping",
      "example": ".map_err(|e| CoreError::Io(e))?;"
    },
    {
      "file": "src/simd_ops.rs",
      "pattern": "Custom error mapping",
      "example": "simd_matrix_multiply(&a, &b).map_err(|e| e.into())"
    },
    {
      "file": "src/zero_copy_net.rs",
      "pattern": "Custom error mapping",
      "example": ".map_err(|e| CoreError::Io(e))?;"
    },
    {
      "file": "src/ffi_security.rs",
      "pattern": "Custom error mapping",
      "example": ".map_err(|_| PyRuntimeError::new_err(\"Encryption failed\"))?;"
    },
    {
      "file": "src/lib.rs",
      "pattern": "Custom error mapping",
      "example": "circle_of_experts::init().map_err(|e| PyErr::new::<pyo3::exceptions::PyRuntimeError, _>(format!(\"Failed to initialize Circle of Experts: {}\", e)))?;"
    },
    {
      "file": "src/security.rs",
      "pattern": "Custom error mapping",
      "example": ".map_err(|_| CoreError::Security(\"Encryption failed\".to_string()).into())"
    },
    {
      "file": "src/services/health_check.rs",
      "pattern": "Custom error mapping",
      "example": ".map_err(|e| ServiceError::HealthCheckFailed(e.to_string()))?;"
    },
    {
      "file": "src/orchestrator/executor.rs",
      "pattern": "Custom error mapping",
      "example": ".map_err(|_| OrchestratorError::ResourceLimitExceeded("
    },
    {
      "file": "src/orchestrator/engine.rs",
      "pattern": "Custom error mapping",
      "example": ".map_err(|_| OrchestratorError::ResourceLimitExceeded("
    },
    {
      "file": "src/mcp_manager/actor.rs",
      "pattern": "Custom error mapping",
      "example": ".map_err(|_| McpError::RuntimeShutdown)?;"
    },
    {
      "file": "src/mcp_manager/connection_pool.rs",
      "pattern": "Custom error mapping",
      "example": ".map_err(|e| McpError::SerializationError(e.to_string()))?;"
    },
    {
      "file": "src/mcp_manager/manager_v2.rs",
      "pattern": "Custom error mapping",
      "example": ".map_err(|_| crate::mcp_manager::errors::McpError::InternalError("
    },
    {
      "file": "src/mcp_manager/python_bindings.rs",
      "pattern": "Custom error mapping",
      "example": ".map_err(|e| PyRuntimeError::new_err(format!(\"Failed to create runtime: {}\", e)))?;"
    },
    {
      "file": "src/mcp_manager/protocol.rs",
      "pattern": "Custom error mapping",
      "example": ".map_err(|e| MCPError::Connection(e.to_string()))?;"
    },
    {
      "file": "src/network/mod.rs",
      "pattern": "Custom error mapping",
      "example": ".map_err(|e| crate::orchestrator::OrchestratorError::NetworkAllocationFailed(e.to_string()))?;"
    },
    {
      "file": "src/synthex_bash_god/python_bindings.rs",
      "pattern": "Custom error mapping",
      "example": ".map_err(|e| PyRuntimeError::new_err(format!(\"Failed to create runtime: {}\", e)))?;"
    },
    {
      "file": "src/circle_of_experts/python_bindings.rs",
      "pattern": "Custom error mapping",
      "example": ".map_err(|e| PyErr::new::<pyo3::exceptions::PyRuntimeError, _>(e.to_string()))?;"
    },
    {
      "file": "src/circle_of_experts/mod.rs",
      "pattern": "Custom error mapping",
      "example": ".map_err(|e| CoreError::CircleOfExperts(format!(\"Failed to initialize thread pool: {}\", e)))?;"
    },
    {
      "file": "src/learning_engine/optimizer.rs",
      "pattern": "Uses error context (anyhow)",
      "example": "let result = best_result.context(\"No optimization strategy produced valid results\")?;"
    },
    {
      "file": "src/learning_engine/optimizer.rs",
      "pattern": "Custom error mapping",
      "example": ".map_err(|_| anyhow::anyhow!(\"Cyclic dependencies detected\"))?;"
    },
    {
      "file": "src/learning_engine/predictor.rs",
      "pattern": "Uses error context (anyhow)",
      "example": ".context(\"Failed to create feature tensor\")"
    },
    {
      "file": "src/synthex_bashgod/execution.rs",
      "pattern": "Custom error mapping",
      "example": ".map_err(|e| BashGodError::Execution(format!(\"Failed to acquire permit: {}\", e)))?;"
    },
    {
      "file": "src/synthex_bashgod/actor.rs",
      "pattern": "Custom error mapping",
      "example": ".map_err(|_| SBGError::ExecutionError(\"Command timed out\".to_string()))? .map_err(|e| SBGError::ExecutionError(e.to_string()))?;"
    },
    {
      "file": "src/synthex_bashgod/service.rs",
      "pattern": "Custom error mapping",
      "example": ".map_err(|_| SBGError::ActorError(\"Failed to send stats request\".to_string()))?;"
    },
    {
      "file": "src/synthex_bashgod/supervisor.rs",
      "pattern": "Custom error mapping",
      "example": ".map_err(|_| BashGodError::Supervision(\"Failed to send shutdown\".to_string()))?;"
    },
    {
      "file": "src/synthex_bashgod/distributed.rs",
      "pattern": "Custom error mapping",
      "example": ".map_err(|e| BashGodError::Runtime(format!(\"Failed to bind: {}\", e)))?;"
    },
    {
      "file": "src/synthex_bashgod/python_bindings.rs",
      "pattern": "Custom error mapping",
      "example": ".map_err(|e| PyRuntimeError::new_err(format!(\"Failed to create runtime: {}\", e)))?;"
    },
    {
      "file": "src/synthex/service.rs",
      "pattern": "Custom error mapping",
      "example": ".map_err(|e| crate::synthex::SynthexError::IoError(e.to_string()))?;"
    },
    {
      "file": "src/synthex/bashgod_optimizer.rs",
      "pattern": "Custom error mapping",
      "example": ".map_err(|e| anyhow!(\"Execution failed: {}\", e))?;"
    },
    {
      "file": "src/synthex/python_bindings.rs",
      "pattern": "Custom error mapping",
      "example": ".map_err(|e| PyErr::new::<pyo3::exceptions::PyRuntimeError, _>("
    },
    {
      "file": "src/synthex/engine.rs",
      "pattern": "Custom error mapping",
      "example": ".map_err(|_| crate::synthex::SynthexError::TimeoutError(query.options.timeout_ms))?;"
    },
    {
      "file": "src/mcp_manager/fusion/command_router.rs",
      "pattern": "Custom error mapping",
      "example": ".map_err(|e| McpError::ExecutionError(format!(\"Bash execution failed: {}\", e)))?;"
    },
    {
      "file": "src/mcp_manager/fusion/cross_tool.rs",
      "pattern": "Custom error mapping",
      "example": ".map_err(|e| McpError::Internal(format!(\"Failed to acquire permit: {}\", e)))?;"
    },
    {
      "file": "src/mcp_manager/protocols/websocket.rs",
      "pattern": "Uses error context (anyhow)",
      "example": "let url = Url::parse(&url).context(\"Invalid WebSocket URL\")?;"
    },
    {
      "file": "src/mcp_manager/protocols/http.rs",
      "pattern": "Uses error context (anyhow)",
      "example": "key.parse().context(\"Invalid header name\")?,"
    },
    {
      "file": "src/mcp_manager/protocols/http.rs",
      "pattern": "Custom error mapping",
      "example": ".map_err(|e| {"
    },
    {
      "file": "src/mcp_manager/plugins/kubernetes.rs",
      "pattern": "Custom error mapping",
      "example": ".map_err(|e| PluginError::InitializationFailed("
    },
    {
      "file": "src/mcp_manager/plugins/docker.rs",
      "pattern": "Custom error mapping",
      "example": ".map_err(|e| PluginError::ExecutionError(format!(\"Failed to execute docker: {}\", e)))?;"
    },
    {
      "file": "src/mcp_manager/plugins/prometheus.rs",
      "pattern": "Custom error mapping",
      "example": ".map_err(|e| PluginError::InitializationFailed("
    },
    {
      "file": "src/mcp_manager/plugin/loader.rs",
      "pattern": "Custom error mapping",
      "example": "Library::new(path).map_err(|e| {"
    },
    {
      "file": "src/mcp_manager/plugin/schema.rs",
      "pattern": "Custom error mapping",
      "example": ".map_err(|e| PluginError::InvalidManifest("
    },
    {
      "file": "src/mcp_manager/plugin/hot_reload.rs",
      "pattern": "Custom error mapping",
      "example": ".map_err(|e| PluginError::InvalidManifest(format!(\"Invalid version: {}\", e)))?;"
    },
    {
      "file": "src/mcp_manager/plugin/rollback.rs",
      "pattern": "Custom error mapping",
      "example": ".map_err(|e| PluginError::InvalidManifest(format!(\"Invalid version: {}\", e)))?;"
    },
    {
      "file": "src/mcp_manager/plugin/discovery.rs",
      "pattern": "Custom error mapping",
      "example": "let glob = Glob::new(pattern).map_err(|e| {"
    },
    {
      "file": "src/mcp_manager/plugin/mod.rs",
      "pattern": "Custom error mapping",
      "example": ".map_err(|_| PluginError::InvalidManifest("
    },
    {
      "file": "src/mcp_manager/plugin/state_transfer.rs",
      "pattern": "Custom error mapping",
      "example": ".map_err(serde::de::Error::custom)"
    },
    {
      "file": "src/mcp_manager/resilience/chaos.rs",
      "pattern": "Custom error mapping",
      "example": ".map_err(|_| anyhow!(\"Failed to send abort signal\"))?;"
    },
    {
      "file": "src/mcp_manager/resilience/bulkhead.rs",
      "pattern": "Custom error mapping",
      "example": ".map_err(|_| McpError::Other(format!(\"Bulkhead {} closed\", self.name)))?;"
    },
    {
      "file": "src/synthex_bashgod/memory/tensor.rs",
      "pattern": "Custom error mapping",
      "example": ").map_err(|e| SBGError::MemoryError(e.to_string()))?;"
    },
    {
      "file": "src/synthex_bashgod/mcp_integration/server_manager.rs",
      "pattern": "Custom error mapping",
      "example": ".map_err(|e| SBGError::MCPError(format!(\"Request failed: {}\", e)))?;"
    },
    {
      "file": "src/synthex_bashgod/learning/predictor.rs",
      "pattern": "Custom error mapping",
      "example": ".map_err(|e| SBGError::LearningError(e.to_string()))?,"
    },
    {
      "file": "src/synthex/tests/agent_tests.rs",
      "pattern": "Uses error context (anyhow)",
      "example": ""
    },
    {
      "file": "src/synthex/tests/integration_tests.rs",
      "pattern": "Uses error context (anyhow)",
      "example": ""
    },
    {
      "file": "src/synthex/tests/query_tests.rs",
      "pattern": "Uses error context (anyhow)",
      "example": ""
    },
    {
      "file": "src/synthex/tests/test_utils.rs",
      "pattern": "Uses error context (anyhow)",
      "example": ""
    },
    {
      "file": "src/synthex/tests/mcp_v2_tests.rs",
      "pattern": "Uses error context (anyhow)",
      "example": ""
    }
  ]
}